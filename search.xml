<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PrepareStatement相较于Statement]]></title>
    <url>%2F2019%2F09%2F11%2Fstatement%2F</url>
    <content type="text"><![CDATA[二者区别1.PreparedStatement是预编译的,对于批量处理可以大大提高效率. 也叫JDBC存储过程2.使用 Statement 对象。在对数据库只执行一次性存取的时侯，用 Statement 对象进行处理。PreparedStatement 对象的开销比Statement大，对于一次性操作并不会带来额外的好处。 3.Statement每次执行sql语句，相关数据库都要执行sql语句的编译，Preparedstatement是预编译得, Preparedstatement支持批处理 4、 Code Fragment 1: 12String updateString = "UPDATE COFFEES SET SALES = 75 " + "WHERE COF_NAME LIKE ′Colombian′";stmt.executeUpdate(updateString); Code Fragment 2: 1234PreparedStatement updateSales = con.prepareStatement("UPDATE COFFEES SET SALES = ? WHERE COF_NAME LIKE ? ");updateSales.setInt(1, 75);updateSales.setString(2, "Colombian");updateSales.executeUpdate; 片断2和片断1的区别在于，后者使用了PreparedStatement对象，而前者是普通的Statement对象。PreparedStatement对象不仅包含了SQL语句，而且大多数情况下这个语句已经被预编译过，因而当其执行时，只需DBMS运行SQL语句，而不必先编译。当你需要执行Statement对象多次的时候，PreparedStatement对象将会大大降低运行时间，当然也加快了访问数据库的速度。 这种转换也给你带来很大的便利，不必重复SQL语句的句法，而只需更改其中变量的值，便可重新执行SQL语句。选择PreparedStatement对象与否，在于相同句法的SQL语句是否执行了多次，而且两次之间的差别仅仅是变量的不同。如果仅仅执行了一次的话，它应该和普通的对象毫无差异，体现不出它预编译的优越性。 5.执行许多SQL语句的JDBC程序产生大量的Statement和PreparedStatement对象。通常认为PreparedStatement对象比Statement对象更有效,特别是如果带有不同参数的同一SQL语句被多次执行的时候。PreparedStatement对象允许数据库预编译SQL语句，这样在随后的运行中可以节省时间并增加代码的可读性。 然而，在Oracle环境中，开发人员实际上有更大的灵活性。当使用Statement或PreparedStatement对象时，Oracle数据库会缓存SQL语句以便以后使用。在一些情况下,由于驱动器自身需要额外的处理和在Java应用程序和Oracle服务器间增加的网络活动，执行PreparedStatement对象实际上会花更长的时间。 然而，除了缓冲的问题之外，至少还有一个更好的原因使我们在企业应用程序中更喜欢使用PreparedStatement对象,那就是安全性。传递给PreparedStatement对象的参数可以被强制进行类型转换，使开发人员可以确保在插入或查询数据时与底层的数据库格式匹配。 当处理公共Web站点上的用户传来的数据的时候，安全性的问题就变得极为重要。传递给PreparedStatement的字符串参数会自动被驱动器忽略。最简单的情况下，这就意味着当你的程序试着将字符串“D’Angelo”插入到VARCHAR2中时，该语句将不会识别第一个“，”，从而导致悲惨的失败。几乎很少有必要创建你自己的字符串忽略代码。 在Web环境中，有恶意的用户会利用那些设计不完善的、不能正确处理字符串的应用程序。特别是在公共Web站点上,在没有首先通过PreparedStatement对象处理的情况下，所有的用户输入都不应该传递给SQL语句。此外，在用户有机会修改SQL语句的地方，如HTML的隐藏区域或一个查询字符串上，SQL语句都不应该被显示出来。 在执行SQL命令时，我们有二种选择：可以使用PreparedStatement对象，也可以使用Statement对象。无论多少次地使用同一个SQL命令，PreparedStatement都只对它解析和编译一次。当使用Statement对象时，每次执行一个SQL命令时，都会对它进行解析和编译。 第一： prepareStatement会先初始化SQL，先把这个SQL提交到数据库中进行预处理，多次使用可提高效率。 Statement不会初始化，没有预处理，没次都是从0开始执行SQL 第二： prepareStatement可以替换变量 在SQL语句中可以包含?，可以用 1234ps=conn.prepareStatement("select * from Cust where ID=?"); int sid=1001; ps.setInt(1, sid); rs = ps.executeQuery(); 可以把?替换成变量。 而Statement只能用如下代码实现。 123int sid=1001; Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("select * from Cust where ID="+sid); 使用Statement而不是PreparedStatement对象JDBC驱动的最佳化是基于使用的是什么功能. 选择PreparedStatement还是Statement取决于你要怎么使用它们. 对于只执行一次的SQL语句选择Statement是最好的. 相反, 如果SQL语句被多次执行选用PreparedStatement是最好的. PreparedStatement的第一次执行消耗是很高的. 它的性能体现在后面的重复执行. 例如, 假设我使用Employee ID, 使用prepared的方式来执行一个针对Employee表的查询. JDBC驱动会发送一个网络请求到数据解析和优化这个查询. 而执行时会产生另一个网络请求.在JDBC驱动中，减少网络通讯是最终的目的. 如果我的程序在运行期间只需要一次请求, 那么就使用Statement. 对于Statement, 同一个查询只会产生一次网络到数据库的通讯. 对于使用PreparedStatement池的情况下, 本指导原则有点复杂. 当使用PreparedStatement池时, 如果一个查询很特殊, 并且不太会再次执行到, 那么可以使用Statement. 如果一个查询很少会被执行,但连接池中的Statement池可能被再次执行, 那么请使用PreparedStatement. 在不是Statement池的同样情况下, 请使用Statement. 使用PreparedStatement的Batch功能Update大量的数据时, 先Prepare一个INSERT语句再多次的执行, 会导致很多次的网络连接. 要减少JDBC的调用次数改善性能, 你可以使用PreparedStatement的AddBatch()方法一次性发送多个查询给数据库. 例如, 让我们来比较一下下面的例子. 例 1: 多次执行PreparedStatement，多次数据库请求（网络请求） 12345678PreparedStatement ps = conn.prepareStatement( "INSERT into employees values (?, ?, ?)"); for (n = 0; n &lt; 100; n++) &#123; ps.setString(name[n]); ps.setLong(id[n]); ps.setInt(salary[n]); ps.executeUpdate(); &#125; 例 2: 使用Batch，以此请求执行多条 123456789PreparedStatement ps = conn.prepareStatement( "INSERT into employees values (?, ?, ?)"); for (n = 0; n &lt; 100; n++) &#123; ps.setString(name[n]); ps.setLong(id[n]); ps.setInt(salary[n]); ps.addBatch(); &#125; ps.executeBatch(); 在例 1中, PreparedStatement被用来多次执行INSERT语句. 在这里, 执行了100次INSERT操作, 共有101次网络往返. 其中,1次往返是预储PreparedStatement, 另外100次往返执行每个迭代. 在例2中, 当在100次INSERT操作中使用addBatch()方法时, 只有两次网络往返. 1次往返是预储PreparedStatement, 另一次是执行batch命令. 虽然Batch命令会用到更多的数据库的CPU周期, 但是通过减少网络往返，性能得到提高.记住, JDBC的性能最大的增进是减少JDBC驱动与数据库之间的网络通讯.次数 注：Oracel 10G的JDBC Driver限制最大Batch size是16383条，如果addBatch超过这个限制，那么executeBatch时就会出现“无效的批值”（Invalid Batch Value） 异常。因此在如果使用的是Oracle10G，在此bug减少前，Batch size需要控制在一定的限度。 ​ 同样mysql 5.5.28 批量执行的数据最大限度是多少不清楚，但自己试了1w,2w,3w 都没问题，记得在url 后面添加：rewriteBatchedStatements=true 表示批量插入，如果不添加的话即使使用addbatch() ,executeBatch() 在后台入库的地方还是不会一次请求入库而是多次请求入库。 选择合适的光标类型的光标类型以最大限度的适用你的应用程序. 本节主要讨论三种光标类型的性能问题. 对于从一个表中顺序读取所有记录的情况来说, Forward-Only型的光标提供了最好的性能. 获取表中的数据时, 没有哪种方法比使用Forward-Only型的光标更快. 但不管怎样, 当程序中必须按无次序的方式处理数据行时, 这种光标就无法使用了. 对于程序中要求与数据库的数据同步以及要能够在结果集中前后移动光标, 使用JDBC的Scroll-Insensitive型光标是较理想的选择. 此类型的光标在第一次请求时就获取了所有的数据(当JDBC驱动采用’lazy’方式获取数据时或许是很多的而不是全部的数据)并且储存在客户端. 因此, 第一次请求会非常慢, 特别是请求长数据时会理严重. 而接下来的请求并不会造成任何网络往返(当使用’lazy’方法时或许只是有限的网络交通) 并且处理起来很快. 因为第一次请求速度很慢, Scroll-Insensitive型光标不应该被使用在单行数据的获取上. 当有要返回长数据时, 开发者也应避免使用Scroll-Insensitive型光标, 因为这样可能会造成内存耗尽. 有些Scroll-Insensitive型光标的实现方式是在数据库的临时表中缓存数据来避免性能问题, 但多数还是将数据缓存在应用程序中. Scroll-Sensitive型光标, 有时也称为Keyset-Driven光标, 使用标识符, 像数据库的ROWID之类. 当每次在结果集移动光标时, 会重新该标识符的数据. 因为每次请求都会有网络往返, 性能可能会很慢. 无论怎样, 用无序方式的返回结果行对性能的改善是没有帮助的. 现在来解释一下这个, 来看这种情况. 一个程序要正常的返回1000行数据到程序中. 在执行时或者第一行被请求时, JDBC驱动不会执行程序提供的SELECT语句. 相反, 它会用键标识符来替换SELECT查询, 例如, ROWID. 然后修改过的查询都会被驱动程序执行，跟着会从数据库获取所有1000个键值. 每一次对一行结果的请求都会使JDBC驱动直接从本地缓存中找到相应的键值, 然后构造一个包含了’WHERE ROWID=？’子句的最佳化查询, 再接着执行这个修改过的查询, 最后从服务器取得该数据行. 当程序无法像Scroll-Insensitive型光标一样提供足够缓存时, Scroll-Sensitive型光标可以被替代用来作为动态的可滚动的光标. 使用有效的getter方法JDBC提供多种方法从ResultSet中取得数据, 像getInt(), getString(), 和getObject()等等. 而getObject()方法是最泛化了的, 提供了最差的性能。 这是因为JDBC驱动必须对要取得的值的类型作额外的处理以映射为特定的对象. 所以就对特定的数据类型使用相应的方法. 要更进一步的改善性能, 应在取得数据时提供字段的索引号, 例如, getString(1), getLong(2), 和getInt(3)等来替代字段名. 如果没有指定字段索引号, 网络交通不会受影响, 但会使转换和查找的成本增加. 例如, 假设你使用getString(“foo”) … JDBC驱动可能会将字段名转为大写(如果需要), 并且在到字段名列表中逐个比较来找到”foo”字段. 如果可以, 直接使用字段索引, 将为你节省大量的处理时间. 例如, 假设你有一个100行15列的ResultSet, 字段名不包含在其中. 你感兴趣的是三个字段 EMPLOYEENAME (字串型), EMPLOYEENUMBER (长整型), 和SALARY (整型). 如果你指定getString(“EmployeeName”), getLong(“EmployeeNumber”), 和getInt(“Salary”), 查询旱每个字段名必须被转换为metadata中相对应的大小写, 然后才进行查找. 如果你使用getString(1), getLong(2), 和getInt(15). 性能就会有显著改善. 获取自动生成的键值有许多数据库提供了隐藏列为表中的每行记录分配一个唯一键值. 很典型, 在查询中使用这些字段类型是取得记录值的最快的方式, 因为这些隐含列通常反应了数据在磁盘上的物理位置. 在JDBC3.0之前, 应用程序只可在插入数据后通过立即执行一个SELECT语句来取得隐含列的值. 例 3: JDBC3.0之前 123456//插入行 int rowcount = stmt.executeUpdate ( "insert into LocalGeniusList (name) values ('Karen')"); // 现在为新插入的行取得磁盘位置 - rowid ResultSet rs = stmt.executeQuery ( "select rowid from LocalGeniusList where name = 'Karen'"); 这种取得隐含列的方式有两个主要缺点. 第一, 取得隐含列是在一个独立的查询中, 它要透过网络送到服务器后再执行. 第二, 因为不是主键, 查询条件可能不是表中的唯一性ID. 在后面一个例子中, 可能返回了多个隐含列的值, 程序无法知道哪个是最后插入的行的值. (译者：由于不同的数据库支持的程度不同，返回rowid的方式各有差异。在SQL Server中，返回最后插入的记录的id可以用这样的查询语句：SELECT @IDENTITY ) JDBC3.0规范中的一个可选特性提供了一种能力, 可以取得刚刚插入到表中的记录的自动生成的键值. 例 4: JDBC3.0之后 123456int rowcount = stmt.executeUpdate ( "insert into LocalGeniusList (name) values ('Karen')", // 插入行并返回键值 Statement.RETURN_GENERATED_KEYS); ResultSet rs = stmt.getGeneratedKeys (); // 得到生成的键值 现在, 程序中包含了一个唯一性ID, 可以用来作为查询条件来快速的存取数据行, 甚至于表中没有主键的情况也可以. 这种取得自动生成的键值的方式给JDBC的开发者提供了灵活性, 并且使存取数据的性能得到提升. 选择合适的数据类型接收和发送某些数据可能代价昂贵. 当你设计一个schema时, 应选择能被最有效地处理的数据类型. 例如, 整型数就比浮点数或实数处理起来要快一些. 浮点数的定义是按照数据库的内部规定的格式, 通常是一种压缩格式. 数据必须被解压和转换到另外种格式, 这样它才能被数据的协议处理. 获取ResultSet由于数据库系统对可滚动光标的支持有限, 许多JDBC驱动程序并没有实现可滚动光标. 除非你确信数据库支持可滚动光标的结果集, 否则不要调用rs.last()和rs.getRow()方法去找出数据集的最大行数. 因为JDBC驱动程序模拟了可滚动光标, 调用rs.last()导致了驱动程序透过网络移到了数据集的最后一行. 取而代之, 你可以用ResultSet遍历一次计数或者用SELECT查询的COUNT函数来得到数据行数. 通常情况下，请不要写那种依赖于结果集行数的代码, 因为驱动程序必须获取所有的数据集以便知道查询会返回多少行数据. preparestatement优点在JDBC应用中,如果你已经是稍有水平开发者,你就应该始终以PreparedStatement代替Statement.也就是说,在任何时候都不要使用Statement.基于以下的原因: 代码的可读性和可维护性虽然用PreparedStatement来代替Statement会使代码多出几行,但这样的代码无论从可读性还是可维护性上来说.都比直接用Statement的代码高很多档次: 1234stmt.executeUpdate("insert into tb_name (col1,col2,col2,col4) values ('"+var1+"','"+var2+"',"+var3+",'"+var4+"')");perstmt = con.prepareStatement("insert into tb_name (col1,col2,col2,col4) values (?,?,?,?)");perstmt.setString(1,var1);perstmt.setString(2,var2);perstmt.setString(3,var3);perstmt.setString(4,var4);perstmt.executeUpdate(); 不用我多说,对于第一种方法.别说其他人去读你的代码,就是你自己过一段时间再去读,都会觉得伤心. reparedStatement尽最大可能提高性能每一种数据库都会尽最大努力对预编译语句提供最大的性能优化.因为预编译语句有可能被重复调用.所以语句在被DB的编译器编译后的执行代码被缓存下来,那么下次调用时只要是相同的预编译语句就不需要编译,只要将参数直接传入编译过的语句执行代码中(相当于一个涵数)就会得到执行.这并不是说只有一个 Connection中多次执行的预编译语句被缓存,而是对于整个DB中,只要预编译的语句语法和缓存中匹配.那么在任何时候就可以不需要再次编译而可以直接执行.而statement的语句中,即使是相同一操作,而由于每次操作的数据不同所以使整个语句相匹配的机会极小,几乎不太可能匹配.比如:insert into tb_name (col1,col2) values (‘11’,’22’);insert into tb_name (col1,col2) values (‘11’,’23’);即使是相同操作但因为数据内容不一样,所以整个个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存.这样每执行一次都要对传入的语句编译一次. 当然并不是所以预编译语句都一定会被缓存,数据库本身会用一种策略,比如使用频度等因素来决定什么时候不再缓存已有的预编译结果.以保存有更多的空间存储新的预编译语句. 极大地提高了安全性即使到目前为止,仍有一些人连基本的恶义SQL语法都不知道. 1String sql = "select * from tb_name where name= '"+varname+"' and passwd='"+varpasswd+"'"; 如果我们把[‘ or ‘1’ = ‘1]作为varpasswd传入进来.用户名随意,看看会成为什么? 1select * from tb_name = &apos;随意&apos; and passwd = &apos;&apos; or &apos;1&apos; = &apos;1&apos;; 因为’1’=’1’肯定成立,所以可以任何通过验证.更有甚者:把[‘;drop table tb_name;]作为varpasswd传入进来,则:select * from tb_name = ‘随意’ and passwd = ‘’;drop table tb_name;有些数据库是不会让你成功的,但也有很多数据库就可以使这些语句得到执行. 而如果你使用预编译语句.你传入的任何内容就不会和原来的语句发生任何匹配的关系.(前提是数据库本身支持预编译,但上前可能没有什么服务端数据库不支持编译了,只有少数的桌面数据库,就是直接文件访问的那些)只要全使用预编译语句,你就用不着对传入的数据做任何过虑.而如果使用普通的statement, 有可能要对drop,;等做费尽心机的判断和过虑. 上面的几个原因,还不足让你在任何时候都使用PreparedStatement吗? 总结： 上面是三篇文章，三篇文章详细介绍了statement 和preparestatement 两个对象的使用以及效率、安全问题。在实际项目中如果能够使用preparestatement 还是建议使用preparestatement 原因有3： 1）上面说了 如果sql中只有数值在变则效率高 2）preparestatement 具有防sql注入 3）代码可读性比较好 实例：下面这个比喻很好，很明确的说明了批量添加，并且从中也可以看出在批量添加的时候PreparedStatement为什么比Statement快的原因~ Statement和PreparedStatement的区别就不多废话了,直接说PreparedStatement最重要的addbatch()结构的使用. PreparedStatement 的addBatch和executeBatch实现批量添加1.建立链接 1Connection connection =getConnection(); 2.不自动 Commit (瓜子不是一个一个吃,全部剥开放桌子上,然后一口舔了) 1connection.setAutoCommit(false); 3.预编译SQL语句,只编译一回哦,效率高啊.(发明一个剥瓜子的方法,以后不要总想怎么剥瓜子好.就这样剥.) 1PreparedStatement statement = connection.prepareStatement("INSERT INTO TABLEX VALUES(?, ?)"); 4.来一个剥一个,然后放桌子上 记录1 123statement.setInt(1, 1);statement.setString(2, "Cujo");statement.addBatch(); 记录2 123statement.setInt(1, 2);statement.setString(2, "Fred");statement.addBatch(); 记录3 123statement.setInt(1, 3);statement.setString(2, "Mark");statement.addBatch(); 批量执行上面3条语句. 一口吞了,很爽 1int [] counts = statement.executeBatch(); Commit it 咽下去,到肚子(DB)里面 1connection.commit(); statement 对象的addBatch 和 executeBatch 来实现批量添加 123456789101112stmt.addBatch("update TABLE1 set 题目="盛夏话足部保健1" where id="3407"");stmt.addBatch("update TABLE1 set 题目="夏季预防中暑膳食1" where id="3408"");stmt.addBatch("INSERT INTO TABLE1 VALUES("11","12","13","","")");stmt.addBatch("INSERT INTO TABLE1 VALUES("12","12","13","","")");stmt.addBatch("INSERT INTO TABLE1 VALUES("13","12","13","","")");stmt.addBatch("INSERT INTO TABLE1 VALUES("14","12","13","","")");stmt.addBatch("INSERT INTO TABLE1 VALUES("15","12","13","","")");stmt.addBatch("INSERT INTO TABLE1 VALUES("16","12","13","","")");stmt.addBatch("INSERT INTO TABLE1 VALUES("17","12","13","","")");stmt.addBatch("INSERT INTO TABLE1 VALUES("18","12","13","","")");int [] updateCounts=stmt.executeBatch();cn.commit(); 实例：批量添加1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void insertData(List&lt;Map&lt;String,String&gt;&gt; list,Logger log)&#123; //获取的数据 List &lt;Map&lt;String,String&gt;&gt; nlist= list; String upsql="update hrd_staff set position =? where id=?"; Iterator&lt;Map&lt;String,String&gt;&gt; iter= nlist.iterator(); Connection con= Utils.getCon(); int count=0; try &#123; //在皮脸添加的时候注意事务提交方式 con.setAutoCommit(false); //PreparedStatement方法的使用 PreparedStatement pstm = con.prepareStatement(upsql); while(iter.hasNext())&#123; count++; Map&lt;String,String&gt; map= iter.next(); String jon_name= map.get("job_name"); String uid= map.get("uid"); pstm.setString(1,jon_name); pstm.setString(2,uid); pstm.addBatch(); // 如果数据量很大，不能一次性批量添加所以我们要分批次添加，这里就是300条一次 if(count%300==0)&#123; //持久化 int []res=pstm.executeBatch(); //提交事务，持久化数据 con.commit(); pstm.clearBatch(); log.info("300整除插入结果: "+res.length); &#125; &#125; //小于300条的在这里持久化 int []ress= pstm.executeBatch(); //事务提交持久化 con.commit(); pstm.clearBatch(); log.info("插入数据结果："+ress.length); &#125; catch (SQLException e) &#123; try &#123; con.rollback(); &#125; catch (SQLException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally&#123; try &#123; if(null!=con)&#123; con.close(); con.setAutoCommit(true); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 这里除了下面说的url中的批量设置外，我们也要注意事务的设置，不能设置为自动提交，要批量添加后在提交事务. 总结addBatch() 就是把你的处理内容添加到批处理单元中。即添加到了batch中。你可以循环加入很多，数据库都不会处理，直到调用如下代码executeBatch() 此时，数据库把刚才加到batch中的命令批量处理。 使用批量插入的好处： , 当在100次INSERT操作中使用addBatch()方法时, 只有两次网络往返. 1次往返是预储statement, 另一次是执行batch命令. 虽然Batch命令会用到更多的数据库的CPU周期, 但是通过减少网络往返，性能得到提高. 记住, JDBC的性能最大的增进是减少JDBC驱动与数据库之间的网络通讯. 如果没有使用批处理则网络往返101次这样会耗很多时间，自然效率也就一般 这里要注意：在mysql 下使用批量执行的时候要在，url 后面添加手动设置支持批量添加 实例如下： 1String url="jdbc:mysql://localhost:3306/music?rewriteBatchedStatements=true"; 默认情况下rewriteBatchedStatements 的值为false 也就是批量添加功能是关闭的，如果使用则要手动开启！还有就是事务的设置，不能使自动提交，要批量添加后才提交！！！]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节流拷贝文件]]></title>
    <url>%2F2019%2F09%2F11%2FIO4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142public class ByteCopy &#123; public static void main(String[] args) &#123; File f_s = new File("d:\\2.txt"); // 要拷贝的文件对象 File f_d = new File("e:/yxm"); // 要拷贝到的路径 if (!f_d.exists()) &#123; // 判断要拷贝到的路径是否存在，不存在就创建 f_d.mkdirs(); &#125; File f_dd = new File(f_d, "7s.txt"); FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(f_s); fos = new FileOutputStream(f_dd); byte[] byteTemp = new byte[1024]; while(fis.read(byteTemp) != -1)&#123; int size =byteTemp.length; fos.write(byteTemp,0,size); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fis != null) &#123; fos.close(); &#125; if (fos != null) &#123; fis.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流拷贝文件]]></title>
    <url>%2F2019%2F09%2F11%2FIO3%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839public class CharCopy &#123; public static void main(String[] args) &#123; File f_s = new File("d:\\2.txt"); // 要拷贝的文件对象 File f_d = new File("e:/yxm"); // 要拷贝到的路径 if (!f_d.exists()) &#123; // 判断要拷贝到的路径是否存在，不存在就创建 f_d.mkdirs(); &#125; File f_dd = new File(f_d, "7s.txt"); FileReader fis = null; FileWriter fos = null; try &#123; fis = new FileReader(f_s); fos = new FileWriter(f_dd); char[] charTemp = new char[1]; while (fis.read(charTemp) != -1) &#123; int size = charTemp.length; fos.write(charTemp, 0, size); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fis != null) &#123; fos.close(); &#125; if (fos != null) &#123; fis.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java往文件中写数据,新写入的数据总是覆盖原有数据,实现追加功能]]></title>
    <url>%2F2019%2F09%2F11%2FIO2%2F</url>
    <content type="text"><![CDATA[原文链接12345678910111213141516171819202122232425262728293031323334353637import java.io.BufferedWriter;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.RandomAccessFile;/** * 描述：追加内容到文件末尾 * @author Administrator */ public class WriteStreamAppend &#123; public static void main(String[] args) &#123; method2("/Users/zhang/Desktop/test.txt", "追加到文件的末尾"); &#125; /** * 第一种 * 追加文件：使用FileOutputStream，在构造FileOutputStream时， 把第二个参数设为true * @param fileName * @param content */ public static void method1(String file, String conent) &#123; BufferedWriter out = null; try &#123; out = new BufferedWriter(new OutputStreamWriter( new FileOutputStream(file, true))); out.write(conent); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041 /** * * 第二种 * 追加文件：使用FileWriter * @param fileName * @param content */ public static void method2(String fileName, String content) &#123; try &#123; // 打开一个写文件器，构造函数中的第二个参数true表示以追加形式写文件 FileWriter writer = new FileWriter(fileName, true); writer.write(content); writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** *第三种 * 追加文件：使用RandomAccessFile * @param fileName * 文件名 * @param content * 追加的内容 */ public static void method3(String fileName, String content) &#123; try &#123; // 打开一个随机访问文件流，按读写方式 RandomAccessFile randomFile = new RandomAccessFile(fileName, "rw"); // 文件长度，字节数 long fileLength = randomFile.length(); // 将写文件指针移到文件尾。 randomFile.seek(fileLength); randomFile.writeBytes(content); randomFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC相关内容]]></title>
    <url>%2F2019%2F09%2F11%2Fjdbc%2F</url>
    <content type="text"><![CDATA[JDBC概念 JDBC（Java Data Base Connectivity）是一种用于执行SQL语句的Java API，可以为多种数据库提供统一访问。换句话说,JDBC充当了Java应用程序与各种数据库之间的桥梁。SUN公司（Java原来的母公司）提供了JDBC的接口规范——JDBC API，而数据库厂商按照该接口规范提供了针对自己数据库的具体实现——JDBC驱动。 JDBC工作原理 JDBC API主要做三件事：连接数据库，发送SQL语句，处理结果 JDBC API中常用的类和接口: 方法名 说 明 DriverManager类 根据不同的数据库管理相应的JDBC驱动 Connection接口 负责连接数据库 Statement接口 发送SQL语句 ResultSet接口 保存和处理SQL语句的查询结果 PreparedStatement接口 Statement的子接口，负责发送SQL语句，但是优于Statement 使用JDBC访问数据库的步骤(1) 从相关数据库厂商的官方网站上下载JDBC驱动，并导入到项目中 (2) 加载JDBC驱动 使用Class.forName()方法可以把给定的一个JDBC驱动类加载到Java虚拟机中。 Class.forName(“驱动类名称“); (3) 连接数据库 DriverManager类属于JDBC的驱动管理类，主要负责在数据库和相应的驱动之间建立连接。通过该类的getConnection()方法可以连接数据库，当调用该方法时，DriverManager类会首先从已加载的驱动中找到一个合适的驱动类，然后通过数据库连接字符串（URL）、用户名和密码连接数据库。 1Connection conn=DriverManager.getConnection(“数据库连接字符串”, “数据库用户名”, “登录密码”); (4) 发送SQL语句并获得返回结果 连接上数据库后就可以通过该连接创建Statement或PreparedStatement接口的对象，该对象可以发送SQL语句到数据库。如果是查询操作将返回一个包含查询数据的ResultSet结果集，如果是增、删、改操作将返回受影响的行数。 1Statement stmt=conn.createStatement(); ResultSet rs=stmt.executeQuery(“ SQL查询语句”); (5) 处理返回结果 这里主要处理的是查询操作所返回的ResultSet结果集，通过循环可以把结果集中的数据取出来。 1234while( rs.next() )&#123; int id=rs.getInt(“列名”); String name=rs.getString("列名"); &#125; EG: JDBC应用 两种常用的驱动方式： 名称 优点 缺点 JDBC—ODBC桥连方式 可以访问几乎所有的数据库，不需要任何驱动 效率低、只能在Windows上 纯Java驱动 也可以访问几乎所有的数据库，执行效率高，可以跨平台 需要下载专用的JDBC驱动 常见的数据库的驱动类和连接URL: 123456789101112SQL2008: Driver: com.microsoft.sqlserver.jdbc.SQLServerDriverURL: jdbc:sqlserver://127.0.0.1:1433;databaseName=数据库名称Oracle: Driver: oracle.jdbc.driver.OracleDriverURL: jdbc:oracle:thin:@localhost:1521:dbname MySQL:Driver: com.mysql.jdbc.DriverURL: jdbc:mysql://localhost:3306/数据库名称JDBC-ODBC: Driver: sun.jdbc.odbc.JdbcOdbcDriver URL: jdbc:odbc:数据源名称** Connection接口的常用方法 方法名 说明 Statement createStatement() 创建Statement对象 PreparedStatement preparedStatement(String sql) 创建PreparedStatement对象 CallableStatement prepareCall(String sql) 创建CallableStatement对象 void setAutoCommit(boolean flag) 设置是否自动提交事务 void rollback() 回滚事务 void commit() 提交事务 void close() 关闭数据库连接 问： Connection对象如果忘记 close()会出现什么情况？ connection不及时关闭的话会造成内存泄漏（也称作”存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。(其实说白了就是该内存空间使用完毕之后未回收)），影响性能。 请从面向对象的角度，思考Connection对象为何不能new？ Statement接口Statement接口主要负责发送各种SQL语句，该接口引用的对象由Connection接口的createStatement()方法创建。 下表列出了该接口的常用方法 方法名 说明 int executeUpdate(String sql) 发送增删改语句，并返回受影响的行数 ResultSet executeQuery(String sql) 发送查询语句，并返回结果集对象 void close() 关闭Statement释放资源 ResultSet接口 方法名 说明 boolean next() 定位到下一行 void close() 关闭ResultSet 对象 Xxx getXxx(int colIndex) 参数表示列的索引，从1开始 Xxx getXxx(String colLabel) 参数表示列的名字 注： Xxx表示某种数据类型，例如int、String等，跟数据库里表中列的数据类型对应，例如我们要取age这一列的数据就需要使用getInt()方法。 结果集(ResultSet)是数据中查询结果返回的一种对象，可以说结果集是一个存储查询结果的对象，但是结果集并不仅仅具有存储的功能，他同时还具有操纵数据的功能，可能完成对数据的更新等。 在jdbc中使用ResultSet的时候，会长期占用数据库连接的资源，在操作大量数据时，会有很大的困难。所以会使用List,可以直接对数据进行操作。 返回对象集合List是个集合接口，只要是集合类接口都会使用迭代器，来对数据进行遍历。Iterator it=List.iterator(); 用add()方法添加新的对象。 注入式攻击所谓SQL注入式攻击，就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令 preparedStatement 相较于Statement 优点： 1.增强代码的可读性和维护性 2.提高执行效率 3.增强安全性，避免出现SQL注入 4.更加灵活 CallableStatement（专门用来调用存储过程）该接口定义的常用方法 方法名 说 明 executeQuery() 一般用于调用查询结果是多行的存储过程 execute() 一般用于调用结果是单个值的存储过程 registerOutParameter(String parameName,int sqlType) 注册存储过程的输出参数 具体语法如下所示1conn.prepareCall ( "&#123;call 存储过程名()&#125;" ) ; 调用无参存储过程 调用有输入参数的存储过程 调用带有输出参数的存储过程 调用带return的存储过程 可滚动结果集语法如下所示： 1conn.createStatement(int resultSetType, int resultSetConcurrency); conn.prepareStatement(String sql,int resultSetType,int resultSetConcurrency); 下表列出了参数：resultSetType的取值（这些值通过ResultSet打点调用）： resultSetType取值 说明 FETCH_FORWARD 正向(由始至尾)移动或处理结果集中的行，源表中数据修改后不能反映到结果集中。 FETCH_REVERSE 逆向(由尾至始)移动或处理结果集中的行，源表中数据修改后不能反映到结果集中。 TYPE_FORWARD_ONLY 正向(由始至尾)移动或处理结果集中的行，源表中数据修改后可以反映到结果集中 TYPE_SCROLL_INSENSITIVE 结果集可任意滚动,不允许修改结果集，源表中数据修改后不能反映到结果集中 TYPE_SCROLL_SENSITIVE 结果集可任意滚动，允许修改结果集，源表中数据修改后可以反映到结果集中。 TYPE_FORWARD_ONLY和 CONCUR_READ_ONLY，即只能向前滚动的只读结果集，也就是我们一直用的普通结果集。 如果使用了表格中最后的两个参数，则在获得了指定类型的结果集后，我们可以通过ResultSet的相关方法非常方便、快速的定位记录 这些方法如下表所示： 方法名称 说明 boolean absolute(int row) 定位到指定行编号的记录上 boolean first() 定位到第一行 boolean last() 定位到最后一行 boolean next() 从前往后移动一行 boolean previous() 从后往前移动一行 boolean relative(int row) 按相对行数(正或负)进行移动relative(1)相当于next()relative(-1)相当于previous() 下表列出了参数：resultSetConcurrency的取值，它们用于设置结果集的并发操作类型，有两个取值： resultSetConcurrency取值 说明 CONCUR_READ_ONLY 不允许修改结果集 CONCUR_UPDATABLE 允许修改结果集 使用可滚动结果集能够非常方便、快速的对行进行定位，本例中的结果集是只读的，其实如果需要，我们也可以直接对结果集进行增、删、改、查等操作（当参数resultSetConcurrency取值为：CONCUR_UPDATABLE时）。 ResultSet常用操作数据的方法有： 方法名称 说明 void moveToInsertRow() 移动至待插入行 void deleteRow() 删除当前行 void updateXxx(String columnLabel,Xxx x) void updateXxx(int columnIndex,Xxx x) 修改行中的数据Xxx表示某种数据类型，跟列的数据类型有关第一个参数表示列的索引或者列名第二个参数表示列的新值 void updateRow() 将结果集修改过的数据更新到数据库 123456789101112&#125;catch(Exception e)&#123; e.printStackTrace();&#125;finally&#123; try&#123; rs.close(); stmt.close(); conn.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125;&#125;&#125; JDBC事务 eg:事务 eg:保存点 123456e1.printStackTrace();&#125;&#125;finally&#123;conn.commit();//提交事务&#125; JDBC批量操作PreparedStatement批量处理方法： 方法名 方法描述 addBatch() 将一组参数添加到此PreparedStatement对象的批处理命令中 executeBatch() 将一批命令提交给数据库来执行，如果全部命令执行成功，则返回更新计数组成的数组，父接口的方法 clearBatch() 清空此Statement对象的当前 SQL 命令列表，父接口的方法 eg: 注意： 使用pstmt.addBatch();加入缓存的时候；有个峰值，就是最高保存多少条SQL命令。 这个异常是内存溢出，内存中保存的数据超出了java堆空间的大小。 解决办法：分成多次执行 DAO模式DAO（Data Access Object）即：数据存取对象，故名思议就是基于对象的数据存取技术。 问： 我们之前编写的代码难道不是基于对象的数据存取么？ 答案是否定的。我们之前的可以称得上是利用JDBC对象，来进行数据存取，而非基于对象的。 反射创建对象]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO基本概念及操作]]></title>
    <url>%2F2019%2F09%2F10%2FIO1%2F</url>
    <content type="text"><![CDATA[文件IO操作1.磁盘对象：在OS中，磁盘对象主要有文件、文件夹(目录)、磁盘分区等组成；磁盘分区将一块硬盘划分成不同的大的区块；每个区块中可以有多个文件夹；每个文件夹中有可以有多个子文件夹或文件；文件夹是用来组织和管理文件的；任意一个文件夹都有一个地址.例如:C:\我的文档\Java面向对象2.磁盘操作：通常情况下，我们的磁盘操作主要分为两大类： A、对磁盘对象的操作；B、对文件内容的操作。 File类(对磁盘对象-文件和文件夹)进行操作文件路径的分隔符应使用 “/” “\” File类中的文件路径分隔符常量(File.Separator) File类操作文件夹和文件的方法和常量 方法或常量 类型 描述 public String separator 常量 文件路径分隔符 public File(String filename) 构造方法 创建File类对象并传入完整路径 public boolean mkdir() 方法 创建单级目录 public boolean mkdirs() 方法 创建目录且允许创建多级目录 public boolean isDirectory() 方法 判断给定的路径是否为目录 publicboolean delete() 方法 删除文件或目录 public boolean renameTo(File dest) 方法 重命名文件或目泶 public File[] listFiles() 方法 列出指定目录的全部文件 public String[] list() 方法 列出指定目录的子目录及文件的名称 public boolean createNewFile() 方法 创建新文件 public boolean exists() 方法 判断文件是否存在 public long length() 方法 返回文件的大小 public String getPath() 方法 返回文件的路径信息 注意:文件夹和目录有何不同？ 答：文件夹的路径就是目录。 代码案例12345678910111213141516171819202122232425262728293031import java.io.File;import java.io.IOException;public class Test &#123; public static void main(String[] args) &#123; File f = new File("D:/hello" + File.separator); String[] str = f.list(); for (String name : str) &#123; System.out.println(name); &#125; System.out.println("***********"); test(); &#125;//判断文件是否存在,存在即删除,不存在就创建一个新的文件 public static void test() &#123; File f = new File("D:/hello/1.txt"); if (f.exists()) &#123; f.delete(); &#125; else &#123; try &#123; f.createNewFile(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println("文件名称:" + f.getName()); System.out.println("文件路径:" + f.getPath()); System.out.println("文件长度:" + f.length() + "Bytes"); System.out.println(f.isDirectory() ? "是目录" : "不是目录"); &#125;&#125; 1234567891011j2eej2senodejsnodejs1tomcat_80tomcat_80.rar*************文件名称:1.txt文件路径:D:\hello\1.txt文件长度:0Bytes不是目录 RandomAccessFile类(随机访问文件:对文件内容的操作) RandomAccessFile是Java中功能最丰富的文件访问类，它提供了多种文件访问方法，包括以二进制方式“随机访问”文件、跳转到文件的任意位置读写数据等。实际应用中一般使用RandomAccessFile类访问文件指定位置的内容块。之所以可以访问文件的任意位置，是因RandomAccessFile可以操作文件指针。 默认情况下打开新文件时，位置指针指向文件开始处，当对文件内容操作时，文件指针指向哪里就从哪里开始写入，程序代码可以移动文件指针到指定位置，再进行读写操作。 RandomAccessFile类常用方法 方法 类型 描述 public RandomAccessFile(File f,String mode) 构造方法 接收File类并设置r只读、w只写?、rw为读写模式 public RanciomAccessFile(String name,String mode) 构造方法 输入指定的文件路径并设置模式 public void close () 方法 关闭随机存取文交流并释放与该流关联的所有系统资源 public final byte readByte () 方法 读取一个字节 public int read (byte [ ] b) 方法 将内容读取到byte数组中 public final int readInt() 方法 将一个整型数据写入到文件中 public final void writeBytes(String s) 方法 按字节序列将该字符串写入该文件 public final void writeInt(int v) 方法 按四个字节将int写入该文件 public void seek(long pos) 方法 设置指针距离文件开头的字节数，是绝对定位 public int skipBytes (int n) 方法 指针从当前位置开始跳过的字节数是相对定位 public long getFilePointer () 方法 获取指针的当前位置 代码案例1234567891011121314151617181920212223242526import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;public class Test &#123; public static void main(String[] args) &#123; File f = new File("D:/hello" + File.separator + "1.txt"); try &#123; RandomAccessFile raf = new RandomAccessFile(f, "rw"); raf.writeBytes("jim");//写入3个字节 raf.writeInt(23);//写入四个字节 raf.writeBytes("tom"); raf.writeInt(24); raf.writeBytes("john"); raf.writeInt(22); raf.close();//关闭连接释放资源 System.out.println("输入写出成功"); raf.readInt(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 步骤： 1.先检索到自己需要信息的位置 2.将信息转化为byte数组 3.读取数组里的内容 4.将单个转化为字符串 12345678910111213141516171819202122232425262728293031import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;public class Test &#123; public static void main(String[] args) &#123; File f = new File("D:/hello" + File.separator + "1.txt"); try &#123; RandomAccessFile raf = new RandomAccessFile(f, "r"); raf.skipBytes(14);//raf.seek(14); byte[] b=new byte[4]; raf.read(b); String n3=new String(b); int a3=raf.readInt(); System.out.println("第三个人:"+n3+","+a3+"岁"); raf.seek(0);//raf.skipBytes(-14);不能往前跳 b=new byte[3]; raf.read(b); String n1=new String(b); int a1=raf.readInt(); System.out.println("第一个人:"+n1+","+a1+"岁"); raf.close();//关闭连接释放资源 System.out.println("读取成功"); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123第三个人:john,22岁第一个人:jim,23岁读取成功 汉字转字节数组： 12String name="张三";byte[] b=name.getBytes(); 123456789 // "r", "rw", "rws",or "rwd"File f = new File("D:/hello/1.txt");RandomAccessFile raf = new RandomAccessFile(f, "rw");// 读取时: byte[] b=new byte[4];4对应字节数// 写入数据:String name = "张三";// 字节为4raf.write(name.getBytes());raf.writeBytes("jim");// 字节为3raf.writeInt(23);// 字节为4 字节输入输出流 数据流是一串连续不断的数据的集合，数据如同管道供水般一段一段从一端流向另一端，并按先后顺序形成有序队列。 在程序中，无论数据分为多次还是一次性整体写入，其读取效果完全一致。读取时可以选择任意长度的数据，但必须按照由前往后、先进先出的顺序进行。如下图所示。 使用流操作文件有如下几个基本步骤① 用File类打开文件； ② 通过字节流或字符流指定输入（来源）/输出（目标）位置； ③ 进行读/写操作； ④ 关闭流。 InputStream和OutputStream字节输入流是指数据以字节形式从其他文件或终端设备向程序流入，输入流只能从流中读取数据，可以使用InputStream类完成。 字节输出流是指数据以字节形式从程序流出，输出流只能向流中写入数据，可以使用OutputStream类完成。 InputStream和OutputStream是两个抽象类 体系结构 抽象类 InputStream的主要方法 方法 描述 public void close () 关闭输入流 public abstract int read() 以数字的方式读取内容 public int read (byte [ ] b) 将内容读到byte数组中同时返回阅读入的个数 抽象类 OutputStream的主要方法 方法 描述 public void close () 关闭输出流 public void flush() 刷新输出流并强制写出缓冲的输出字节 public abstract voidwrite(int b) 将指定的字节写入此输出流 public int write (byte [ ] b) 将 b.length 个字节从指定的字节数组写入此输出流 publicvoid write(byte[] b,int off,int len) 将指定字节数组中从偏移量 off 开始的len个字节写入此输出流 注意： 若需要使用InputStream和OutputStream两个抽象类来完成二进制数据IO操作，必须通过其子类来完成。eg:使用FilelnputStream读取文件内容，而使用FileOutputStream来写入文件内容。 FileInputStream和FileOutputStreamFilelnputStream是InputStream的子类，主要用于从文件中读取数据；FileOutputStream是OutputStream的子类，主要用于向文件中写入数据。 FileOutputStream的主要构造方法如下语法 1public FileOutputStream(File file,boolean append) 其中boolean flag参数是可选的．true表示以追加模式打开文件（相当于自动调整文件指针到最后），false表示以覆盖模式（相当于文件指针在首行的最左侧）打开文件默认情况下flag参数值为false。 FilelnputStream的主要构造方法如下语法 12public FileInputStream(File file) public FileInputStream(String name) 代码案例任务：编码打开D:/hello/1.txt文件，向文件中写入hello world，然后再从D:/hello/1.txt文件中读取数据。 要求：写入文件使用 FileOutStream,从文件中读入数据使用FileInputStream。 12345678910111213141516171819import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class Test3 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("D:/hello/1.txt"); FileOutputStream fos = new FileOutputStream(f, true); String str = "hello world"; fos.write(str.getBytes()); fos.close(); FileInputStream fis = new FileInputStream(f); byte[] buf = new byte[1024]; int len = fis.read(buf); System.out.println(new String(buf, 0, len)); fis.close(); &#125;&#125; 1输出结果: hello world 读写文件内容，已经掌握了两种方式： 1.使用RandomAccessFile：可以随意调整文件指针位置，进行读写操作。 2.使用FileOutStream来存档，使用FileInputStream来读档。 BufferedlnputStream 和 BufferedOutputStreamFilelnputStream和FileOutputStream使用byte数组保存从文件中读取的数据；但由于硬盘（机械设备）数据存取速度远低于内存（电子设备）的数据存取速度，所以可以对IO流进行缓冲，以减少对硬盘的存取次数，提高读写效率。 BufferedInputStream和BufferedOutputStream为InputStream和OutputStream增加了内存缓冲区. 根本目的是:允许Java的IO流一次操作多个字节，从而提高整个系统的性能。 BufferedlnputStream构造方法12public BufferedInputStream(InputStream in) public BufferedInputStream(InputStream in,int size) 第一种形式的构造方法创建带有32个字节缓冲区的缓冲流，第二种形式的构造方法按照指定大小创建缓冲区。 BufferedOutputStream构造方法12public BufferedOutputStream(OutputStream in) public BufferedOutputStream(OutputStream in,int size) 与BufferedlnputStream相同，上述第一种形式的构造方法创建带有32个字节缓冲区的缓冲流第二种形式的构造方法按指定的大小来创建缓冲区。 BufferedOutputStream与OutputStream的使用基本一致， 但BufferedOutputStream中的flush方法可以强制输出缓冲区的数据。 代码案例利用缓冲流，将D:/hello/1.txt中的内容，复制到D:/hello/2.txt文件中。 1234567891011121314151617181920import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; byte[] data=new byte[1]; FileInputStream in=new FileInputStream("D:/hello/1.txt"); FileOutputStream out=new FileOutputStream("D:/hello/2.txt"); BufferedInputStream bufin=new BufferedInputStream(in); BufferedOutputStream bufos=new BufferedOutputStream(out); while(bufin.read(data)!=-1) &#123; bufos.write(data); &#125; bufos.flush(); bufin.close(); bufos.close();&#125;&#125; 创建一个长度为1的字节数组（目的是小于32，因为缓冲流默认缓冲区是32字节，大于32就没有意义了) 比如512或1024，表示一次读多少个字节的数据。 read方法返回本次实际读到的字节数，如果为-1，表示本次未读到任何数据。 调用flush方法，将输出缓冲流中的内容（不管缓冲区是否满）一股脑写入2.txt中。 在网络交互的程序中，缓冲流用的还是挺多的，比如：我们在网上下载一个视频，我们将缓冲流的缓冲区指定的稍微大点，这样，当缓冲流满的时候，才去向硬盘写入一次数据，减少了对磁盘的访问频率。 对象序列化和反序列化不管是游戏还是正在执行过程中的Java程序，很多数据以对象的方式存储在内存中。 对象序列化是指直接将内存中的整个对象存储至文件或其他终端中的过程，即将对象转换为二进制数据保存到文件或其他终端。 反序列化则与之相反。 序列化及反序列化可以方便地实现对象存储和传输。 序列化类的对象时，要求该类必须实现java.io.Serializable接口 接口定义如1public interface Serializable&#123;&#125; 非常有意思的是， 此接口中没有定义任何方法，所以又称为标识接口，表示该类具备序列化的能力。 对象的类实现Serializable接口之后，可以分别使用类ObjectInputStream和ObjectOutputStream类存储、读取数据。 0bjectInputStream类主要方法 方法 类型 描述 public ObjectInputStream (InputStream in) 构造方法 构造输入对象 public final Object readObject () 方法 从指定位置读取对象 0bjectOutputStream类主要方法 方法 类型 描述 public ObjectOutputStream (OutputStream out) 构造方法 构造输出对象 public final void writeObject(Object o) 方法 输出对象到指定位置 案例 1.定义可序列化的类，该类必须实现Serializable接口。 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.Serializable;public class Student implements Serializable &#123;private String name;private int age;private Grade grade;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125;public int getAge() &#123; return age;&#125;public void setAge(int age) &#123; this.age = age;&#125;public Grade getGrade() &#123; return grade;&#125;public void setGrade(Grade grade) &#123; this.grade = grade;&#125;&#125;import java.io.Serializable;public class Grade implements Serializable&#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; pubic void setName(String name) &#123; this.name = name; &#125;&#125; 2.编写序列化及反序列化方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class Test8 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; writeObject(); readObject(); &#125; // 序列化 public static void writeObject() throws IOException &#123; File f = new File("D:/hello/2.txt"); FileOutputStream outputStream = new FileOutputStream(f); ObjectOutputStream os = new ObjectOutputStream(outputStream); // 创建序列化对象 Student tom = new Student(); tom.setAge(20); tom.setName("tom"); Grade grade = new Grade(); grade.setId(1000); grade.setName("S150"); tom.setGrade(grade); // 进行写操作 os.writeObject(tom); outputStream.close(); os.close(); &#125; // 反序列化 public static void readObject() throws IOException, ClassNotFoundException &#123; File f = new File("D:/hello/2.txt"); FileInputStream inputStream = new FileInputStream(f); ObjectInputStream in = new ObjectInputStream(inputStream); Object object = in.readObject(); // 强制类型转换 Student tom = (Student) object; System.out.println("姓名:" + tom.getName()); System.out.println("年龄:" + tom.getAge()); System.out.println("班级:" + tom.getGrade().getName()); &#125;&#125; 123姓名:tom年龄:20班级:S150 字符输入输出流Reader和Writer由于Java中的字符采用Unicode编码，所以InputStream类和OutputStream类用于处理字节，但不适合处理字符文本。 Java为字符文本的输入和输出专门提供了Reader和Writer类，二者均为抽象类且与InputStream类和OutputStream相对应。 其继承层次图如下图所示： Reader类主要方法 方法 描述 public abstract void close() 关闭输入流 public int read() 读取单个字符 public intread(char [] c) 将内容读取到字符数组中，并返回读取的长度 Writer类主要方法 方法 描述 public abstract void close() 关闭输出流 public void write (String str) 输出字符串到流中 public void write (char [ ] c) 输出字符数组到流中 public abstract void flush () 强制清空缓存 与OutputStream和InputStream类似，Reader和Writer也是抽象类，所以需要根据文件类型的子类来选择具体的子类来实现读取操作。 eg: 以字符形式操作文件时，可以选择FileReader和FileWriter。 当我们看到Reader和Writer时，千万别有一种自己被加重了负担的感觉，而是要当成一个帮手，看到他们请嘴角上扬。 FileReader和FileWriter案例FileReader和FileWriter是Reader和Writer的实现子类，可用于读写文本文件，现在请编码使用FileWriter向D:/hello/2.txt中写入hello world，并使用FileReader来读取并显示hello world！ 核心代码： 1234567891011public static void testWriter() throws IOException &#123; File f = new File("D:/hello/2.txt"); FileWriter out = new FileWriter(f); out.write("hello world!"); out.close(); FileReader reader = new FileReader(f); char[] c= new char[1024]; int len = reader.read(c); System.out.println(new String(c, 0, len)); reader.close();&#125; InputStreamReader和OutputStreamWriterInputStreamReader和OutputStreamWriter分别为Reader和Writer类的子类，二者用于字节流和字符流之间的转换。 其中InputStreamReader用于将输入的字节流转变为字符流 而OutputStreamWriter用于将输出的字符流转变为字节流。 创建使用默认字符编码的 1OutputStreamWriter OutputStreamWriter (OutputStream out) 创建使用指定字符集的 1OutputStreamWriter OutputStreamWriter (OutputStream out,String charsetName) 案例使用OutputStreamWriter向D:/hello/2.txt中，写入一段文本。 12345678910public static void main(String[] args) throws IOException &#123; testOutputStreamWriter();&#125;public static void testOutputStreamWriter() throws IOException &#123; File f = new File("D:/hello/2.txt"); FileOutputStream s = new FileOutputStream(f); OutputStreamWriter w = new OutputStreamWriter(s); w.write("今日的痛苦是明日最甜美的回忆"); w.close();&#125; 创建一个使用默认字符集的 1InputStreamReader InputStreamReader(InputStream in) 创建使用指定字符集的 1InputStreamReader InputStreamReader(InputStream in, String charsetName) 任务： 使用OutputStreamWriter从D:/hello/2.txt中读取内容。 123456789101112public static void main(String[] args) throws IOException &#123; testInputStreamWriter();&#125;public static void testInputStreamWriter() throws IOException &#123; FileInputStream s = new FileInputStream("D:/hello/2.txt"); InputStreamReader r = new InputStreamReader(s); char[] c = new char[1024];// 一次最多多1024个 int len = r.read(c);// 实际读到的字数 System.out.println(new String(c, 0, len)); r.close();&#125; 1输出结果: 今日的痛苦是明日最甜美的回忆 注意： 频繁的转换字符与字节将影响程序的效率，所以实际应用中应尽量避免直接使用InputStreamReader和OutputStreamWriter类进行转换。 必须进行频繁的转换时，建议使用BufferedWriter和BufferedReader类包装InputStreamReader和OutputStreamWriter。 BufferedWriter和BufferedReaderBufferedWriter和BufferedReader是带缓冲区的Reader和Writer。使用BufferedReader读取文件时，将首先从文件中读取字符数据并存入缓冲区中，然后调用read()方法，先从缓冲区开始读取，缓冲区数据不足时再从文件中读取；使用BufferedWriter时，写入的数据将先存储到缓冲区中，在缓冲区饱和的情况下将一次性写入目的地。通过缓冲区可以减少对硬盘的输入或输出操作，提高文件存取效率。 BufferedReader类的主要方法： 方法 类型 描述 public BufferedReader(Reader in) 构造方法 接收Reader类实例 public String readLine() 方法 从缓冲区读取一行文本 public int read() 方法 读取单个字符 public int read(char[] cbuf,int off,int len) 方法 将字符读入数组的某一部分 BufferedWriter类主要方法： 方法 类型 描述 public BufferedWriter(Writer out) 构造方法 接收Writer类实例 public void newLine() 方法 写入一个行分隔符 public void write(int c) 方法 写入单个字符 public void write(char[] c,int off,int len) 方法 写入字符数组的某一部分 public void write(String s,int off,int len) 方法 写入字符串的某一部分 案例通过BufferedWriter向D:/hello/2.txt文件中写入一段文本，再使用BufferedReader从D:/hello/2.txt文件中读入数据并显示出来。 1234567891011121314151617public static void main(String[] args) throws IOException &#123; testBuffterWriter();&#125;public static void testBuffterWriter() throws IOException &#123; File f = new File("D:/hello/2.txt"); FileWriter writer=new FileWriter(f); BufferedWriter bufferedWriter =new BufferedWriter(writer); bufferedWriter.write("肖战"); bufferedWriter.close(); writer.close(); FileReader reader=new FileReader(f); BufferedReader bufferedReader=new BufferedReader(reader); String content=bufferedReader.readLine(); System.out.println(content); bufferedReader.close(); reader.close();&#125; 上边代码纯粹是为了给大家演示使用过程而设置，在实际项目中一般不会有这样的业务。 有两点需要关注： a.BufferedWriter对象和BufferedReader对象的构建过程。 b.文件关闭(Close)的顺序：先关闭外层缓冲对象，再关闭内层对象。 PrintWriterPrintWriter是Writer的子类，其作用是将格式化的数据或对象输出到一个文本输出流. PrintWriter类构造方法 方法 描述 PrintWriter(File file) 使用指定文件创建不具有自动行刷新的新 PrintWriter PrintWriter(File file, String csn)) 创建具有指定文件和字符集且不带自动刷行新的新 PrintWriter PrintWriter(OutputStream out) 根据现有的 OutputStream 创建不带自动刷新的新 PrintWriter PrintWriter(OutputStream out,boolean autoFlush) 通过现有的 OutputStream 创建新的 PrintWriter PrintWriter(String fileName) 创建具有指定文件名称且不带自动行刷新的新 PrintWriter PrintWriter(String fileName, String csn) 创建具有指定文件名称和字符集且不带自动行刷新的新 PrintWriter PrintWriter(Writer out) 创建不带自动行刷新的新 PrintWriter PrintWriter(Writer w, boolean autoFlush) 创建新 PrintWriter PrintWriter类中的主要方法是print()和write()，二者均提供类型丰富的参数，可以实现多种形式多种终端的格式化输出操作。 案例使用PrintWriter类向D:/hello/2.txt文件中，写入字符串数据。 1234567public static void testPrintWriter() throws IOException &#123; File f = new File("D:/hello/2.txt"); PrintWriter pw=new PrintWriter(f); pw.println("hello world"); pw.write("java"); pw.close(); &#125; 程序运行后，打开D:/hello/2.txt文件，如图所示。 怎么没有数据呢？这是因为PrintWriter内置缓冲区，缓冲区还有空间时，是不会进行写入的文件的，你有以下几种方式来让缓冲区中内容进入文件： a.在调用print()或write()方法后，调用flush()方法强制刷新缓冲区，将文字写入文件。 b.在创建PrintWriter对象时开启自动刷新选项（例如：第216行被注释的代码） c.调用close方法，也会将缓冲区内容写入文件之中。 程序运行后，打开D盘下面的test.txt文件，如图所示： 字节流与字符流区别 字节流 字符流 以字节为单位输入和输出数据 以字符为单位输入和输出数据 操作时不会用到缓冲区（内存） 操作时使用了缓冲区（内存） 字节流按照8位传输 字符流按照16位传输1个字符=2个字节]]></content>
      <categories>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven介绍]]></title>
    <url>%2F2019%2F09%2F10%2Fmaven1%2F</url>
    <content type="text"><![CDATA[Maven相关概念Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中[插件]目标(goal)的逻辑。当你使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。 Maven 有一个生命周期，当你运行 mvn install 的时候被调用。这条命令告诉 Maven 执行一系列的有序的步骤，直到到达你指定的生命周期。遍历生命周期旅途中的一个影响就是，Maven 运行了许多默认的[插件]目标，这些目标完成了像编译和创建一个 JAR 文件这样的工作。 Dependency(依赖)各种项目需要依赖的jar包,在没使用Maven时需要把各种框架的jar包都导入进项目的lib目录下,但有了maven之后就可以通过在pom.xml配置文件中通过依赖管理(&lt;dependencies&gt;)配置相关的依赖项(&lt;dependency&gt;)即可. maven不但可以提供直接的依赖管理,比如直接依赖Junit、Spring MVC,还可以提供所有传递依赖管理,这是一个透明的过程,也就是这里写了依赖Spring的Web MVC框架,那么Spring MVC所依赖的其他包,Maven也会为我们自动载入. 坐标—— ——唯一标识一个产品 Maven安装并测试步骤 1、下载并解压meaven.zip(百度谷歌搜索Maven)； 2、系统变量下新建系统变量， M2_HOME ，值是meaven安装目录； 3、path：%M2_HOME%\bin； 4、测试cmd：mvn -version;** 修改配置文件1.maven安装目录中，conf--&gt;seeting复制到.m2文件夹下， 2.修改setting中的localRepository ，即修改本地仓库位置。 3.mirror 修改中央仓库的替代仓库地网址（Maven 的核心仓库的副本就是一个mirror。配置之后，每次访问都去这个仓库访问）如： 123456789101112&lt;mirror&gt; &lt;id&gt;UK&lt;/id&gt; &lt;name&gt;UK Central&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 好处: 每次升级Maven版本不需要修改Maven自己的配置文件 自由的选择Maven仓库的位置 为了避免Maven下载中心负载过重，可以选择其他的下载中心，比如：英国的/阿里云 用Maven创建项目1.在继承Maven的eclipse(4.3版本 kepler)中 windows---&gt;prefrences----&gt;Maven---&gt;Installation---&gt; 将新下载的maven文件add进去，确保在user Setings中 配置文件的路径是之前配置了mirror的配置文件setting.xml 2.运行命令创建项目(注意：需要指定创建项目的路径) 例如: 1234cd C:\Users\Workspaces\Eclipse 10 命令：mvn archetype:generate -DgroupId=imooc-arthur -DartifactId=spring-mvc-study-DarchetypeArtifactId=maven-archetype-webapp 参数解释： 1234archetype:generate 调用插件 groupId 坐标artifactId 坐标的一个元素，目录结构的根目录名称archetypeArtifactId 目录类型的一个类型，此为webapp的类型 eclipse创建Maven项目eclipse –&gt; File –&gt; New –&gt; Maven Project(勾选Create a simple project) –&gt; Next –&gt; 填写相关信息 –&gt; Finish POM.xml添加对应的需要的约束]]></content>
      <categories>
        <category>开发工具及技术</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中equals和==]]></title>
    <url>%2F2019%2F09%2F10%2Fxzs3%2F</url>
    <content type="text"><![CDATA[解释一(数据类型方面)java中的数据类型，可分为两类： 1.基本数据类型，也称原始数据类型byte,short,char,int,long,float,double,boolean 他们之间的比较，应用双等号（==）,比较的是他们的值。 2.复合数据类型(类) 当他们用()进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。 对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（）进行比较的，所以比较后的结果跟双等号(==)的结果相同。 1234567891011public class TestString &#123;public static void main(String[] args) &#123; String s1 = &quot;Monday&quot;; String s2 = &quot;Monday&quot;; if (s1 == s2) &#123; System.out.println(&quot;s1 == s2&quot;);&#125; else&#123; System.out.println(&quot;s1 != s2&quot;);&#125;&#125;&#125; 编译并运行程序，输出： 1s1 == s2 说明：s1 与 s2 引用同一个 String 对象 “Monday”! 再稍微改动一下程序，会有更奇怪的发现： 12345678910111213public class TestString &#123;public static void main(String[] args) &#123;String s1 = "Monday";String s2 = new String("Monday");if (s1 == s2)&#123;System.out.println("s1 == s2");&#125;else&#123;System.out.println("s1 != s2");&#125;if (s1.equals(s2)) &#123;System.out.println("s1 equals s2");&#125;else&#123;System.out.println("s1 not equals s2");&#125;&#125;&#125; 我们将s2用new操作符创建 程序输出： 12s1 != s2s1 equals s2 说明:s1,s2分别引用了两个”Monday”String对象 字符串缓冲池 原来，程序在运行的时候会创建一个字符串缓冲池当使用 s2 = “Monday” 这样的表达是创建字符串的时候，程序首先会在这个String缓冲池中寻找相同值的对象，在第一个程序中，s1先被放到了池中，所以在s2被创建的时候，程序找到了具有相同值的 s1将s2引用s1所引用的对象”Monday”. 第二段程序中，使用了 new 操作符，他明白的告诉程序：”我要一个新的！不要旧的！”于是一个新的”Monday”Sting对象被创建在内存中。他们的值相同，但是位置不同，一个在池中游泳一个在岸边休息。哎呀，真是资源浪费，明明是一样的非要分开做什么呢？ 再次更改程序： 1234567891011121314public class TestString &#123;public static void main(String[] args) &#123;String s1 = "Monday";String s2 = new String("Monday");s2 = s2.intern();if (s1 == s2)&#123;System.out.println("s1 == s2");&#125;else&#123;System.out.println("s1 != s2");&#125;if (s1.equals(s2)) &#123;System.out.println("s1 equals s2");&#125;else&#123;System.out.println("s1 not equals s2");&#125;&#125;&#125; 这次加入： 1s2 = s2.intern(); 程序输出：** 12s1 == s2s1 equals s2 原 来,java.lang.String的intern()方法&quot;abc&quot;.intern()方法的返回值还是字符串“abc”，表面上看起来好像这个方 法没什么用处。但实际上，它做了个小动作：检查字符串池里是否存在“abc”这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把“abc”到字符串池中，然后再返回它的引用。 解释二(内存地址方面) equals 方法是 java.lang.Object 类的方法。 有两种用法说明： 对于字符串变量来说，使用“==”和“equals()”方法比较字符串时，其比较方法不同。 “==”比较两个变量本身的值，即两个对象在内存中的首地址。 “equals()”比较字符串中所包含的内容是否相同。 比如： 123String s1,s2,s3 = "abc", s4 ="abc" ;s1 = new String("abc");s2 = new String("abc"); 那么： 1s1==s2 是 false 两个变量的内存地址不一样，也就是说它们指向的对象不 一样，故不相等。 1s1.equals(s2) //是true 两个变量的所包含的内容是abc，故相等。 注意(1)： 12StringBuffer s1 = new StringBuffer("a");StringBuffer s2 = new StringBuffer("a"); 结果： 1s1.equals(s2) //是false 解释：StringBuffer类中没有重新定义equals这个方法，因此这个方法就来自Object类，而Object类中的equals方法是用来比较“地址”的，所以等于false. 注意(2)： 对于s3和s4来说，有一点不一样要引起注意，由于s3和s4是两个字符串常量所生成的变量，其中所存放的内存地址是相等的，所以s3==s4是true（即使没有s3=s4这样一个赋值语句） 对于非字符串变量来说，”==”和”equals”方法的作用是相同的都是用来比较其对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个对象。 比如： 12345class A&#123; A obj1 = new A(); A obj2 = new A();&#125; 那么： 12obj1==obj2 //false obj1.equals(obj2) //false 但是如加上这样一句： 1obj1=obj2; 那么: 12obj1==obj2 //true obj1.equals(obj2) //true 总之： equals方法对于字符串来说是比较内容的，而对于非字符串来说是比较其指向的对象是否相同的。 == 比较符也是比较指向的对象是否相同的也就是对象在对内存中的的首地址。 String类中重新定义了equals这个方法，而且比较的是值，而不是地址。所以是true。 解释三(案例演示)关于equals与==的区别从以下几个方面来说： 如果是基本类型比较，那么只能用==来比较，不能用equals 比如： 123456789101112public class TestEquals &#123;public static void main(String[] args) &#123;int a = 3;int b = 4;int c = 3;System.out.println(a == b);//结果是falseSystem.out.println(a == c);//结果是trueSystem.out.println(a.equals(c));//错误，编译不能通过，equals方法//不能运用与基本类型的比较&#125;&#125; 对于基本类型的包装类型，比如Boolean、Character、Byte、Shot、Integer、Long、Float、Double等的引用变量，==是比较地址的，而equals是比较内容的。 比如： 1234567891011public class TestEquals &#123;public static void main(String[] args) &#123; Integer n1 = new Integer(30);Integer n2 = new Integer(30);Integer n3 = new Integer(31);System.out.println(n1 == n2);//结果是false 两个不同的Integer对象，故其地址不同，System.out.println(n1 == n3);//那么不管是new Integer(30)还是new Integer(31) 结果都显示falseSystem.out.println(n1.equals(n2));//结果是true 根据jdk文档中的说明，n1与n2指向的对象中的内容是相等的，都是30，故equals比较后结果是trueSystem.out.println(n1.equals(n3));//结果是false 因对象内容不一样，一个是30一个是31&#125;&#125; 这是Integer的实例，如果是其他的比如Double、Character、Float等也一样。 注意：对于String(字符串)、StringBuffer(线程安全的可变字符序列)、StringBuilder(可变字符序列)这三个类作进一步的说明。 首先，介绍String的用法，请看下面的实例： 1234567891011121314151617181920public class TestEquals &#123;public static void main(String[] args) &#123;String s1 = "123";String s2 = "123";String s3 = "abc";String s4 = new String("123");String s5 = new String("123");String s6 = new String("abc");System.out.println(s1 == s2);//（1）trueSystem.out.println(s1.equals(s2));//（2）trueSystem.out.println(s1 == s3);//（3）flaseSystem.out.println(s1.equals(s3));//（4）flaseSystem.out.println(s4 == s5);//（5）flaseSystem.out.println(s4.equals(s5));//（6）trueSystem.out.println(s4 == s6);//（7）flaseSystem.out.println(s4.equals(s6));//（8）flaseSystem.out.println(s1 == s4);//（9）falseSystem.out.println(s1.equals(s4));//（10）true&#125;&#125; 答案解释： s1与s2分别指向由字符串常量”123” 创建的对象，在常量池中，只有一个对象，内容123，有两个引用s1和s2指向这个对象，故这两个引用变量所指向的地址是相同的，因而（1）处的运行结果为true. 又因为s1.equals(s2)是比较s1和s2所指向的对象的内容是否相等，而我们知道这两个对象的内容都是字符串常量”123”，故标记（2）处的运行结果是true. 用同样的方法分析，s1和s3所指向的对象不一样，内容也不一样，故标记（3）和（4）处运行结果是false。 再看看s4和s5，这两个引用变量所指向的对象的内容都是一样的（内容都是123），但是这两个对象是用new操作符创建处类的，是在内存中分配两块空间给这两个对象的，因而这两个对象的内存地址不一样，故是两个不同的对象，标记（5）处的s4 == s5 运行结果为false，但是内容一样，故标记（6）处的s4.equals(s5)运行结果为true。 同理,s4和s6所指向的对象地址不同，内容也不相同。故标记（7)(8）处运行结果为false。 s1和s4分别指向两个不同的对象（之所以这样称呼，是因为这两个对象在内存中的地址不相同，故而对象不相同），故标记为（9）处的s1 == s4运行结果为false，而标记为（10）处的s1.equals(s4)运行结果疑问：乍一看结果，有点惊讶，为什么不是true呢，不是说equals方法是比较内容的吗？ 解释：不错，如果在新类中被覆盖了equals方法，就可以用来比较内容的。但是在上面的例子中类Value并没有覆盖Object中的equals方法，而是继承了该方法，因此它就是被用来比较地址的，又v1和v2的所指向的对象不相同，故标记（1）处的v1.equals(v2)运行结果为false，标记为（2）处的v1 == v2运行结果也为false。]]></content>
      <categories>
        <category>小知识</category>
        <category>Java基础相关</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于tomcat8在windows2008下高并发下问题的解决方案]]></title>
    <url>%2F2019%2F09%2F10%2Ftomcat2%2F</url>
    <content type="text"><![CDATA[原文链接关于tomcat8在windows2008下高并发下问题的解决方案因为客户服务器特殊的环境问题，只能使用windows2008r2服务器，然而配置过后，网站的高访问量很快就出现了各种问题，以下是解决的问题汇总。服务器环境：windows2008R2+jdk8.0+tomcat8.0.21+sqlserver2008r2(以上软件环境均是64位) 1、首先建议安装jdk8.0(64位)以能获取较高的JVM内存设置，不然网站访问并发过高，内存很快就会出现不足，也就是常说的java heap space不足了。下载地址 记得一定要选择：jdk-8u45-windows-x64.exe 2、安装64位的tomcat8.0, 3、修改连接器协议，默认是HTTP/1.1，该默认设置不能支持过高的并发量，不然会出现io错误。 方法是修改conf/server.xml将 1&lt;Connector port="8080" protocol="HTTP/1.1"/&gt; 修改为 1&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol"/&gt; 4、优化jar包，如果一个jar文件出现在多个WEB应用中的话，可以将该jar文件统一放到一个目录下，以 避免被tomcat 多次加载，耗用内存占用。方法是： 修改：/conf/catalina.properties文件 将： 123common.loader="$&#123;catalina.base&#125;/lib","$&#123;catalina.base&#125;/lib/*.jar","$&#123;catalina.home&#125;/lib","$&#123;catalina.home&#125;/lib/*.jar后面增加："$&#123;catalina.home&#125;/share/lib/*.jar" 然后将共用的jar文件放到tomcat下share目录里的lib文件夹里即可。 5、tomcat8默认会缓存图片资源，当并发过高时，会提示warn信息： 12WARNING [http-nio-80-exec-43] org.apache.catalina.webresources.Cache.getResource Unable to add the resource at..... 这个本身没有什么问题，只是不断在日志中写入信息，日志文件不断增加，感觉不好，干脆设置不缓存，方法是：修改META-INF下的context.xml文件，在Context中增加一行： 1&lt;Resources cachingAllowed="false"&gt;&lt;/Resources&gt; 6、设置jvm较大内存，编辑bin/catalina.bat，找到以下代码段： 1rem Guess CATALINA_HOME if not defined 在其上面增加代码： 1set JAVA_OPTS=-Xms512m -Xmx4096m -XX:PermSize=128M -XX:MaxPermSize=256m 这里设置的Xmx为4G内存，如果安装的不是64位的JDK，那么在设置最大内存的时候，就会提示不支持(好像最多能设置到1G多点，要知道服务器内存是64G)。所以第一步为什么要安装64位的操作系统了。 7、设置tomcat最大并发数，方法：修改conf/server.xml，在Connector下增加以下代码： 1&lt;Connector maxThreads="1000" minSpareThreads="100" maxSpareThreads="300" acceptCount="100" /&gt; 以下是我的配置： 12345&lt;Connector port="80" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" maxThreads="1000" minSpareThreads="100" maxSpareThreads="300" acceptCount="100" redirectPort="8443" URIEncoding="GBK" useBodyEncodingForURI="true" /&gt;]]></content>
      <categories>
        <category>并发</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[org.springframework.web.context.ContextLoaderListener]]></title>
    <url>%2F2019%2F09%2F10%2Ftomcat1%2F</url>
    <content type="text"><![CDATA[原文链接 一启动Tomcat就报错: 123456789101112131415java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1892) at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1735) at org.apache.catalina.core.DefaultInstanceManager.loadClass(DefaultInstanceManager.java:504) at org.apache.catalina.core.DefaultInstanceManager.loadClassMaybePrivileged(DefaultInstanceManager.java:486) at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:113) at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:5034) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5634) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1571) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1561) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:748) 解决方法 Maven项目构建的,报错的原因就是:启动的时候,没有把项目的JAR包一起发布. 解决方法就是,右键项目—-&gt;Deployment Assembly—-&gt;Add添加JAR到项目中去 然后点击Apply就行了。]]></content>
      <categories>
        <category>Exception</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Packet for query is too large]]></title>
    <url>%2F2019%2F09%2F10%2Fmysql10%2F</url>
    <content type="text"><![CDATA[原文链接 报错信息： 123Caused by: com.mysql.jdbc.PacketTooBigException: Packet for query is too large (1354 &gt; 1024).You can change this value on the server by setting the max_allowed_packet' variable MySQL根据配置文件会限制Server接受的数据包大小。有时候插入、更新或查询时数据包的大小，会受 max_allowed_packet 参数限制，导致操作失败。(查询数据库返回的数据包太大，超过了默认值) 初步探索: 查看 max_allowed_packet 参数： 在客户端执行： 1show VARIABLES like &apos;%max_allowed_packet%&apos;; 得到结果如下： 12345+--------------------+-------------------+ | Variable_name | Value | +--------------------+-------------------+ | max_allowed_packet | 1024 | +--------------------+-------------------+ 修改方法： (1)修改配置文件 可以编辑my.cnf来修改(在windows下my.ini中),在[mysqld]段或者mysql的server配置段进行修改。 max_allowed_packet = 20M 如果找不到my.cnf可以通过 mysql --help | grep my.cnf 去寻找my.cnf文件。linux下该文件在/etc/下 (2)在mysql命令行中修改 12set global max_allowed_packet = 2*1024*1024*10 //这里的数值为字节数，这里改为20M，需要重新登陆客户端起作用 注：在客户端用命令修改后，只能暂时起作用，重新启动MYSQL后，会恢复原来的值]]></content>
      <categories>
        <category>Exception</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cannot find template location(s) [classpathtemplates]]]></title>
    <url>%2F2019%2F09%2F10%2Fspringboot5%2F</url>
    <content type="text"><![CDATA[原文链接SpringBoot 项目启动后，可能在控制台看到这样一个警告：1234WARN 8904 --- [ restartedMain] o.s.b.a.f.FreeMarkerAutoConfiguration Cannot find template location(s): [classpath:/templates/](please add some templates, check your FreeMarker configuration,or set spring.freemarker.checkTemplateLocation=false) 其实你可以忽略不必管它。但你如果不想看到它。 解决方法(二选一): （1）在项目的 /src/main/resources/templates 目录下添加一个模板文件，比如 .jsp 或 .ftl 文件。 （2）打开项目配置文件 application.properties，有的人可能喜欢使用 .yml 格式的。 添加配置： 1spring.freemarker.checkTemplateLocation=false]]></content>
      <categories>
        <category>Exception</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理相关内容及日志]]></title>
    <url>%2F2019%2F09%2F09%2Fexception2%2F</url>
    <content type="text"><![CDATA[异常处理(概念)出现异常(程序在运行过程中所发生的不正常事件，它会中断正在运行的程序，java中控制台里显示了问题的描述信息和发生问题的位置)时采取的一系列的措施，使系统能够继续正常运行.注：java中所有的异常类型都以Exception单词结尾。三大错误语法错误例如少写分号、使用中文双引号等，此类错误最易被解决，随着学习的深入，这些都将不再是问题。 逻辑错误例如用错了运算符，结果是有的但是可能给我们预期的不一样，通过调试通常能解决这个问题。 运行时错误（也可以叫异常)正常情况，或者正常输入都不会有问题，只有在某些特殊情况（比如：网络断了、硬盘电源线接触不良了等）或者特殊输入时（比如：输入了边界值），程序出现问题甚至崩溃。这种问题，最难被发现，有些问题甚至经过严格的测试，也不容易出现，java中必须提供相应的包含机制来搞定这类错误。 表示异常情况eg: 假如你开车不小心闯红灯，这时候一个交警向你敬个礼说：你好，你触犯《道路交通安全法》第26条：“红灯表示禁止通行”，依据《道路交通安全法》第90条：“处警告或者二十元以上二百元以下罚款”；对你罚款200元。如下图所示。这就是一个异常，怎么表示这个异常呢？ 这个异常有罚款金额200元，罚款原因：闯红灯，责任人：司机，处理人：交警张华。 Java语言是按照面向对象的思想来处理异常，使得程序具有更好的可维护性。 Java异常处理机制具有以下优点​ 1.把各种不同类型的异常情况进行分类，用Java类来表示异常情况，这种类被称为异常类。把异常情况表示成异常类，可以充分发挥类的可扩展和可重用的优势。 ​ 2.异常流程的代码和正常流程的代码分离，提高了程序的可读性，简化了程序的结构。 ​ 3.可以灵活地处理异常,如果当前方法有能力处理异常，就捕获并处理它,否则只需抛出异常,由方法调用者来处理它。 Java已经把程序在运行中出现的大部分异常都设计好了，我们只需要直接拿着使用就行了。 Java的异常体系结构 Exception是异常类的祖先，处于继承关系的最顶层. 如何控制处理异常的流程正确运用Java提供的一套完整的异常处理机制，有助于提供程序的健壮性。 所谓程序的健壮性，就是指程序在正常情况下返回正确结果；如果遇到异常情况，程序也能采取周到的解决措施。相反，不健壮的程序则不能事先预计到可能会出现的异常，或没有提供强大的异常处理措施，导致程序终止或返回错误结果，很难检测到异常原因。 Java的异常处理机制主要是通过五个关键字来实现的： 1.try：我们通常把可能出现问题的代码放到try块中。 2.catch：如果try块中的代码在执行过程中，真的出现了异常，则catch用来捕获这个异常，从而让系统恢复正常不至于崩溃；如果try块中没有出现异常，则catch块中的代码，不会被执行。你可以认为catch是一个消防部门。 注:catch后的小括号中是需要捕捉的异常类型参数. 输入被除数为10.0 ： 出现了两个异常：InputMismatchException和ArithmeticException。但程序并没有因为异常的出现而中断。 输入除数为0： 实际应用中try-catch语句块分三种情况： 1、try语句块未出现异常 如果try语句块中的代码在运行时没有发生异常，那么catch语句块中的所有语句将被忽略，不会执行 2、 try语句块出现异常 如果try语句块的代码在运行时出现异常，那么在try语句块中，出现异常的那行代码之后的代码将不会执行，而catch块中的语句都会执行. 3.try语句块出现异常，catch不匹配 ？？ 如果try语句块的代码在运行时出现了异常，但是这个异常与catch中捕捉的异常类型不匹配，这时程序就中断（崩溃）。 最后一句“System.out.println(“程序执行完毕！”);”并没有执行；程序直接中断执行。 注：当异常真正发生时，之后的代码不会再被执行。 多重catch块： 注意： 1.当try语句块出现异常时，Java系统会自上而下分别对每个catch块进行异常类型匹配，并执行第一个与异常类型匹配的catch块，这个catch块一旦执行，其后的所有catch块都会被忽略。 2.多重catch块正常的编写顺序是先子类后父类，最后一个一般都是顶层的Exception类。 eg: 3.finally:try块或catch块的代码执行后，如果存在finally块，则执行此块中代码。 释放资源的代码一般写在finally中。 finally{ 在所有其他的错误过程发生之后被无条件执行的语句 可以在异常发生或未发生的之后无条件释放资源。 包含异常处理程序和清理代码。 } 关闭水龙头将不被执行，这样的流程显然是不安全的，必须要保证关闭水龙头在任何情况下都要被执行。 Finally代码块能保证特定的操作总会被执行。放在该语句块中的代码不管try语句是否出现异常都会被执行，特别是当try-catch语句块中有return语句时，finally块还是会被执行。return语句会在finally语句块之后执行。 4.throw：程序员可以利用此关键字来自己抛出一个异常。在某些时候是非常有必要的。 5.throws：用在方法前声明此方法可能会产生某种类型异常，它强制要求方法的调用者必须用try-catch来处理。 throws关键字后面可以同时声明多个异常，中间用逗号隔开。 Exception类自带的方法可以帮我们了解异常的相关信息： eg： 异常处理语句的语法规则 try代码块不能脱离catch代码块或finally代码块而单独存在。try代码块后面至少有一个catch代码块或finally代码块；否则编译出错. try代码块后面可以零个或多个catch代码块，还可以有零个或至多一个finally代码块。如果catch代码块和finally代码块并存，finally代码块必须在catch代码块后面。 try代码块后面可以只跟finally代码块。 在try代码块中定义的变量的作用域为try代码块，在catch代码块和finally代码块不能访问该变量。 5.当try代码块后面有多个catch代码块时，Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，而不会再执行其他的catch代码块。 在以下代码块中文件读写的语句会抛出FileNotFoundException异常，FileNotFoundException类是IOException类的子类，而IOException类是Exception的子类。Java系统把FileNotFoundException对象于IOException类匹配，因此当出现FileNotFoundException时，程序的打印结果为“文件读写错误”。 6.如果一个方法可能出现检查异常，要么用try…catch语句捕获，要么用throws字句声明将其抛出，否则会导致编译错误。 使用try…catch语句处理异常？？？？ 使用throws语句声明抛出异常 7.throw语句后面不允许紧跟其他的语句，因为这些语句永远不会被执行. throw 与 throws throw:用于语句中抛出异常，后跟一个异常对象，只能抛出一个。 throws:用于抛出异常，将异常抛出方法体外，后跟异常类型，可抛多个。 方法退出有几种方式1.正常执行完退出。 2.遇到return退出。 3.遇到Exception(异常)退出。 日志 把软件系统在运行期间产生的异常信息记录到一个文件 log4j日志工具简介log4j是Apache的一个开源项目，也是一个非常优秀的日志记录工具。通过使用log4j，我们可以很方便的控制日志的输出级别、格式以及目的地。 log4j官方站点是http://logging.apache.org/log4j/要使用log4j，首先需要到官方网站上下载log4j的Jar文件。 Jar即Java Archive，称之为Java 归档文件。它是一种与平台无关的文件格式，可以把许多文件组合成一个压缩文件，可以简单的认为Jar就是Java中的rar文件。我们使用普通的压缩包软件就可以把Jar文件进行解压。下图就是log4j的Jar被解压后的文件。 我们可以看到Jar里面大部分都是编译好的class文件，将来使用log4j时就需要用到其中的Logger.class。 使用log4jeg: 将提供给大家的log4j-1.2.17.jar文件，导入到项目中，使用Logger对象，记录异常信息到文件中的同时，把异常信息一并显示到控制台界面中。 实现步骤： ​ a. 把log4j的Jar文件导入到项目中。在Eclipse中的项目上单击右键，然后在右键菜单中单击最后一项【Properties】打开如下图所示的对话框。 ​ 在对话框中先选择左边的【Java Build Path】节点，然后单击右边的【Libraries】选项卡，最后单击【Add External JARs…】选择本机上log4j的Jar文件就行了。 ​ b.创建和编写log4j.properties文件。 注意，请把此配置文件放到src目录下，该文件是log4j的配置文件，用来配置日志的相关信息，例如日志的输出格式、级别和目的地等。下面实例给出了该配置文件的一个参考代码，各配置项的具体含义会在后面做详细讲解。 123456789101112131415161718192021//将日志信息输出到控制台log4j.appender.stdout=org.apache.log4j**.ConsoleAppender**log4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayout//将日志信息输出到test.loglog4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=**test.log**log4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %m%n//设置日志的输出级别和目的地log4j.rootLogger=**debug**, stdout,file ​ c.在程序中使用log4j编码实现记录日志，注意：第8行的log为当前类的类名，如果你的类名为Test，则需要修改为Test。 在上述代码中，我们首先创建了一个Logger对象，这个对象是用来替代System.out 的日志记录器。它提供了很多方法来输出不同级别的日志信息，见下表。 方法列表 级别 public void fatal(Objectmsg) 致命的 public void error(Objectmsg) 错误的 public void warn(Objectmsg) 警告的 public void info(Objectmsg) 信息提示的 public void debug(Object msg) 调试的 运行时我们先输入一个10.0产生一个异常，然后再次运行程序输入10和0会再产生一个异常，最后打开test.log文件就能看到日志信息，如下图所示。 log4j配置文件​ 通过上面的例子我们发现在项目中使用log4j非常简单，其中一个很关键的地方就是那个log4j.properties配置文件。下面我们就对这个配置文件进行详细讲解。 配置日志的输出级别和有效目的地12//设置日志的输出级别和有效目的地log4j.rootLogger=debug,stdout,file log4j.rootLogger属性的值有三个，用逗号进行了分隔。第一个值表示输出日志的级别，后面两个值表示哪些目的地有效。log4j的主要输出级别有：fatal、error、warn、info、debug， 它们的优先级从高到低依次为：fatal &gt; error &gt; warn &gt; info &gt;debug。 这些级别与上表中的方法有对应关系，日志记录器（Logger对象）将只输出那些级别高于或等于它的级别的信息。 eg: 如果级别设置为info，那么在程序中调用fatal(Object msg)、error(Object msg) 、warn(Object msg)、info(Object msg)方法将输出日志信息，而调用debug(Object msg)方法将不会输出日志信息。 配置日志输出目的地log4j允许将日志输出到多个目的地，一个输出目的地被称作一个appender。log4j中最常用的appender有以下两种： a.ConsoleAppender： 输出日志信息到控制台，可以通过属性log4j.appender.stdout进 行配置，与之相关的log4j.appender.stdout.Target属性的默认值是System.out。 b.FileAppender： 输出日志信息到一个文件，可以通过属性log4j.appender.file进行配 置，与之相关的log4j.appender.file.File属性可以配置该文件的路径及名称，该文件不需要我们事先创建好，如果不存在，log4j会自动创建。 12345678910//将日志信息输出到控制台log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.out//将日志信息输出到文件log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=test.log 日志布局及格式log4j可以配置日志的布局及格式，最常用的有以下三种： (1) HTMLLayout：将日志信息输出为HTML表格。参考代码如下所示： 123log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=test.htmllog4j.appender.file.layout=org.apache.log4j.HTMLLayout 运行结果如下图所示。 (2) SimpleLayout：这是最简单的一种输出格式，只输出了日志级别和异常提示信息。 (3) PatternLayout：自定义输出格式，需要通过log4j.appender.file.layout.ConversionPattern属性来设置格式，常用的参数如下所示： 123456789101112131415%d：用来设置输出日志的日期和时间格式，默认格式为IS08601，也可以自定义格 式，例如%d&#123;yyyy-MM-dd HH : mm : ss&#125;，输出格式类似于2010-03-0917 : 51。%m：用来输出代码中设置的异常提示信息。%n：用来输出一个回车换行符。%I：用来输出日志事件的发生位置，包括类名、发生错误的行号等信息。%F：用来输出文件名。%M：用来输出方法名。log4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %m%n 注意： log4j.properties文件不能随意命名，而且必须放置在src根目录下。]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Exception</tag>
        <tag>Log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形展示状态码]]></title>
    <url>%2F2019%2F09%2F09%2Fhttp2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP-IP]]></title>
    <url>%2F2019%2F09%2F09%2Ftcp-ip%2F</url>
    <content type="text"><![CDATA[参考文档： OSI七层模型与TCP/IP五层模型 TCP/IP教程 PS:大致内容：OSI参考模型 、PDU、对等通信、TCP/IP 、协议族 OSI参考模型 OSI（Open System Interconnect）,即开放式系统互联。 一般都叫OSI参考模型,是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及,推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范,就能互联了。 OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）,即ISO开放互连系统参考模型。 协议数据单元PDU(Protocol Data Unit)是指对等层次之间传递的数据单位。 协议数据单元(Protocol Data Unit )物理层的 PDU是数据位(bit),数据链路层的 PDU是数据帧(frame),网络层的PDU是数据包(packet),传输层的 PDU是数据段(segment)其他更高层次的PDU是报文(message) Q：什么时候有PDU？ A：当需要跟别人通信时候才有。 整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。 应用层 OSI参考模型中最靠近用户的一层,是为计算机用户提供应用接口,也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP,HTTPS,FTP,POP3,SMTP等。公司A的老板就是我们所述的用户,而他要发送的商业报价单,就是应用层提供的一种网络服务,当然,老板也可以选择其他服务,比如说:发一份商业合同,发一份询价单,等等 表示层 提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要,该层可提供一种标准表示形式,用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层(公司的文秘),就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到,公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用,将应用层的数据转换翻译等 会话层 负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成.会话层的同事拿到表示层的同事转换后资料,（会话层的同事类似公司的外联部）,会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封,并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后,此次会话就算结束了,外联部的同事就会终止此次会话 传输层 传输层建立了主机端到端的链接,传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务,包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节,使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的TCP、 UDP就是在这一层。端口号既是这里的“端”。传输层就相当于公司中的负责快递邮件收发的人,公司自己的投递员,他们负责将上一层的要寄出的资料投递到快递公司或邮局 网络层 本层通过IP寻址来建立两个节点之间的连接,为源端的运输层送来的分组,选择合适的路由和交换节点,正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。网络层就相当于快递公司庞大的快递网络,全国不同的集散中心,比如说,从深圳发往北京的顺丰快递(陆运为例啊，空运好像直接就飞到北京了),首先要到顺丰的深圳集散中心,从深圳集散中心再送到武汉集散中心,从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心,就相当于网络中的一个IP节点 数据链路层 将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。数据链路层又分为2个子层：逻辑链路控制子层(LLC)和媒体访问控制子层(MAC)。MAC子层处理CSMA/CD算法、数据出错校验、成帧等;LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。 物理层 实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。快递寄送过程中的交通工具,就相当于我们的物理层，例如汽车、火车、飞机、船 通信特点：对等通信对等通信,为了使数据分组从源传送到目的地,源端OSI模型的每一层都必须与目的端的对等层进行通信,这种通信方式称为对等层通信。在每一层通信过程中,使用本层自己协议进行通信。 TCP/IP 是因特网的通信协议 TCP/IP 通信协议定义了电子设备(比如计算机)如何连入因特网,以及数据如何在它们之间传输的标准。 浏览器使用 TCP/IP 协议进入服务器,服务器使用 TCP/IP 协议来发送 HTML 到浏览器。 在 TCP/IP 中包含一系列用于处理数据通信的协议： TCP (传输控制协议) - 应用程序之间通信 UDP (用户数据报协议) - 应用程序之间的简单通信 IP (网际协议) - 计算机之间的通信 ICMP (因特网消息控制协议) - 针对错误和状态 DHCP (动态主机配置协议) - 针对动态寻址 TCP 使用固定的连接 TCP 用于应用程序之间的通信。当应用程序希望通过 TCP 与另一个应用程序通信时,它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方”握手”之后,TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。UDP 和 TCP 很相似,但是更简单,同时可靠性低于 TCP。 IP 是无连接的 IP 用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。 IP 路由器 当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。IP 路由器负责将这个包路由至它的目的地，直接地或者通过其他的路由器。在一个相同的通信中，一个包所经由的路径可能会和其他的包不同。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。 TCP/IP 意味着 TCP 和 IP 在一起协同工作。 TCP 负责应用软件(比如您的浏览器)和网络软件之间的通信。IP 负责计算机之间的通信。 TCP 负责将数据分割并装入 IP 包,然后在它们到达的时候重新组合它们。IP 负责将包发送至接受者。 TCP/IP五层协议和OSI的七层协议对应关系如下： 在每一层都工作着不同的设备： 在每一层实现的协议也各不同，即每一层的服务也不同.下图列出了每层主要的协议： 协议族 TCP/IP 是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合。 协议 名称 作用 TCP 传输控制协议(Transmission Control Protocol) 用于从应用程序到网络的数据传输控制,负责在数据传送之前将它们分割为 IP 包,然后在它们到达的时候将它们重组 IP 网际协议(Internet Protocol) 负责计算机之间的通信,负责在因特网上发送和接收数据包 HTTP 超文本传输协议(Hyper Text Transfer Protocol) 负责 web 服务器与 web 浏览器之间的通信,用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页） HTTPS 安全的 HTTP(HTTP Secure) 负责在 web 服务器和 web 浏览器之间的安全通信,作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据 SSL 安全套接字层(Secure Sockets Layer) 用于为安全数据传输加密数据 SMTP 简易邮件传输协议(Simple Mail Transfer Protocol) 用于电子邮件的传输,可以传送纯文本，但是无法传输诸如图片、声音或者电影之类的二进制数据(SMTP 使用 MIME 协议通过 TCP/IP 网络来发送二进制数据。MIME 协议会将二进制数据转换为纯文本) MIME 多用途因特网邮件扩展(Multi-purpose Internet Mail Extensions) 使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件,包括声音、视频和二进制数据 IMAP 因特网消息访问协议(Internet Message Access Protocol) 用于存储和取回电子邮件(有能力在下载邮件之前先通过邮件服务器端查看他们。通过 IMAP,可以选择下载这些邮件或者仅仅是删除它们) POP 邮局协议(Post Office Protocol) 用于从电子邮件服务器向个人电脑下载电子邮件(一旦它连接上邮件服务器，您的所有的邮件都会被下载到邮件程序中) FTP 文件传输协议(File Transfer Protocol) 负责计算机之间的文件传输 NTP 网络时间协议(Network Time Protocol) 用于在计算机之间同步时间(钟) DHCP 动态主机配置协议(Dynamic Host Configuration Protocol) 用于向网络中的计算机分配动态 IP 地址 SNMP 简单网络管理协议(Simple Network Management Protocol) 用于计算机网络的管理 LDAP 轻量级的目录访问协议(Lightweight Directory Access Protocol) 用于从因特网搜集关于用户和电子邮件地址的信息 ICMP 因特网消息控制协议(Internet Control Message Protocol) 负责网络中的错误处理 ARP 地址解析协议(Address Resolution Protocol) 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址 RARP 反向地址转换协议(Reverse Address Resolution Protocol) 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址 BOOTP 自举协议(Boot Protocol) 用于从网络启动计算机 PPTP 点对点隧道协议(Point to Point Tunneling Protocol) 用于私人网络之间的连接(隧道)]]></content>
      <categories>
        <category>TCP</category>
        <category>IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NatApp免费使用需知]]></title>
    <url>%2F2019%2F09%2F09%2Fnatapp1%2F</url>
    <content type="text"><![CDATA[原文链接NatApp注册安装使用 NatApp免费内网穿透，需要支付宝实名认证（笔者于2018年12月25日操作【2019也可参考】）； NatApp免费内网穿透，会不定时强制更换域名/端口； NatApp免费内网穿透，免费隧道/HK_2型隧道不支持https； NatApp免费内网穿透使用，需要下载客户端（如：windows下的natapp.exe）和配置config.ini文件 注册账号在NatApp上注册账号：https://natapp.cn/register 实名认证我的账户–实名认证–支付宝扫码确认 购买隧道1.点击左边 购买隧道,免费 2.选择端口（如：8080）进行内网穿透，并免费购买 一个注册用户可免费拥有2条不同协议的隧道 隧道协议: Web: 普通型http(s)隧道穿透,用于搭建网站,微信开发等穿透到本地web服务. TCP: 端口转发 应用于SSH,数据库,远程桌面,GAME等基于TCP连接的一切应用任您想象~ UDP: 端口转发 应用于游戏,远程开机等基于UDP协议的一切应用 选定后不可更改 客户端下载和运行1.下载客户端 在 natapp.cn 根据您的本机下载对应的客户端,比如我的本机是win7,64位,则下载Windows 64位的客户端 客户端地址：https://natapp.cn/#download 下载之后,解压至任意目录,得到natapp.exe 取得authtoken在网站后台,我的隧道处,可以看到刚才购买的隧道 点击复制,即可得到 authtoken 这个authtoken便是您的隧道登录凭证 运行natappa) config.ini方式 (推荐)config.ini文件下载地址：https://natapp.cn/article/config_ini 根据操作系统下载不同的config.ini文件，到刚才下载的natapp.exe同级目录 【注意：将config.ini放在客户端的同级目录】 将得到的authtoken填进去 (其他地方都不填),然后保存 windows下,直接双击natapp.exe 即可. 在Linux/Mac 下 需要先给执行权限 chmod a+x natapp 然后再运行./natapp b) cmd -authtoken= 参数方式运行.windows ,点击开始-&gt;运行-&gt;命令行提示符 后进入 natapp.exe的目录 natapp -authtoken=9ab6b9040a624f40 linux ,同样给予可执行权限之后,运行 ./natapp -authtoken=9ab6b9040a624f40 注意参数输入正确性,不要有多余的空格等! 运行成功,都可以得到如下界面: Tunnel Status Online 代表链接成功 Version 当前客户端版本,如果有新版本,会有提示 Forwarding 当前穿透 网址 或者端口 Web Interface 是本地Web管理界面,可在隧道配置打开或关闭,仅用于web开发测试 Total Connections 总连接数 Avg Conn Time 0.00ms 这里不代表,不代表,不代表 延时,需要注意! 本机建立web服务并启动本机建立启动web服务,如 nginx/apache/iis 等，端口为隧道中配置的端口（如：8080） 确保 http://127.0.0.1:8080 可以访问 使用Natapp分配的网址将natapp分配的网址(运行成功中的Forwarding )，鼠标选定然后复制下来(选定之后单击鼠标右键)， 在浏览器中访问,可以看到内网穿透成功了! NatApp修改映射IP我的渠道，找到需要修改映射IP的渠道，点击配置 本地地址中修改，默认127.0.0.1 可改为其他内网地址]]></content>
      <categories>
        <category>开发工具及技术</category>
        <category>NatApp</category>
      </categories>
      <tags>
        <tag>NatApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse导出Maven项目生成war包]]></title>
    <url>%2F2019%2F09%2F09%2Feclipse1%2F</url>
    <content type="text"><![CDATA[第一种方法：maven build①eclipse中，在需要打包的项目名上右击选中，然后把鼠标光标指向弹出框中的“run as”：会看到在这个弹出框的右侧会出现一个悬浮窗，如下：②在上边的第二个悬浮窗鼠标点击“maven clean”，maven会清除掉之前对这个项目的打包信息；执行以后在eclipse的控制台console会看到如下信息： ③重复第一、二步，选择“maven build”，会看到如下弹出界面，在“Goals”后的文本框内输入“-X package”,勾选上下方的“update snapshots”和“skip tests”，然后点击右下方的“run”. ④Run之后可以看到eclipse控制台输出如下内容，代表打包成功： ⑤然后在项目名上右击，选择“refresh”刷新，再打开项目目录，可以看到在项目下的target下已经生成了一个“你的项目名.war”的文件，.war结尾，项目名开头。把这个.war结尾的文件拷贝到服务器中，例如tomcat的webapps目录下，启动tomcat服务器，然后就可以在浏览器中正常访问这个web项目了。 项目名称修改时候的war包注意事项： ①正常打包，生成的文件名就是项目名，但是如果我们更改过项目名，那么打包后的文件名依旧是之前的项目名，而不是更改后的；例如我把下面的planSystem1项目名改为myPlanSystem，再打包，就会看到生成的文件依旧是planSystem1.war,如图： ②这时候需要打开上图中另一个箭头所指的“pom.xml”修改一些东西，打开pom.xml，在如下界面中点击箭头所指的地方，在出现的代码区域搜索“finalName”，会看到finalName中间依旧是之前的项目名： ③把这里的名称改为更改之后的项目名，如图： ④保存后重新执行打包操作，之后再查看就会看到.war文件名已经成功变成了更改后的项目名： 第二种方法:利用Eclipse的export 功能但是需要修改.classpath 中的maven classpth的配置信息： 把原来的配置信息： 1&lt;classpathentry kind="con" path="org.maven.ide.eclipse.MAVEN2_CLASSPATH_CONTAINER"/&gt; 修改为： 12&lt;classpathentry exported="true" kind="con" path="org.maven.ide.eclipse.MAVEN2_CLASSPATH_CONTAINER"&gt; &lt;attributes&gt; &lt;attributename="org.eclipse.jst.component.dependency" value="/WEB-INF/lib"/&gt; &lt;/attributes&gt; &lt;/classpathentry&gt; 然后再export 就可以成功导出war包，这样才会同时把lib包一起导出来. 第三种:利用maven的插件pom.xml中: 12345678910&lt;!-- tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;path&gt;/SSM&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; run as :tomcat7:exec-war或者tomcat7:exec-war-only 参考链接https://www.cnblogs.com/qlqwjy/p/8231032.html https://blog.csdn.net/lt_yl/article/details/78458538]]></content>
      <categories>
        <category>开发工具及技术</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程]]></title>
    <url>%2F2019%2F09%2F09%2Fbingfa1%2F</url>
    <content type="text"><![CDATA[线程基础、线程之间的共享和协作基础概念CPU核心数和线程数的关系核心数:线程数=1:1 ;使用了超线程技术后—&gt; 1:2 我们在选购电脑的时候，CPU是一个需要考虑到核心因素，因为它决定了电脑的性能等级。CPU从早期的单核，发展到现在的双核，多核。CPU除了核心数之外，还有线程数之说，下面笔者就来解释一下CPU的核心数与线程数的关系和区别。 简单地说，CPU的核心数是指物理上，也就是硬件上存在着几个核心。比如，双核就是包括2个相对独立的CPU核心单元组，四核就包含4个相对独立的CPU核心单元组，等等，依次类推。 线程数是一种逻辑的概念，简单地说，就是模拟出的CPU核心数。比如，可以通过一个CPU核心数模拟出2线程的CPU，也就是说，这个单核心的CPU被模拟成了一个类似双核心CPU的功能。我们从任务管理器的性能标签页中看到的是两个CPU。 比如Intel 赛扬G460是单核心，双线程的CPU，Intel 酷睿i3 3220是双核心 四线程，Intel 酷睿i7 4770K是四核心 八线程 ，Intel 酷睿i5 4570是四核心 四线程等等。 对于一个CPU，线程数总是大于或等于核心数的。一个核心最少对应一个线程，但通过超线程技术，一个核心可以对应两个线程，也就是说它可以同时运行两个线程。 CPU的线程数概念仅仅只针对Intel的CPU才有用，因为它是通过Intel超线程技术来实现的，最早应用在Pentium4上。如果没有超线程技术，一个CPU核心对应一个线程。所以，对于AMD的CPU来说，只有核心数的概念，没有线程数的概念。 CPU之所以要增加线程数，是源于多任务处理的需要。线程数越多，越有利于同时运行多个程序，因为线程数等同于在某个瞬间CPU能同时并行处理的任务数。 在Windows中，在cmd命令中输入wmic,然后在出现的新窗口中输入cpu get * 即可查看物理CPU数、CPU核心数、线程数。其中: Name:表示物理CPU数 NumberOfCores：表示CPU核心数 NumberOfLogicalProcessors：表示CPU线程数 CPU时间片轮转机制又称RR调度，会导致上下文切换. 时间片轮转（RR）调度算法是专门为分时系统设计的。它类似于 FCFS调度，但是增加了抢占以切换进程。该算法中，将一个较小时间单元定义为时间量或时间片。时间片的大小通常为 10~100ms。就绪队列作为循环队列。CPU 调度程序循环整个就绪队列，为每个进程分配不超过一个时间片的 CPU。 为了实现 RR 调度，我们再次将就绪队列视为进程的 FIFO 队列。新进程添加到就绪队列的尾部。CPU 调度程序从就绪队列中选择第一个进程，将定时器设置在一个时间片后中断，最后分派这个进程。 接下来，有两种情况可能发生。进程可能只需少于时间片的 CPU 执行。对于这种情况，进程本身会自动释放 CPU。调度程序接着处理就绪队列的下一个进程。否则，如果当前运行进程的 CPU 执行大于一个时间片，那么定时器会中断，进而中断操作系统。然后，进行上下文切换，再将进程加到就绪队列的尾部，接着 CPU 调度程序会选择就绪队列内的下一个进程。 不过，采用 RR 策略的平均等待时间通常较长。假设有如下一组进程，它们在时间 0 到达，其 CPU 执行以 ms 计： 进程 执行时间 P1 24 P2 3 P3 3 如果使用 4ms 的时间片，那么 P1 会执行最初的 4ms。由于它还需要 20ms，所以在第一个时间片之后它会被抢占，而 CPU 就交给队列中的下一个进程。由于 P2 不需要 4ms，所以在其时间片用完之前就会退出。CPU 接着交给下一个进程，即进程 P3。在每个进程都得到了一个时间片之后，CPU 又交给了进程 P1 以便继续执行。因此，RR 调度结果如下： 现在，我们计算这个调度的平均等待时间。P1 等待 10-4 = 6ms，P2 等待 4ms，而 P3 等待 7ms。因此，平均等待时间为 17/3 = 5.66ms。 在 RR 调度算法中，没有进程被连续分配超过一个时间片的 CPU（除非它是唯一可运行的进程）。如果进程的 CPU 执行超过一个时间片，那么该进程会被抢占，并被放回到就绪队列。因此，RR调度算法是抢占的。 如果就绪队列有 n 个进程，并且时间片为 q，那么每个进程会得到 1/n 的 CPU 时间，而且每次分得的时间不超过 q 个时间单元。每个进程等待获得下一个 CPU 时间片的时间不会超过 (n-1)q 个时间单元。例如，如果有 5 个进程，并且时间片为 20ms，那么每个进程每 100ms 会得到不超过 20ms 的时间。 RR 算法的性能很大程度取决于时间片的大小。在一种极端情况下，如果时间片很大，那么 RR 算法与 FCFS 算法一样。相反，如果时间片很小（如 1ms），那么 RR 算法可以导致大量的上下文切换。 例如，假设我们只有一个需要 10 个时间单元的进程。如果时间片为 12 个时间单元，那么进程在一个时间片不到就能完成，而且没有额外开销。如果时间片为 6 个时间单元，那么进程需要 2 个时间片，并且还有一个上下文切换。如果时间片为 1 个时间单元，那么就会有 9 个上下文切换，相应地使进程执行更慢（图 1)。 ​ 图 1 更小时间片如何增加上下文切换 因此，我们希望时间片远大于上下文切换时间。如果上下文切换时间约为时间片的 10%，那么约 10% 的 CPU 时间会浪费在上下文切换上。在实践中，大多数现代操作系统的时间片为 10~100ms，上下文切换的时间一般少于 10ms；因此，上下文切换的时间仅占时间片的一小部分。 周转时间也依赖于时间片大小。正如从图 2 中所看到的，随着时间片大小的增加，一组进程的平均周转时间不一定会改善。一般情况下，如果大多数进程能在一个时间片内完成，那么平均周转时间会改善。 ​ 图 2 周转时间如何随着时间片大小而改变 例如，假设有三个进程，都需要 10 个时间单元。如果时间片为 1 个时间单元，那么平均周转时间为 29；如果时间片为 10，那么平均周转时间会降为 20；如果再考虑上下文切换时间，那么平均周转时间对于较小时间片会增加，这是因为需要更多的上下文切换。 尽管时间片应该比上下文切换时间要大，但也不能太大。如果时间片太大，那么 RR 调度就演变成了 FCFS 调度。根据经验，80% 的 CPU 执行应该小于时间片。 FCFS调度算法毫无疑问，最简单的 CPU 调度算法是先来先服务（FCFS）调度箅法。釆用这种方案，先请求 CPU 的进程首先分配到 CPU。 FCFS 策略可以通过 FIFO 队列容易地实现。当一个进程进入就绪队列时，它的 PCB 会被链接到队列尾部。当 CPU 空闲时，它会分配给位于队列头部的进程，并且这个运行进程从队列中移去。FCFS 调度代码编写简单并且理解容易。 FCFS 策略的缺点是，平均等待时间往往很长。假设有如下一组进程，它们在时间 0 到达，CPU 执行长度按 ms 计： 进程 执行时间 P1 24 P2 3 P3 3 如果进程按 P1、P2、P3 的顺序到达，并且按 FCFS 顺序处理，那么得到如下 Gantt 图所示的结果（这种 Gantt 图为条形图，用于显示调度情况，包括每个进程的开始与结束时间）： 进程 P1 的等待时间为 0ms，进程 P2 的等待时间为 24ms，而进程 P3 的等待时间为 27ms。因此，平均等待时间为 (0 + 24 + 27)/3 = 171ms。不过，如果进程按 P2、P3、P1 的顺序到达，那么结果如以下 Gantt 图所示： 现在平均等待时间为 (6 + 0+3)/3 = 3ms。这个减少是相当大的。因此，FCFS 策略的平均等待时间通常不是最小，而且如果进程的 CPU 执行时间变化很大，那么平均等待时间的变化也会很大。 另外，考虑动态情况下的 FCFS 调度性能。假设有一个 CPU 密集型进程和多个 I/O 密集型进程。随着进程在系统中运行，可能发生如下情况：CPU 密集型进程得到 CPU，并使用它。在这段时间内，所有其他进程会处理完它们的 I/O，并转移到就绪队列来等待 CPU。当这些进程在就绪队列中等待时，I/O 设备空闲。最终，CPU 密集型进程完成 CPU 执行并且移到 I/O 设备。所有 I/O 密集型进程，由于只有很短的 CPU 执行，故很快执行完并移回到 I/O 队列。这时，CPU 空闲。之后，CPU 密集型进程会移回到就绪队列并分配到 CPU。再次，所有 I/O 进程会在就绪队列中等待 CPU 密集型进程的完成。由于所有其他进程都等待一个大进程释放 CPU，故称之为护航效果。与让较短进程先进行相比，这会导致 CPU 和设备的使用率降低。 也要注意，FCFS 调度算法是非抢占的。一旦 CPU 分配给了一个进程，该进程就会使用 CPU 直到释放 CPU 为止，即程序终止或是请求 I/O。FCFS 算法对于分时系统（每个用户需要定时得到一定的 CPU 时间）是特别麻烦的。允许一个进程使用 CPU 过长将是个严重错误。 什么是进程和线程进程：程序运行资源分配的最小单位，进程内部有多个线程，会共享这个进程的资源 线程：CPU调度的最小单位，必须依赖进程而存在。本身不拥有资源. 并行和并发并行：同一时刻，可以同时处理事情的能力 并发：与单位时间相关，在单位时间内可以处理事情的能力 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发.(不一定是同时的) 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 并发的关键是你有处理多个任务的能力，不一定要同时. 并行的关键是你有同时处理多个任务的能力。 所以我认为它们最关键的点就是：是否是『同时』 参考链接 高并发编程的意义、好处和注意事项好处：充分利用cpu的资源、加快用户响应的时间，程序模块化，异步化. 问题： 线程共享资源，存在冲突； 容易导致死锁； 启用太多的线程，就有搞垮机器的可能 认识Java里的线程 新启线程的方式 JAVA里的程序天生就是多线程的.eg:如下简单的main方法-并不是只有Main主线程. 123456789public class Test &#123;public static void main(String[] args) &#123; //虚拟机线程管理的接口(可以拿去线程信息) ThreadMXBean threadMXBean=ManagementFactory.getThreadMXBean(); ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false); for (ThreadInfo threadInfo : threadInfos) &#123; System.out.println("["+threadInfo.getThreadId()+"]" +" "+threadInfo.getThreadName()); &#125;&#125;&#125; Console: 12345[5] Attach Listener //获取当前程序运行相关信息[4] Signal Dispatcher //分发虚拟机信号处理[3] Finalizer //调用Finalizer方法的线程,虚拟机不一定会执行[2] Reference Handler //负责清除引用线程[1] main //主线程(入口) 有三种启动线程的方式类Thread(单继承)–&gt;接口Runnable,接口Callable123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * @author PE * @date 2019年9月1日 上午10:56:35 * @explain */public class Test &#123; private static class UseThread extends Thread &#123; @Override public void run() &#123; System.out.println("I'm extends Thread"); &#125;&#125; private static class UserRunable implements Runnable &#123; @Override public void run() &#123; System.out.println("I'm implemets Runnable"); &#125; &#125; private static class UserCall implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; return "CallResult"; &#125; &#125; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; UseThread u = new UseThread(); u.start(); UserRunable u1 = new UserRunable(); new Thread(u1).start(); UserCall u2 = new UserCall(); // 包装成runnable FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(u2); new Thread(futureTask).start(); //futureTask.get()时是阻塞的,上面执行完才会执行下面 System.out.println(futureTask.get()); &#125;&#125; Console: 123I'm extends Thread I'm implemets RunnableCallResult 怎么样才能让Java里的线程安全停止工作呢 线程自然终止：自然执行完或抛出未处理异常 stop()，resume(),suspend()已不建议使用,stop()会导致线程不会正确释放资源，suspend()线程不释放资源,容易导致死锁。 java线程是协作式，而非抢占式 调用一个线程的interrupt() 方法中断一个线程，并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定。 12Thread t=new Thread(); t.interrupt();//该线程有可能不会理会 isInterrupted() 判定当前线程是否处于中断状态。 static方法interrupted() 判定当前线程是否处于中断状态，同时中断标志位改为false。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * @author PE * @date 2019年9月1日 上午10:56:35 * @explain */public class Test &#123; private static class UseThread extends Thread &#123; public UseThread(String name) &#123; super(name); &#125; @Override public void run() &#123; String threadName = Thread.currentThread().getName(); while (!isInterrupted()) &#123; System.out.println(threadName + " is run!"); &#125; System.out.println(threadName + " interrput flag is " + isInterrupted()); &#125; &#125; private static class UserRunable implements Runnable &#123; @Override public void run() &#123; String threadName = Thread.currentThread().getName(); while (!Thread.currentThread().isInterrupted()) &#123; System.out.println(threadName + " is run2!"); &#125;System.out.println(threadName + " interrput2 flag is " + Thread.currentThread().isInterrupted()); &#125; &#125; public static void main(String[] args)throws InterruptedException, ExecutionException &#123; /* Thread u = new UseThread("endThread"); u.start(); Thread.sleep(20); u.interrupt();*/ UserRunable u1 = new UserRunable(); Thread uii = new Thread(u1); uii.start(); Thread.sleep(20); uii.interrupt(); &#125;&#125; 方法里如果抛出InterruptedException，线程的中断标志位会被复位成false，如果确实是需要中断线程，要求我们自己在catch语句块里再次调用 1234567891011121314151617181920212223242526272829303132333435/** * @author PE * @date 2019年9月1日 上午10:56:35 * @explain */public class Test &#123; private static class UseThread extends Thread &#123; public UseThread(String name) &#123; super(name); &#125; @Override public void run() &#123; String threadName = Thread.currentThread().getName(); while (!isInterrupted()) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; System.out.println(threadName + " interrput flag is " + isInterrupted()); //要求我们自己在catch语句块里再次调用,防止出现Console下的情况 interrupt(); e.printStackTrace(); &#125; System.out.println(threadName); &#125; System.out.println(threadName + " interrput flag is " + isInterrupted()); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread u = new UseThread("endThread"); u.start(); Thread.sleep(500); u.interrupt(); &#125;&#125; Console: 123456789101112131415161718192021222324252627282930//try..catch 中未手动加入interrupt();endThreadendThreadendThreadendThreadendThread interrput flag is falsejava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at Test$UseThread.run(Test.java:22)endThreadendThreadendThreadendThreadendThreadendThreadendThreadendThreadendThreadendThread.....//try..catch 中手动interrupt();endThreadendThreadendThreadendThreadendThread interrput flag is falsejava.lang.InterruptedException: sleep interruptedendThreadendThread interrput flag is true at java.lang.Thread.sleep(Native Method) at Test$UseThread.run(Test.java:16) 对Java里的线程再多一点点认识线程常用方法和线程的状态 线程只有5种状态。整个生命周期就是这几种状态的切换。 run()和start() ：run方法就是普通对象的普通方法，只有调用了start()后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法。 12345678910111213141516171819202122232425262728293031323334353637383940package com.xiangxue.ch1;import java.util.concurrent.TimeUnit;/** *@author Mark老师 ThreadRun 首先是对象,然后再有特殊性,调用start,虚拟机才会将线程对象 和操作系统中实际的线程进行映射 *类说明：start和run方法的区别 */public class StartAndRun &#123; public static class ThreadRun extends Thread&#123; @Override public void run() &#123; int i = 90; while(i&gt;0)&#123; ms(1000); System.out.println("I am "+Thread.currentThread().getName() +" and now the i="+i--); &#125; &#125; &#125; /** * 按毫秒数休眠 * @param seconds 毫秒数 */ public static final void ms(int seconds) &#123; try &#123; TimeUnit.MILLISECONDS.sleep(seconds); &#125; catch (InterruptedException e) &#123; &#125; &#125; public static void main(String[] args) &#123; ThreadRun beCalled = new ThreadRun(); beCalled.setName("BeCalled"); //beCalled.run(); beCalled.start(); &#125;&#125; Console: 123456789101112//run()方法I am main and now the i=90I am main and now the i=89I am main and now the i=88I am main and now the i=87......//start()方法I am BeCalled and now the i=90I am BeCalled and now the i=89I am BeCalled and now the i=88I am BeCalled and now the i=87..... yield() ：让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行。 线程的优先级取值为1~10，缺省为5，但线程的优先级不可靠，不建议作为线程开发时候的手段 1beCalled.setPriority(5); 守护线程和主线程不一定同生但一定共死，finally不能保证一定执行. 123456789101112131415161718192021222324252627282930313233343536package com.xiangxue.ch1;import java.util.concurrent.ExecutionException;/** * @author Mark老师 * * 类说明：守护线程的使用和守护线程中的finally语句块 */public class DaemonThread &#123; private static class UseThread extends Thread &#123; @Override public void run() &#123; try &#123; while (!isInterrupted()) &#123; System.out.println(Thread.currentThread().getName() + " I am extends Thread."); &#125; System.out.println(Thread.currentThread().getName() + " interrupt flag is " + isInterrupted()); &#125; finally &#123; System.out.println("...........finally"); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; UseThread useThread = new UseThread(); //是否设置为守护线程 // useThread.setDaemon(true); useThread.start(); Thread.sleep(5); //useThread.interrupt(); &#125;&#125; Console: 1234567891011//useThread.setDaemon(false);+ useThread.interrupt();Thread-0 I am extends Thread......Thread-0 I am extends Thread.Thread-0 interrupt flag is true...........finally//useThread.setDaemon(true);Thread-0 I am extends Thread......Thread-0 I am extends Thread.Thread-0 interrupt flag is true 线程间的共享synchronized内置锁对象锁，锁的是类的对象实例类锁,锁的是每个类的的Class对象(每个类的的Class对象在一个虚拟机中只有一个，所以类锁也只有一个) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import com.xiangxue.tools.SleepTools;/** *@author Mark老师 *类说明：演示对象锁和类锁 */public class SynClzAndInst &#123; //使用类锁的线程 private static class SynClass extends Thread&#123; @Override public void run() &#123; System.out.println("TestClass is running..."); synClass(); &#125; &#125; //使用对象锁的线程 private static class InstanceSyn implements Runnable&#123; private SynClzAndInst synClzAndInst; public InstanceSyn(SynClzAndInst synClzAndInst) &#123; this.synClzAndInst = synClzAndInst; &#125; @Override public void run() &#123; System.out.println("TestInstance is running..."+synClzAndInst); synClzAndInst.instance(); &#125; &#125; //使用对象锁的线程 private static class Instance2Syn implements Runnable&#123; private SynClzAndInst synClzAndInst; public Instance2Syn(SynClzAndInst synClzAndInst) &#123; this.synClzAndInst = synClzAndInst; &#125; @Override public void run() &#123; System.out.println("TestInstance2 is running..."+synClzAndInst); synClzAndInst.instance2(); &#125; &#125; //锁对象 private synchronized void instance()&#123; SleepTools.second(3); System.out.println("synInstance is going..."+this.toString()); SleepTools.second(3); System.out.println("synInstance ended "+this.toString()); &#125; //锁对象 private synchronized void instance2()&#123; SleepTools.second(3); System.out.println("synInstance2 is going..."+this.toString()); SleepTools.second(3); System.out.println("synInstance2 ended "+this.toString()); &#125; //类锁，实际是锁类的class对象 private static synchronized void synClass()&#123; SleepTools.second(1); System.out.println("synClass going..."); SleepTools.second(1); System.out.println("synClass end"); &#125; public static void main(String[] args) &#123; SynClzAndInst synClzAndInst = new SynClzAndInst(); Thread t1 = new Thread(new InstanceSyn(synClzAndInst)); //不同对象锁可以并行运行. //SynClzAndInst synClzAndInst2 = new SynClzAndInst(); //同一对象锁,需要排队 //Thread t2 = new Thread(new Instance2Syn(synClzAndInst)); t1.start(); //t2.start(); //类锁和对象锁可以并行运行 SynClass synClass = new SynClass(); synClass.start(); SleepTools.second(1); &#125;&#125; volatile关键字(最轻量的同步机制)适合于只有一个线程写，多个线程读的场景，因为它只能确保可见性(多个线程写,不能保证原子性,安全性低)。 123456789101112131415161718192021222324252627282930313233343536373839package com.xiangxue.ch1.vola;import java.util.concurrent.TimeUnit;/** *@author Mark老师 * *类说明：演示violate无法提供操作的原子性 */public class VolatileUnsafe &#123; private static class VolatileVar implements Runnable &#123; private volatile int a = 0; @Override public void run() &#123; String threadName = Thread.currentThread().getName(); a = a++; System.out.println(threadName+":======"+a); try &#123; TimeUnit.MILLISECONDS.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; a = a+1; System.out.println(threadName+":======"+a); &#125; &#125; public static void main(String[] args) &#123; VolatileVar v = new VolatileVar(); Thread t1 = new Thread(v); Thread t2 = new Thread(v); Thread t3 = new Thread(v); Thread t4 = new Thread(v); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; Console: 12345678Thread-2:======0Thread-3:======0Thread-0:======0Thread-1:======0Thread-2:======2Thread-3:======2Thread-0:======3Thread-1:======4 ThreadLocal线程变量可以理解为是个map，类型 Map&lt;Thread,Integer&gt;. 每个线程都拥有自己的副本. 优点:共享同一个变量时,线程之间不会起冲突. 缺点:,存储东西比较大,占有内存资源非常大.(用空间换取安全性) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** *@author Mark老师 *类说明：演示ThreadLocal的使用(线程池) */public class UseThreadLocal &#123; //可以理解为 一个map，类型 Map&lt;Thread,Integer&gt; static ThreadLocal&lt;Integer&gt; threadLaocl = new ThreadLocal&lt;Integer&gt;()&#123; @Override protected Integer initialValue() &#123; return 1; &#125; &#125;; /** * 运行3个线程 */ public void StartThreadArray()&#123; Thread[] runs = new Thread[3]; for(int i=0;i&lt;runs.length;i++)&#123; runs[i]=new Thread(new TestThread(i)); &#125; for(int i=0;i&lt;runs.length;i++)&#123; runs[i].start(); &#125; &#125; /** *类说明：测试线程，线程的工作是将ThreadLocal变量的值变化， *并写回，看看线程之间是否会互相影响 */ public static class TestThread implements Runnable&#123; int id; public TestThread(int id)&#123; this.id = id; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName()+":start"); Integer s = threadLaocl.get();//获得变量的值 s = s+id; threadLaocl.set(s); System.out.println(Thread.currentThread().getName()+":" +threadLaocl.get()); //threadLaocl.remove();并不是必须的 &#125; &#125; public static void main(String[] args)&#123; UseThreadLocal test = new UseThreadLocal(); test.StartThreadArray(); &#125;&#125;]]></content>
      <categories>
        <category>线程</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当tomcat端口被占用怎么查看占用程序]]></title>
    <url>%2F2019%2F09%2F09%2Fxzs2%2F</url>
    <content type="text"><![CDATA[注意:管理员操作 1.netstat -aon|findstr “端口号” 2.tasklist|findstr “查询出的 listening” 3.taskkill /f /t /im 查询出占用程序名称,显示已终止即成功(注意:有空格)]]></content>
      <categories>
        <category>小知识</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据源-连接池(部分知识点)]]></title>
    <url>%2F2019%2F09%2F09%2Fsql5%2F</url>
    <content type="text"><![CDATA[什么是数据源？ 数据源定义的是连接到实际数据库的一条路径而已，数据源中并无真正的数据，它仅仅记录的是你连接到哪个数据库，以及如何连接的，如odbc数据源。也就是说数据源仅仅是数据库的连接名称，一个数据库可以有多个数据源连接.在Java语言中，DataSource对象就是一个代表数据源实体的对象。一个数据源就是一个用来存储数据的工具，它可以是复杂的大型企业级数据库，也可以是简单得只有行和列的文件。数据源可以位于在服务器端，也可以位于客服端。 数据源（DataSource）用来连接数据库，创建连接（Connection）对象。 java.sql.DataSource接口负责建立与数据库的连接由Tomcat提供，将连接保存在连接池中。 什么是数据库连接池？数据库连接是负责分配、管理和释放数据库连接。使用数据库连接池是因为数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。如weblogic、tomcat、WebSphere容器都实现了数据库连接池，但是数据库连接池是可以独立出来自己编码实现的。 数据库连接池在系统启动时初始化了一定量maxIdle=idlenum的数据库连接，即没有他的使用中的链接被释放的情况下，连接池中保存的最大空闲链接数。数据库连接请求如果没有超过idle的值则直接去连接池中获取；如果超过了maxIdle的值则新建一个数据库连接；但如果数据库连接池中的连接总数超过了maxActive=activenum则 (如下处理)； 直接抛错 让想要借出连接的线程等待一段时间，如果等不到，再抛错 每隔一段检查一次pool，直到有可用连接，否则一直等下去 永远可以拿到(视情况需要maxActive不设置或0或负) 但当没有可以使用的数据库链接的时候，连接池将要等待一个链接被返回的最长时间（毫秒）maxWait=waitnum，超过这个时间就要抛出异常。 什么是jndi？jndi全称是java naming and directory interface。简单点就是你按命名规则给一个东西命名然后你就可以通过该名字在特定环境下直接查找到该东西了。 JNDI是用于向Java程序提供目录和命名功能的API。可以简单地把JNDI理解为一种将对象和名字绑定的技术，对象工厂负责生产出对象，这些对象都和惟一的名字绑定。外部程序可以通过名字来获取对某个对象的引用。在一个文件系统中，文件名被绑定给文件。在DNS中，一个IP地址绑定一个URL。在目录服务中，一个对象名被绑定给一个对象实体。 在Intranets(企业内部网)和Internates（互联网）中目录服务(Directory service)都非常重要，它规范了命名规则，让人们容易理解实体及之间的关系。JNDI是Java平台的一个标准扩展，提供了一组接口、类和关于命名空间的概念。JNDI目前所支持的技术包括LDAP、CORBA Common Object Service（COS）名字服务、RMI、NDS、DNS、Windows注册表等等。 jndi被设计成独立于特定的目录服务，所以各种各样的目录都可以通过相同的方式进行访问。这样使用jndi的java程序员不仅可以获得统一规整的命名和目录，而且可以通过多层的命名方案无缝访问(seamless acess)目录对象。 数据源与数据库连接池关系？我们通过第三方工具来使用数据源来实现对数据库数据操作。一个数据库连接池可以给它创建多个数据源，如一个人有别名；如果单纯使用jdbc连接数据库是web容器你要什么就去连什么。这样做没人看不耗内存，量大了你就死机。可以这样理解，数据源表示一个与数据库的连接（传统）或者表示很多与数据库的连接（使用数据库连池)。数据源是用于访问连接池或多池的JNDI对象，多池的主要目的是提高可用性和在一组连接池间实现负载均衡。 数据源与jndi关系？数据源是在JDBC 2.0中引入的一个概念。在JDBC 2.0扩展包中定义了javax.sql.DataSource接口来描述这个概念。如果用户希望建立一个数据库连接，通过查询在JNDI服务中的数据源，可以从数据源中获取相应的数据库连接。这样用户就只需要提供一个逻辑名称Logic Name，而不是数据库登录的具体细节。即DataSource采用Java的JNDI技术，来获得DataSource对象的引用。当然各种web容器把DataSource作为一种可以配置的JNDI资源来处理如tomcat。生成DataSource对象的工厂为org.apache.commons.dbcp.BasicDataSourceFactory。 jdbc基础java database connectivity standard 是一套规范的面向应用程序的接口，通过它可以访问各类关系数据库。各个数据库会实现该接口作为驱动如jtds.jar，当然可以自己写实现。 jdbc是低级api，提供访问数据库的接口，是构建高级api的基础，利用纯java编写可以在任何操作系统任何java环境下工作。JDBC API 中定义了一些Java类分别用来表示与数据库的连接（connections）, SQL语句（SQL Statements）, 结果集（ResultSets）以及其它的数据库对象, 使得Java程序能方便地与数据库交互并处理所得的结果。 使用JDBC, 所有Java程序（包括Java applications , applets和servlet）都能通过SQL语句或存储在数据库中的过程（stored procedures）来存取数据库。要通过JDBC来存取某一特定的数据库，必须有相应的JDBC driver，它往往是由生产数据库的厂家提供，是连接JDBC API与具体数据库之间的桥梁。JDBC Driver 是用于特定数据库的一套实施了JDBC接口的类集。 简单的说，jdbc可以做三件事：与数据库建立连接，发送sql语句，处理结果。jdbc可以理解为odbc的纯java语言和面向对象的实现。 数据库访问方法在ASP中可以通过三种方式访问数据库： IDC（Internet Database Connector）方式； ADO（ActiveX Data Objects）方式； RDS（Remote Data Service）方式。 在jsp中访问数据库常用： JDBC-ODBC桥接器； 特定数据库的jdbc驱动直接连接数据库； 经过池化维护一定量的连接数目，用jndi去访问数据源对应池获取连接； 数据库是一个数据的工厂，可以理解成产品的生产厂家，如果你从厂家租用东西，厂家就马上找人开工，启动设备，等生产好之后，发货给你。当然整个生产过程需要比较长的时间。 数据源，是一个产品代理仓库，代理那里原来就有一些生产好的产品了，所以你从代理获取产品，可以马上就得到。当然代理的仓库也是有大小限制的。无论哪种情况，你用完了某个产品，记得要归还哦。 ODBC（Open DataBase Conectivity）是微软公司制定的标准编程接口，只要有相应的ODBC驱动程序，就可以通过ODBC连结操作各种不同的数据库。通常通过控制面板中的ODBC Data Source来配置ODBC的数据源。所谓ODBC数据源就是命名的一组信息，包括需要连结的数据库所在位置（可以是磁盘目录/文件，也可以是网络服务器）、对应的ODBC驱动程序以及访问数据库所需的其他相关信息，用户可以通过数据源的名称(DSNs，Data Source Names)来指定所需的ODBC连接。 DSNs按照其保存方式和作用范围分为三种：用户DSN、系统DSN和文件DSN。每个文件DSN保存在单独的一个文件中，文件可以在网络范围内共享；用户DSN保存在注册表中，只对当前用户可见；系统DSN页保存在注册表中，但对系统中的所有用户可见。用户DSN和系统DSN的区别在于，用户DSN保存在注册表的HKEY_CURRENT_USER下，而系统DSN保存在HKEY_LOCAL_MACHINE下。 假定我们要连接的数据库是Access97的c:\test\auto.mdb(注意：用较新的ADO连接Access数据库效率更高，这里只是作为一个例子)，数据源的名称为CenterAuto，那么可以分为两个步骤： （1）注册DSN本身的信息: （2）登记数据源： 连接池 连接池是由容器（比如Tomcat）提供的，用来管理池中的连接对象。 连接池自动分配连接对象并对闲置的连接进行回收。 连接池中的连接对象是由数据源（DataSource）创建的。 连接池（Connection Pool）用来管理连接（Connection）对象。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql函数]]></title>
    <url>%2F2019%2F09%2F09%2Fmysql9%2F</url>
    <content type="text"><![CDATA[数学函数12345678910111213141516ABS(x) 返回x的绝对值BIN(x) 返回x的二进制（OCT返回八进制，HEX返回十六进制）CEILING(x) 返回大于x的最小整数值EXP(x) 返回值e（自然对数的底）的x次方 FLOOR(x) 返回小于x的最大整数值 GREATEST(x1,x2,...,xn) 返回集合中最大的值 LEAST(x1,x2,...,xn) 返回集合中最小的值LN(x) 返回x的自然对数 LOG(x,y) 返回x的以y为底的对数 MOD(x,y) 返回x/y的模（余数） PI() 返回pi的值（圆周率） RAND() 返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。ROUND(x,y) 返回参数x的四舍五入的有y位小数的值SIGN(x) 返回代表数字x的符号的值 SQRT(x) 返回一个数的平方根 TRUNCATE(x,y) 返回数字x截短为y位小数的结果 聚合函数(常用于GROUP BY从句的SELECT查询中)123456AVG(col) 返回指定列的平均值 COUNT(col) 返回指定列中非NULL值的个数 MIN(col) 返回指定列的最小值 MAX(col) 返回指定列的最大值 SUM(col) 返回指定列的所有值之和 GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果 字符串函数12345678910111213141516ASCII(char) 返回字符的ASCII码值 BIT_LENGTH(str) 返回字符串的比特长度 CONCAT(s1,s2...,sn) 将s1,s2...,sn连接成字符串 CONCAT_WS(sep,s1,s2...,sn) 将s1,s2...,sn连接成字符串，并用sep字符间隔 INSERT(str,x,y,instr) 将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果 FIND_IN_SET(str,list) 分析逗号分隔的list列表，如果发现str，返回str在list中的位置 LCASE(str)或LOWER(str) 返回将字符串str中所有字符改变为小写后的结果 LEFT(str,x) 返回字符串str中最左边的x个字符 LENGTH(s) 返回字符串str中的字符数 LTRIM(str) 从字符串str中切掉开头的空格 POSITION(substr,str) 返回子串substr在字符串str中第一次出现的位置 QUOTE(str) 用反斜杠转义str中的单引号 REPEAT(str,srchstr,rplcstr) 返回字符串str重复x次的结果 REVERSE(str) 返回颠倒字符串str的结果 RIGHT(str,x) 返回字符串str中最右边的x个字符 RTRIM(str) 返回字符串str尾部的空格 STRCMP(s1,s2) 比较字符串s1和s2 TRIM(str) 去除字符串首部和尾部的所有空格 UCASE(str)或UPPER(str) 返回将字符串str中所有字符转变为大写后的结果 日期和时间函数123CURDATE()或CURRENT_DATE() 返回当前的日期 CURTIME()或CURRENT_TIME() 返回当前的时间 DATE_ADD(date,INTERVAL int keyword) 返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化) 示例： 1SELECTDATE_ADD(CURRENT_DATE,INTERVAL 6 MONTH); 12DATE_FORMAT(date,fmt) 依照指定的fmt格式格式化日期date值 DATE_SUB(date,INTERVAL int keyword) 返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化) 示例： 1SELECTDATE_SUB(CURRENT_DATE,INTERVAL 6 MONTH); 123456789101112DAYOFWEEK(date) 返回date所代表的一星期中的第几天(1~7) DAYOFMONTH(date) 返回date是一个月的第几天(1~31) DAYOFYEAR(date) 返回date是一年的第几天(1~366) DAYNAME(date) 返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE); FROM_UNIXTIME(ts,fmt) 根据指定的fmt格式，格式化UNIX时间戳ts HOUR(time) 返回time的小时值(0~23) MINUTE(time) 返回time的分钟值(0~59) MONTH(date) 返回date的月份值(1~12) MONTHNAME(date) 返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE); NOW() 返回当前的日期和时间 QUARTER(date) 返回date在一年中的季度(1~4)，如SELECT QUARTER(CURRENT_DATE); WEEK(date) 返回日期date为一年中第几周(0~53) YEAR(date) 返回日期date的年份(1000~9999) 一些示例：获取当前系统时间 1234SELECT FROM_UNIXTIME(UNIX_TIMESTAMP()); SELECT EXTRACT(YEAR_MONTH FROM CURRENT_DATE);SELECT EXTRACT(DAY_SECOND FROM CURRENT_DATE); SELECT EXTRACT(HOUR_MINUTE FROM CURRENT_DATE); 返回两个日期值之间的差值(月数) 1SELECT PERIOD_DIFF(200302,199802); 在Mysql中计算年龄 1SELECT DATE_FORMAT(FROM_DAYS(TO_DAYS(NOW())-TO_DAYS(birthday)),&apos;%Y&apos;)+0 AS age FROM employee; 这样，如果Brithday是未来的年月日的话，计算结果为0。 下面的SQL语句计算员工的绝对年龄，即当Birthday是未来的日期时，将得到负值。 1SELECT DATE_FORMAT(NOW(), &apos;%Y&apos;)-DATE_FORMAT(birthday,&apos;%Y&apos;)-(DATE_FORMAT(NOW(),&apos;00-%m-%d&apos;) &lt;DATE_FORMAT(birthday, &apos;00-%m-%d&apos;))AS age from employee 加密函数12345678AES_ENCRYPT(str,key) 返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用AES_ENCRYPT的结果是一个二进制字符串，以BLOB类型存储 AES_DECRYPT(str,key) 返回用密钥key对字符串str利用高级加密标准算法解密后的结果 DECODE(str,key) 使用key作为密钥解密加密字符串str ENCRYPT(str,salt) 使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串str ENCODE(str,key) 使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储 MD5() 计算字符串str的MD5校验和 PASSWORD(str) 返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。 SHA() 计算字符串str的安全散列算法(SHA)校验和 示例： 123456SELECT ENCRYPT(&apos;root&apos;,&apos;salt&apos;); SELECT ENCODE(&apos;xufeng&apos;,&apos;key&apos;); SELECT DECODE(ENCODE(&apos;xufeng&apos;,&apos;key&apos;),&apos;key&apos;);#加解密放在一起 SELECT AES_ENCRYPT(&apos;root&apos;,&apos;key&apos;); SELECT AES_DECRYPT(AES_ENCRYPT(&apos;root&apos;,&apos;key&apos;),&apos;key&apos;); SELECT MD5(&apos;123456&apos;); SELECT SHA(&apos;123456&apos;); 控制流函数MySQL有4个函数是用来进行条件操作的，这些函数可以实现SQL的条件逻辑，允许开发者将一些应用程序业务逻辑转换到数据库后台。 MySQL控制流函数： 1234567CASE WHEN[test1] THEN [result1]...ELSE [default] END 如果testN是真，则返回resultN，否则返回default CASE [test] WHEN[val1] THEN [result]...ELSE [default]END 如果test和valN相等，则返回resultN，否则返回default IF(test,t,f) 如果test是真，返回t；否则返回f IFNULL(arg1,arg2) 如果arg1不是空，返回arg1，否则返回arg2 NULLIF(arg1,arg2) 如果arg1=arg2返回NULL；否则返回arg1 这些函数的第一个是IFNULL()，它有两个参数，并且对第一个参数进行判断。如果第一个参数不是NULL，函数就会向调用者返回第一个参数；如果是NULL,将返回第二个参数。 如： 1SELECT IFNULL(1,2), IFNULL(NULL,10),IFNULL(4*NULL,&apos;false&apos;); NULLIF()函数将会检验提供的两个参数是否相等，如果相等，则返回NULL，如果不相等，就返回第一个参数。 如： 1SELECT NULLIF(1,1),NULLIF(&apos;A&apos;,&apos;B&apos;),NULLIF(2+3,4+1); 和许多脚本语言提供的IF()函数一样，MySQL的IF()函数也可以建立一个简单的条件测试，这个函数有三个参数，第一个是要被判断的表达式，如果表达式为真，IF()将会返回第二个参数，如果为假，IF()将会返回第三个参数。 如： 1SELECTIF(1&lt;10,2,3),IF(56&gt;100,&apos;true&apos;,&apos;false&apos;); IF()函数在只有两种可能结果时才适合使用。然而，在现实世界中，我们可能发现在条件测试中会需要多个分支。在这种情况下，MySQL提供了CASE函数，它和PHP及Perl语言的switch-case条件例程一样。 CASE函数的格式有些复杂，通常如下所示： 1234567CASE [expression to be evaluated] WHEN [val 1] THEN [result 1] WHEN [val 2] THEN [result 2] WHEN [val 3] THEN [result 3] ...... WHEN [val n] THEN [result n] ELSE [default result] END 这里，第一个参数是要被判断的值或表达式，接下来的是一系列的WHEN-THEN块，每一块的第一个参数指定要比较的值，如果为真，就返回结果。所有的WHEN-THEN块将以ELSE块结束，当END结束了所有外部的CASE块时，如果前面的每一个块都不匹配就会返回ELSE块指定的默认结果。如果没有指定ELSE块，而且所有的WHEN-THEN比较都不是真，MySQL将会返回NULL。 CASE函数还有另外一种句法，有时使用起来非常方便，如下： 12345CASE WHEN [conditional test 1] THEN [result 1] WHEN [conditional test 2] THEN [result 2] ELSE [default result] END 这种条件下，返回的结果取决于相应的条件测试是否为真。 示例： 12345678910111213141516mysql SELECT CASE &apos;green&apos; WHEN &apos;red&apos; THEN &apos;stop&apos;WHEN &apos;green&apos; THEN &apos;go&apos; END;SELECT CASE 9 WHEN 1 THEN &apos;a&apos; WHEN 2 THEN &apos;b&apos; ELSE &apos;N/A&apos; END;SELECT CASE WHEN (2+2)=4 THEN &apos;OK&apos; WHEN(2+2)&lt;&gt;4 THEN &apos;not OK&apos; END ASSTATUS;SELECT Name,IF((IsActive = 1),&apos;已激活&apos;,&apos;未激活&apos;) AS RESULT FROMUserLoginInfo; SELECT fname,lname,(math+sci+lit) AS total,CASE WHEN (math+sci+lit) &lt; 50 THEN &apos;D&apos; WHEN (math+sci+lit) BETWEEN 50 AND 150 THEN &apos;C&apos;WHEN (math+sci+lit) BETWEEN 151 AND 250 THEN &apos;B&apos; ELSE &apos;A&apos;END AS grade FROM marks; SELECT IF(ENCRYPT(&apos;sue&apos;,&apos;ts&apos;)=upass,&apos;allow&apos;,&apos;deny&apos;) AS LoginResultFROM usersWHERE uname = &apos;sue&apos;;#一个登陆验证 格式化函数12345DATE_FORMAT(date,fmt) 依照字符串fmt格式化日期date值 FORMAT(x,y) 把x格式化为以逗号隔开的数字序列，y是结果的小数位数 INET_ATON(ip) 返回IP地址的数字表示 INET_NTOA(num) 返回数字所代表的IP地址 TIME_FORMAT(time,fmt) 依照字符串fmt格式化时间time值 其中最简单的是FORMAT()函数，它可以把大的数值格式化为以逗号间隔的易读的序列。 示例： 1234567SELECT FORMAT(34234.34323432,3); SELECT DATE_FORMAT(NOW(),&apos;%W,%D %M %Y %r&apos;);SELECT DATE_FORMAT(NOW(),&apos;%Y-%m-%d&apos;); SELECT DATE_FORMAT(19990330,&apos;%Y-%m-%d&apos;); SELECT DATE_FORMAT(NOW(),&apos;%h:%i %p&apos;); SELECT INET_ATON(&apos;10.122.89.47&apos;);SELECT INET_NTOA(175790383); 类型转化函数为了进行数据类型转化，MySQL提供了CAST()函数，它可以把一个值转化为指定的数据类型。类型有： BINARY,CHAR,DATE,TIME,DATETIME,SIGNED,UNSIGNED 示例： 12SELECT CAST(NOW() AS SIGNED INTEGER),CURDATE()+0; SELECT &apos;f&apos;=BINARY &apos;F&apos;,&apos;f&apos;=CAST(&apos;F&apos; AS BINARY); 系统信息函数123456DATABASE() 返回当前数据库名 BENCHMARK(count,expr) 将表达式expr重复运行count次 CONNECTION_ID() 返回当前客户的连接ID FOUND_ROWS() 返回最后一个SELECT查询进行检索的总行数 USER()或SYSTEM_USER() 返回当前登陆用户名 VERSION() 返回MySQL服务器的版本 示例： 123SELECT DATABASE(),VERSION(),USER();SELECTBENCHMARK(9999999,LOG(RAND()*PI()));#该例中,MySQL计算LOG(RAND()*PI())表达式9999999次。]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019所看记录片]]></title>
    <url>%2F2019%2F09%2F09%2Fjilu%2F</url>
    <content type="text"></content>
      <categories>
        <category>Tv</category>
      </categories>
      <tags>
        <tag>纪录片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是OOM，为什么会OOM及一些解决方法]]></title>
    <url>%2F2019%2F09%2F09%2Foom%2F</url>
    <content type="text"><![CDATA[什么是OOM？ OOM,全称”Out Of Memory”,翻译成中文就是“内存用完了”,来源java.lang.OutOfMemoryError。看下关于的官方说明： Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector. 意思就是说，当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error（注：非exception，因为这个问题已经严重到不足以被应用处理） 为什么会OOM(没有内存了呢)？JVM内存过小、程序不严密，产生了过多的垃圾。 分配的少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。 应用用的太多，并且用完没释放，浪费了。此时就会造成内存泄露或者内存溢出。 内存泄露申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。 内存溢出申请的内存超出了JVM能提供的内存大小，此时称之为溢出。 在之前没有垃圾自动回收的日子里，比如C语言和C++语言，我们必须亲自负责内存的申请与释放操作，如果申请了内存，用完后又忘记了释放，比如C++中的new了但是没有delete，那么就可能造成内存泄露。偶尔的内存泄露可能不会造成问题，而大量的内存泄露可能会导致内存溢出。 而在Java语言中，由于存在了垃圾自动回收机制，所以，我们一般不用去主动释放不用的对象所占的内存，也就是理论上来说，是不会存在“内存泄露”的。但是，如果编码不当，比如，将某个对象的引用放到了全局的Map中，虽然方法结束了，但是由于垃圾回收器会根据对象的引用情况来回收内存，导致该对象不能被及时的回收。如果该种情况出现次数多了，就会导致内存溢出，比如系统中经常使用的缓存机制。Java中的内存泄露，不同于C++中的忘了delete，往往是逻辑上的原因泄露。 在解决java内存溢出问题之前，需要对jvm（java虚拟机）的内存管理有一定的认识 JVM管理的内存大致包括三种不同类型的内存区域（大概介绍）：Permanent Generation space（永久保存区域）主要存放Class（类）和Meta的信息，Class第一次被Load的时候被放入PermGen space区域，Class需要存储的内容主要包括方法和静态属性。 Heap space(堆区域)用来存放Class的实例（即对象），对象需要存储的内容主要是非静态属性。每次用new创建一个对象实例后，对象实例存储在堆区域中，这部分空间也被jvm的垃圾回收机制管理。 Java Stacks(Java栈）跟大多数编程语言包括汇编语言的栈功能相似，主要基本类型变量以及方法的输入输出参数。Java程序的每个线程中都有一个独立的堆栈。 容易发生内存溢出问题的内存空间包括：Permanent Generation space和Heap space。 JVM内存模型：按照JVM规范 JAVA虚拟机在运行时会管理以下的内存区域(详细介绍) 程序计数器 当前线程执行的字节码的行号指示器，线程私有 JAVA虚拟机栈 Java方法执行的内存模型，每个Java方法的执行对应着一个栈帧的进栈和出栈的操作 本地方法栈 类似“ JAVA虚拟机栈 ”，但是为native方法的运行提供内存环境 JAVA堆 对象内存分配的地方，内存垃圾回收的主要区域，所有线程共享。可分为新生代，老生代 方法区 用于存储已经被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Hotspot中的“永久代” 运行时常量池 方法区的一部分，存储常量信息，如各种字面量、符号引用等 直接内存 并不是JVM运行时数据区的一部分， 可直接访问的内存， 比如NIO会用到这部分 按照JVM规范，除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM。 导致OutOfMemoryError异常的常见原因有以下几种 内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 代码中存在死循环或循环产生过多重复的对象实体； 使用的第三方软件中的BUG； 启动参数内存值设定的过小； 此错误常见的错误提示 java.lang.OutOfMemoryError: PermGen space java.lang.OutOfMemoryError: Java heap space weblogic:Root cause of ServletException java.lang.OutOfMemoryError resin:java.lang.OutOfMemoryError java:java.lang.OutOfMemoryError java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。 OOM分析解决java.lang.OutOfMemoryError的方法有如下几种： 增加jvm的内存大小方法有： 在执行某个class文件时候，可以使用 java -Xmx256M aa.class ​ 来设置运行aa.class时jvm所允许占用的最大内存为256M。 对tomcat容器，可以在启动时对jvm设置内存限度。对tomcat，可以在catalina.bat中添加： 12345set CATALINA_OPTS=-Xms128M -Xmx256M set JAVA_OPTS=-Xms128M -Xmx256M 或者把%CATALINA_OPTS%和%JAVA_OPTS% 代替为-Xms128M -Xmx256M 对resin容器，同样可以在启动时对jvm设置内存限度。在bin文件夹下创建一个startup.bat文件， 内容如下：@echo off call &quot;httpd.exe&quot; &quot;-Xms128M&quot; &quot;-Xmx256M&quot; :end 其中”-Xms128M”为最小内存，”-Xmx256M”为最大内存。 优化程序，释放垃圾导致java.lang.OutOfMemoryError的根本原因是程序不健壮。因此，从根本上解决Java内存溢出的唯一方法就是修改程序，及时地释放没用的对象，释放内存空间。 遇到该错误的时候要仔细检查程序，遇多一次这种问题之后，以后写程序就会小心多了。 Java代码导致OutOfMemoryError错误的解决需要重点排查以下几点： 检查代码中是否有死循环或递归调用。 检查是否有大循环重复产生新对象实体。 检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。 检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。 tomcat中java.lang.OutOfMemoryError: PermGen space异常处理PermGen space的全称是Permanent Generation space 是指内存的永久保存区域,这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中, 它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很多CLASS的话,就很可能出现PermGen space错误, 这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下，系统的代码非常多或引用的第三方包非常多、或代码中使用了大量的常量、或通过intern注入常量、或者通过动态代码加载等方法，导致常量池的膨胀。虽然JDK 1.5以后可以通过设置对永久带进行回收，但是我们希望的是这个地方是不做GC的，它够用就行，所以一般情况下今年少做类似的操作. 解决方法： 手动设置MaxPermSize大小，修改TOMCAT_HOME/bin/catalina.sh在 echo &quot;Using CATALINA_BASE: $CATALINA_BASE&quot; 上面加入以下行： JAVA_OPTS=”-server -XX:PermSize=64M -XX:MaxPermSize=128m 建议：将相同的第三方jar文件移置到tomcat/shared/lib目录下，这样可以达到减少jar 文档重复占用内存的目的。 weblogic中java.lang.OutOfMemoryError异常处理错误提示： Root cause of ervletException java.lang.OutOfMemoryError 解决办法：调整bea/weblogic/common中CommEnv中参数 :sun if “%PRODUCTION_MODE%” == “true” goto sun_prod_mode set JAVA_VM=-client set MEM_ARGS=-Xms256m -Xmx512m -XX:MaxPermSize=256m set JAVA_OPTIONS=%JAVA_OPTIONS% -Xverify:none goto continue :sun_prod_mode set JAVA_VM=-server set MEM_ARGS=-Xms256m -Xmx512m -XX:MaxPermSize=256m goto continue Resin下java.lang.OutOfMemoryError异常处理出现这个错误，一般是因为JVM物理内存过小。默认的Java虚拟机最大内存仅为64兆，这在开发调试过程中可能没有问题，但在实际的应用环境中是远远不能满足需要的，除非你的应用非常小，也没什么访问量。否则你可能会发现程序运行一段时间后包java.lang.OutOfMemoryError的错误。因此我们需要提升resin可用的虚拟机内存的大小。 解决方法： 修改/usr/local/resin/bin/httpd.sh中的args选项 添加参数-Xms（初始内存）和-Xmx（最大能够使用内存大小）可以用来限制JVM的物理内存使用量。例如： args=”-Xms128m -Xmx256m” 设置后，JVM初始物理内存是128m，最大能使用物理内存为256m。这两个值应该由系统管理员根据服务器的实际情况进行设置。 java.lang.OutOfMemoryError: ......java heap space..... 也就是当你看到heap相关的时候就肯定是堆栈溢出了，此时如果代码没有问题的情况下，适当调整-Xmx和-Xms是可以避免的，不过一定是代码没有问题的前提，为什么会溢出呢，要么代码有问题，要么访问量太多并且每个访问的时间太长或者数据太多，导致数据释放不掉，因为垃圾回收器是要找到那些是垃圾才能回收，这里它不会认为这些东西是垃圾，自然不会去回收了；主意这个溢出之前，可能系统会提前先报错关键字为： java.lang.OutOfMemoryError:GC over head limit exceeded 这种情况是当系统处于高频的GC状态(即程序在垃圾回收上花费了98%的时间，却收集不回2%的空间，通常这样的异常伴随着CPU的冲高)，而且回收的效果依然不佳的情况，就会开始报这个错误，这种情况一般是产生了很多不可以被释放的对象，有可能是引用使用不当导致，或申请大对象导致，但是java heap space的内存溢出有可能提前不会报这个错误，也就是可能就内存不够导致，而不是高频GC. 第三类内存溢出在使用ByteBuffer中的allocateDirect()的时候会用到，很多javaNIO的框架中被封装为其他的方法 溢出关键字： java.lang.OutOfMemoryError: Direct buffer memory 如果你在直接或间接使用了ByteBuffer中的allocateDirect方法的时候，而不做clear的时候就会出现类似的问题，常规的引用程序IO输出存在一个内核态与用户态的转换过程，也就是对应直接内存与非直接内存，如果常规的应用程序你要将一个文件的内容输出到客户端需要通过OS的直接内存转换拷贝到程序的非直接内存（也就是heap中），然后再输出到直接内存由操作系统发送出去，而直接内存就是由OS和应用程序共同管理的，而非直接内存可以直接由应用程序自己控制的内存，jvm垃圾回收不会回收掉直接内存这部分的内存，所以要注意了哦。 如果经常有类似的操作，可以考虑设置参数：-XX:MaxDirectMemorySize java.lang.StackOverflowError这个参数直接说明一个内容，就是-Xss太小了，我们申请很多局部调用的栈针等内容是存放在用户当前所持有的线程中的，线程在jdk 1.4以前默认是256K，1.5以后是1M，如果报这个错，只能说明-Xss设置得太小，当然有些厂商的JVM不是这个参数，本文仅仅针对Hotspot VM而已；不过在有必要的情况下可以对系统做一些优化，使得-Xss的值是可用的。 java.lang.OutOfMemoryError: unable to create new native thread这种怪事是因为JVM已经被系统分配了大量的内存(比如1.5G)，并且它至少要占用可用内存的一半。有人发现，在线程个数很多的情况下，你分配给JVM的内存越多，那么，上述错误发生的可能性就越大。 那么是什么原因造成这种问题呢？ 每一个32位的进程最多可以使用2G的可用内存，因为另外2G被操作系统保留。这里假设使用1.5G给JVM，那么还余下500M可用内存。 这500M内存中的一部分必须用于系统dll的加载，那么真正剩下的也许只有400M，现在关键的地方出现了:当你使用Java创建一个线程，在JVM的内存里也会创建一个Thread对象，但是同时也会在操作系统里创建一个真正的物理线程(参考JVM规范)，操作系统会在余下的400兆内存里创建这个物理线程，而不是在JVM的1500M的内存堆里创建。在jdk1.4里头，默认的栈大小是256KB，但是在jdk1.5里头，默认的栈大小为1M每线程，因此，在余下400M的可用内存里边我们最多也只能创建400个可用线程。 1(MaxProcessMemory - JVMMemory - ReservedOsMemory) / (ThreadStackSize) = Number of threads MaxProcessMemory 指的是一个进程的最大内存 JVMMemory JVM内存 ReservedOsMemory 保留的操作系统内存 ThreadStackSize 线程栈的大小 这样结论就出来了，系统可创建线程数量与分配给JVM内存大小成反比,要想创建更多的线程，你必须减少分配给JVM的最大内存。还有一种做法是让JVM宿主在你的JNI代码里边。 给出一个有关能够创建线程的最大个数的估算公式： 对于jdk1.5而言，假设操作系统保留120M内存： 1.5GB JVM: (2GB-1.5Gb-120MB)/(1MB) = ~380 threads 1.0GB JVM: (2GB-1.0Gb-120MB)/(1MB) = ~880 threads 对于栈大小为256KB的jdk1.4而言， 1.5GB allocated to JVM: ~1520 threads 1.0GB allocated to JVM: ~3520 threads 对于这个异常我们首先需要判断下，发生内存溢出时进程中: 到底都有什么样的线程，这些线程是否是应该存在的，是否可以通过优化来降低线程数； 另外一方面默认情况下java为每个线程分配的栈内存大小是1M，通常情况下，这1M的栈内存空间是足足够用了，因为在通常在栈上存放的只是基础类型的数据或者对象的引用，这些东西都不会占据太大的内存. 我们可以通过调整jvm参数，降低为每个线程分配的栈内存大小来解决问题，例如在jvm参数中添加-Xss128k将线程栈内存大小设置为128k。 查看是否操作系统限制了可创建线程数量 执行ulimit -u 可以查看当前用户可创建线程量，如果不满足要求，可以通过修改配置文件调整其大小：相关配置文件在etc/security/limit.d/XX-nproc.conf中. java.lang.OutOfMemoryError: request {} byte for {}out of swap这类错误一般是由于地址空间不够而导致。 要dump堆的内存镜像，可以采用如下两种方式 设置JVM参数-XX:+HeapDumpOnOutOfMemoryError，设定当发生OOM时自动dump出堆信息。不过该方法需要JDK5以上版本。 使用JDK自带的jmap命令.”jmap -dump:format=b,file=heap.bin”其中pid可以通过jps获取。 dump堆内存信息后，需要对dump出的文件进行分析，从而找到OOM的原因。常用的工具有： mat: eclipse memory analyzer, 基于eclipse RCP的内存分析工具。 详细信息参见: 推荐使用 jhat：JDK自带的java heap analyze tool，可以将堆中的对象以html的形式显示出来，包括对象的数量，大小等等，并支持对象查询语言OQL，分析相关的应用后，可以通过来 访问 分析结果。不推荐使用，因为在实际的排查过程中，一般是先在生产环境 dump出文件来，然后拉到自己的开发机器上分析，所以，不如采用高级的分析工具比如前面的mat来的高效。 这个链接中提供了一个采用mat分析的例子 。 注意：因为JVM规范没有对dump出的文件的格式进行定义，所以不同的虚拟机产生的dump文件并不是一样的。在分析时，需要针对不同的虚拟机的输出采用不同的分析工具（当然,有的工具可以兼容多个虚拟机的格式）。IBM HeapAnalyzer也是分析heap的一个常用的工具. 利用gc.log进行OOM监控针对JVM的监听，JDK默认提供了如jconsole、jvisualVM工具都非常好用，本节介绍利用打开gc的日志功能，进行OOM的监控。 首先需要对JAVA程序添加执行参数： -XX:+PrintGC 输出GC日志 -XX:+PrintGCDetails 输出GC的详细日志 -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 -Xloggc:../logs/gc.log 日志文件的输出路径 示例参数配置：-xmx100M -XX:+PrintGCDetails ``-Xloggc:../logs/gc.log -XX:+PrintGCDetails -Xmx设置堆内存 输出日志的详细介绍： 总共分配了100M堆内存空间，老年代+年轻代=堆 就堆内存，此次GC共回收了79186-75828=3356=3.279M内存，能回收空间已经非常少了。 同时从PSYoungGen回收10612-7254=3558=3.474M内存 3558-3356=202K，说明有202K的空间在年轻代释放，却传入年老代继续占用 下一条日志输出： 2018-01-03T10:53:52.281+0800: 11.052: [Full GC (Allocation Failure) [PSYoungGen: 7254K-&gt;7254K(24064K)] [ParOldGen: 68574K-&gt;68486K(68608K)] 75828K-&gt;75740K(92672K), [Metaspace: 3357K-&gt;3357K(1056768K)], 0.6010057 secs] [Times: user=2.08 sys=0.00, real=0.60 secs] 0.6010057 se 68574-68486=88K 75828-75740=88K 此次FullGC 只能释放老年代的88K空间 对于分析gc.log，提供一种图形化工具辅助分析gcviewer-1.3.6 参考链接 什么是OOM，为什么会OOM及一些解决方法 线上java.lang.OutOfMemoryError问题定位三板斧 java中的dump是什么？ java 获取内存dump 的几种方式 Java 内存溢出（java.lang.OutOfMemoryError）的常见情况和处理方式总结 Java 内存溢出（java.lang.OutOfMemoryError）常见情况和总结 几种OOM异常分析]]></content>
      <categories>
        <category>Exception</category>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[影视观看单]]></title>
    <url>%2F2019%2F09%2F09%2Ftv1%2F</url>
    <content type="text"><![CDATA[影视观看单 影视名称 观看时间 霸王别姬 肖申克的救赎 辛德勒的名单 美丽人生 茶馆 阿甘正传 灿烂人生 这个杀手不太冷 背靠背，脸对脸 泰坦尼克号 借东风 放牛班的春天 机器人总动员 城市之光 盗梦空间 教父1 大闹天宫 群英会京剧 贵妃醉酒 丝路花雨 梅兰芳的舞台艺术(下) 忠犬八公的故事 海豚湾 永远的车神 生活多美好 你逃我也逃 遥望南方的童年 疯狂动物城 楚门的世界 教父2 大话西游之大圣娶亲 七武士 切腹 花为媒 梅兰芳的舞台艺术(上) 地球之盐 星际穿越 海上钢琴师 摩登时代 乱世佳人 家园 小鞋子 钢琴家 寻子遇仙记 微观世界 迁徙的鸟 无人知晓 无间道 北极故事 末代皇帝]]></content>
      <categories>
        <category>Tv</category>
      </categories>
      <tags>
        <tag>影视</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书单列表(自我阅读计划)]]></title>
    <url>%2F2019%2F09%2F09%2Fbook1%2F</url>
    <content type="text"><![CDATA[书单列表 名称 阅读开始/结束时间 《如何阅读一本书》-莫提莫·J·艾德勒,查尔斯·范多伦 《平凡的世界》-路遥 《万历十五年》-黄仁宇 《三体》-刘慈轩 《人类简史:从动物到上帝》-尤瓦尔·赫拉利 《白鹿原》-陈忠实 《叫魂:1768年中国妖术大恐慌》-孔飞力 《国富论》-亚当·斯密 《解忧杂货铺》-东野圭吾 《挪威的森林》-村上春树 《我们仨》-杨绛 《瓦尔登湖》-梭罗 《月亮与六便士》-毛姆 《海边的卡夫卡》-村上春树 《白夜行》-东野圭吾 《天龙八部》-金庸 《乡土中国》-费孝通 《追风筝的人》-卡勒德·胡塞尼 《资本论》-马克思 《菊与刀》-鲁思·本尼迪克特 《时间简史(插图本)》-史蒂芬·霍金 《围城》-钱钟书 《大数据时代:生活,工作与思维的大变革》-麦尔·舍恩伯格,库克耶 《霍乱时期的爱情》-加西亚·马尔克斯 《东方快车谋杀案》-阿加莎·克里斯蒂 《雪国》-川端康成 《数学之美》-吴军 《中国哲学简史》-冯友兰 《国史大纲》-钱穆 《西方哲学史》-罗素 《百年孤独》-加西亚·马尔克斯 《乌合之众》-古斯塔夫·勒庞 《射雕英雄传》-金庸 《理想国》-柏拉图 《心理学与生活》-格里格,津巴多 《不能承受的生命之轻》-米兰·昆德拉 《明朝那些事儿》-当年明月 《无人生还》-阿加莎·克里斯蒂 《春秋左传注》-杨伯峻 《长恨歌》-王安忆 《呼兰河传》-萧红 《高效能人士的七个习惯》-史蒂芬·柯维 《了不起的盖茨比》-FS菲兹杰拉德 《思考，快与慢》-丹尼尔·卡尼曼 《小王子》-安东尼·德·圣·埃克苏佩里 《苏菲的世界》-乔斯坦·贾德 《这里》-理查德·麦奎尔 《鲍勃·迪伦诗歌集》-鲍勃·迪伦 《一个广告人的自白》-大卫·奥格威 《BBC科普三部曲》-保尔·罗斯等 《人类的群星闪耀时》-史蒂芬·茨威格 《漫长的告别》-雷蒙德·钱德勒 《非暴力沟通》-马歇尔·卢森堡 《金字塔原理》-明托 《终身成长》-卡罗尔·德韦克 《房思琪的初恋乐园》-林奕含]]></content>
      <categories>
        <category>Books</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行业书籍列表]]></title>
    <url>%2F2019%2F09%2F09%2Fbook2%2F</url>
    <content type="text"><![CDATA[行业书籍列表 书籍名称 阅读开始/完成时间 《编码：隐匿在计算机软硬件背后的语言》 《深入理解计算机系统》 《图灵的秘密》 《算法》–Sedgewick 和 Wayne 《C程序设计语言》– K&amp;R 《30天自制操作系统》 《增长黑客》 –范冰 《万物:文明》–延斯哈德 《潜意识》–列纳德蒙 洛迪诺 《创新者》 –沃尔特 艾萨克森 《浪潮之巅》–吴军 《数学之美》–吴军 《长尾理论》 –克里斯 安德森 《黑客》 –Steven Levy 《启示录》–Marty Cagan 《重新定义公司》 –埃里克 施密特 《Java编程思想》–Bruce Eckel 《Effective Java》 《Head First Design》 《重构：改善既有代码的设计》–Martin Flower 《敏捷软件开发， 原则，模式，实践》 《Java并发编程实战》 《深入理解Java 虚拟机》 《J2EE development without EJB》 《TCP/IP详解》 《编译原理》–龙书 《编程语言实现模式》 《编码的奥秘》 《重构-改善既有代码的设计》 《敏捷软件开发 原则、模式与实践》]]></content>
      <categories>
        <category>Books</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3常用属性]]></title>
    <url>%2F2019%2F09%2F08%2Fcss2%2F</url>
    <content type="text"><![CDATA[Css3设置边框属性【box-shadow属性】 作用: 可以设置一个或多个下拉阴影的框。 语法: box-shadow:h-shadow v-shadow blur spread color 语法描述: 值 描述 h-shadow 必需的。水平阴影的位置。允许负值 v-shadow 必需的。垂直阴影的位置。 先许负值 blur 可选。模糊距离 spread 可选。阴影的大小 color 可选。阴影的颜色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;style&gt; div&#123; width: 300px; height: 100px; background-color: yellow; box-shadow:20px 20px 5px #888888; &#125; input&#123; padding: 4px; border: solid 1px #E5E5E5; font-family:'sans-serif'; width: 200px; background: #FFFFFF; box-shadow:10px 10px 5px rgba(0,0,0,0.5); &#125; input:hover,input:focus&#123; border-color: #c9c58a; &#125;label&#123; margin-left: 10px; color: #999999;&#125; .submit input&#123; width: auto; padding: 9px 15px; background: #617798; border: 0; font-size: 14px; color: #FFFFFF; &#125; &lt;/style&gt;&lt;body&gt;&lt;h3&gt;box-shadow&lt;/h3&gt;&lt;div&gt;&lt;/div&gt;&lt;h3&gt;登录表单&lt;/h3&gt;&lt;form&gt; &lt;p class="name"&gt; &lt;label for="name"&gt; 姓名 &lt;/label&gt; &lt;input type="text" name="name" id="name"&gt; &lt;/p&gt; &lt;p class="email"&gt; &lt;label for="email"&gt; 邮箱 &lt;/label&gt; &lt;input type="text" name="email" id="email"&gt; &lt;/p&gt; &lt;p class="submit"&gt; &lt;input type="submit" value="提交"/&gt; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt; 【border-radius属性】 作用: 这个属性允许你为元素添加圆角边框。 语法: border-radius:none|&lt;length&gt;{1,4}[/&lt;length&gt;{1,4}] 语法描述:length 定义弯道的形状, 由浮点数和单位标识符组成的长度值, 不可为负值 注意:每个半径的四个值的顺序是：左上角，右上角，右下角，左下角 123456789101112131415161718192021222324252627282930313233343536373839404142 &lt;style&gt; div &#123; width: 100px; height: 50px; background: #b3d4fc; text-align: center; line-height: 50px; &#125; .bd1 &#123; border-radius: 100px 0 100px 0; &#125; .bd2 &#123; border-radius: 5px; &#125; .bd3 &#123; border-radius: 10px 15px 10px 5px; &#125; .bd4 &#123; border-radius: 15px 5px; &#125; .bd5 &#123; border-radius: 15px 10px 5px; &#125; &lt;/style&gt;&lt;body&gt;&lt;h3&gt;border-radius&lt;/h3&gt;&lt;span&gt;左上100px 右下100px 右上 0px 左下0px&lt;/span&gt;&lt;div class="bd1"&gt;&lt;/div&gt;&lt;span&gt;四角都为5px&lt;/span&gt;&lt;div class="bd2"&gt;&lt;/div&gt;&lt;span&gt;左上10px 右下10px 右上 15px 左下5px&lt;/span&gt;&lt;div class="bd3"&gt;&lt;/div&gt;&lt;span&gt;左上右下15px 右上左下5px&lt;/span&gt;&lt;div class="bd4"&gt;&lt;/div&gt;&lt;span&gt;左上15px 右下5px 右上左下10px&lt;/span&gt;&lt;div class="bd5"&gt;&lt;/div&gt;&lt;/body&gt; 【border-image属性】 作用: 这个属性允许你为元素添加边框背景。 语法: border-image:source slice width outset repeat 语法插述: 值 描述 source 定义边框的背景图片源, 即图像URL slice 定义如何裁切背景图像 width 定义边框背景图像的显示大小 (即边框显示大小) outset 定义边框背景图像的偏移位置(不支持) repeat 定义边框背景图片的重复性,重复(repeat)、拉伸(stretch)或平铺(round) 12345678910111213141516171819 &lt;style&gt; div&#123; width:250px; border: 15px solid transparent; padding: 10px 20px; &#125; #round&#123; border-image: url("kk.jpeg") 200 round; &#125; #stretch&#123; border-image: url("kk.jpeg") 200 stretch; &#125; &lt;/style&gt;&lt;body&gt;&lt;h3&gt;border-image&lt;/h3&gt;&lt;div id="round"&gt;使用round来填充容器&lt;/div&gt;&lt;br&gt;&lt;div id="stretch"&gt;使用stretch来填充容器&lt;/div&gt;&lt;/body&gt; Css3设置背景属性 【background-size属性】 作用:用来定义背景图像的大小 语法: background-size:length|percentage|cover|contain 语法描述: 值 描述 length 设五背景图片高度和宽度。第一个值设置宽度, 第二个值设置的高度 percentage 将计算相对于背景定位区城的百分比。 第一个值设置宽度, 第二个值设置的高度 cover 此时会保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小(以y轴为主) contain 此时会保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小(以x轴为主) 【background-origin属性】 作用:用来定义背景图像的定位区域 语法:background-origin:padding-box|border-box|content-box 语法描述: padding-box 背景图像填充框的相对位置 border-box 背景图像边界框的相对位置 content-box 背景图像的相对位置的内容框 【background-clip属性】 作用:用来定义背景图像的裁剪区域 语法: backgroud-clip:padding-box|border-box|content-box 语法描述: border-box 默认值,从边框区域向外裁剪背景 padding-box 从补白区域向外裁剪背景 content-box 从内容区域向外裁剪背景 CSS3文本相关 【CSS3 @font-face规则】 以前CSS的版本, 网页设计师不得不使用用户计算机上已经安装的字体。 使用CSS3, 网页设计师可以使用他/她喜欢的任何字体。 当你发现您要使用的字体文件时, 只需简单的将字体文件包含在网站中, 它会自动下载给需要的用户 我们要做的就是在@font-face规则中完成对字体的描述。 可参考链接 12345@font-face&#123;font-family: myFirstFont;src:url(sansation_bold.ttf); font-weight:bold; &#125; font-family 必需。规定字体的名称 src 必需。定义字体文件的 URL font-style 可选。定义字体的样式。默认是”normal” font-weight 可选。定义字体的粗细。默认是”normal” 提示:免费字体下载 1234567891011121314&lt;style&gt; @font-face &#123; font-family: 'Alex'; src: url("KK.ttf") format('truetype'); font-weight: bold; font-style: italic; &#125; .font-face-display&#123; font:66px Alex &#125; &lt;/style&gt;&lt;body&gt;&lt;div class="font-face-display"&gt;Take me to your heart&lt;/div&gt;&lt;/body&gt; 【目前主要的几种网络字体】 TrueType(.ttf)格式: 此字体是Windows和Mac的最常见的字体, 是一种RAW格式, 因此他不为网站优化, 支持这种手体的浏览器有[lE9+,Firefox3.5+,Chrome4+, Safari3+,Opera10+,iOS MobileSafari4.2+] OpenType(.otf)格式: .otf字体被认为是一种原始的字体格式, 其内置在TrueType的基础上, 所以也提供了更多的功能,支持这种手体的浏览器有[Firefox3.5+,Chrome4.0+,Safari3.1+,Opera10.0+, iOS MobileSafari4. 2+] Web Open Font Format(.woff)格式: woff字体是Web手体中最佳格式, 他是一个开放的TrueType/0penType的压缩版本。支持这种字体的浏览器有[lE9+, Firefox3.5+, Chrome6+, Safari3. 6+,0pera11.1+] Embedded Open Type(.eot)格式:.eot字体是lE专用字体, 可以从TrueType创建此格式字体,支持这种字体的浏览器有[lE4+] 【word-wrap属性】 作用: 用来定义文本超过指定容器的边界时是否断开转行 语法: word-wrap:normal|break-word 语法描述: normal 只在先许的断字点换行 (浏览器保持默认处理) break-word 在长单词或 URL地址内部进行换行 【text-overflow属性】 作用: 用来定义省略文本的处理方式 语法: text-overflow:clip|ellipisis|string 语法描述: clip 修剪文本 ellipsis 显示省略持号来代表被修剪的文本 string 使用给定的字符事来代表被修剪的文本(当前浏览器不支持) 注意: 实际上,text-overflow属性仅是内容注解, 表明当文本溢出时是否显示省略标记, 并不具备样式定义的特性。要实现溢出时产生省略号的效果, 我们应该再定义两个样式:强制文本一行内显示(white-space:nowrap)和溢出内容为隐藏(overflow:hidden) 颜色相关 【RGBA颜色值】 作用:它在红、绿、蓝三原色通道的基础上增加了不透明度参数。 语法:RGBA(R,G,B,A) 语法插述: 取值 描述 R 红色值,0-255 G 绿色值,0-255 B 蓝色值,0-255 A 透明度,0-1之间 【HSL颜色值】 作用: 它通过对色调(H)、 他和度(S)和亮度(L) 3个颜色通道的变化以及它们相互之间的叠加来获得各种颜色 。 语法: HSL(&lt;Hue&gt;,&lt;Saturation&gt;,&lt;Lightness&gt;) 语法描述: Hue 0(或360)表示红色, 120表示绿色, 240表示蓝色,也可取其他数值来指定颜色。取值为: 0-360 Saturation 取值为: 0.0% -100.0%, 0%表示灰色,100%颜色最艳。 Lightness 取值为: 0.0%-100.0%,0%最暗, 显示为黑色,100%最亮, 显示为白色 【HSLA颜色值】 作用: 它通过对色调(H)、 他和度(S)和亮度(L) 3个要素基础上增加了不透明度参数。 语法: HSL(&lt;Hue&gt;,&lt;Saturation&gt;,&lt;Lightness&gt;,&lt;alpha&gt;) 语法描述: Hue 0(或360)表示红色, 120表示绿色, 240表示蓝色,也可取其他数值来指定颜色。取值为: 0-360 Saturation 取值为: 0.0% -100.0%, 0%表示灰色,100%颜色最艳。 Lightness 取值为: 0.0%-100.0%,0%最暗, 显示为黑色,100%最亮, 显示为白色 alpha 取值0~1之间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;style&gt; li &#123; list-style-type: none; &#125; li.rgba1 &#123; background: rgba(255, 255, 0, 1); &#125; li.rgba2 &#123; background: rgba(255, 255, 0, 0.8); &#125; li.rgba3 &#123; background: rgba(255, 255, 0, 0.6); &#125; li.rgba4 &#123; background: rgba(255, 255, 0, 0.4); &#125; li.rgba5 &#123; background: rgba(255, 255, 0, 0.2); &#125; li.rgba6 &#123; background: rgba(255, 255, 0, 0); &#125; /*HSL*/ div.hsl1 &#123; background: hsl(320, 100%, 50%); height: 20px; &#125; div.hsl2 &#123; background: hsl(320, 50%, 50%); height: 20px; &#125; div.hsl3 &#123; background: hsl(320, 100%, 75%); height: 20px; &#125; div.hsl4 &#123; background: hsl(202, 100%, 50%); height: 20px; &#125; div.hsl5 &#123; background: hsl(202, 50%, 50%); height: 20px; &#125; div.hsl6 &#123; background: hsl(202, 100%, 75%); height: 20px; &#125; /*HSLA*/ div.hsla1 &#123; background: hsla(320, 100%, 50%, 0.2); height: 20px; &#125; div.hsla2 &#123; background: hsla(320, 50%, 50%, 0.4); height: 20px; &#125; div.hsla3 &#123; background: hsla(320, 100%, 75%, 0.6); height: 20px; &#125; div.hsla4 &#123; background: hsla(202, 100%, 50%, 0.8); height: 20px; &#125; div.hsla5 &#123; background: hsla(202, 50%, 50%, 1.0); height: 20px; &#125; div.hsla6 &#123; background: hsla(202, 100%, 75%, 0); height: 20px; &#125; &lt;/style&gt;&lt;body&gt;&lt;h3&gt;Css3的RGBA效果&lt;/h3&gt;&lt;ul&gt; &lt;li class="rgba1"&gt;1&lt;/li&gt; &lt;li class="rgba2"&gt;0.8&lt;/li&gt; &lt;li class="rgba3"&gt;0.6&lt;/li&gt; &lt;li class="rgba4"&gt;0.4&lt;/li&gt; &lt;li class="rgba5"&gt;0.2&lt;/li&gt; &lt;li class="rgba6"&gt;0&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Css3的HSL效果&lt;/h3&gt;&lt;div class="hsl1"&gt;&lt;/div&gt;&lt;div class="hsl2"&gt;&lt;/div&gt;&lt;div class="hsl3"&gt;&lt;/div&gt;&lt;div class="hsl4"&gt;&lt;/div&gt;&lt;div class="hsl5"&gt;&lt;/div&gt;&lt;div class="hsl6"&gt;&lt;/div&gt;&lt;h3&gt;Css3的HSLA效果&lt;/h3&gt;&lt;div class="hsla1"&gt;&lt;/div&gt;&lt;div class="hsla2"&gt;&lt;/div&gt;&lt;div class="hsla3"&gt;&lt;/div&gt;&lt;div class="hsla4"&gt;&lt;/div&gt;&lt;div class="hsla5"&gt;&lt;/div&gt;&lt;div class="hsla6"&gt;&lt;/div&gt;&lt;/body&gt; 【transparent】 作用:相当于使用了值为0的alpha通道,将背景、文字、边框等的颜色设定为完全透明。 1234567&lt;style&gt;.test&#123;color:transparent;border:1px solid transparent;background:transparent;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>CSS</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站语言切换]]></title>
    <url>%2F2019%2F09%2F07%2Fwz1%2F</url>
    <content type="text"><![CDATA[这可能是目前最方便的网站中英文切换（理论支持所有语言） 实现网站中英文切换的三种方法]]></content>
      <categories>
        <category>小知识</category>
      </categories>
      <tags>
        <tag>小知识</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取子节点所有父节点的name的拼接]]></title>
    <url>%2F2019%2F09%2F07%2Fztree2%2F</url>
    <content type="text"><![CDATA[原文链接 12345678910//获取子节点，所有父节点的name的拼接字符串function getFilePath(treeObj)&#123;if(treeObj==null)return "";var filename = treeObj.name;var pNode = treeObj.getParentNode();if(pNode!=null)&#123;filename = getFilePath(pNode) +"&gt;"+ filename;&#125;return filename;&#125;]]></content>
      <categories>
        <category>Ztree</category>
      </categories>
      <tags>
        <tag>Ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$.fn.zTree is undefined]]></title>
    <url>%2F2019%2F09%2F07%2Fztree1%2F</url>
    <content type="text"><![CDATA[场景 在使用ztree做目录树功能的时候,在初始化的时候报 $.fn.zTree is undefined 错误 原因及解决办法 在父页面引用的jquery相关js文件,layui弹出层引用页面,子页面同时引用了jquery和ztree相关的js ​ 子页面引入js库放到body标签中,保存后再运行 把jquery的js放在了ztree的下面,ztree覆盖了jquery里面的一些内容 ​ 把jquery的js放在前面即可]]></content>
      <categories>
        <category>Exception</category>
        <category>Ztree</category>
      </categories>
      <tags>
        <tag>Ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Layui相关问题推荐阅读]]></title>
    <url>%2F2019%2F09%2F07%2Flayui5%2F</url>
    <content type="text"><![CDATA[解决Layui选择全部,换页checkbox复选框重新勾选的问题方法 layui admin table单击行勾选checkbox并高亮显示 Layui select配合input实现可输入，可选择，可搜索]]></content>
      <categories>
        <category>Layui</category>
      </categories>
      <tags>
        <tag>Layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[select组件设置下拉框的高度]]></title>
    <url>%2F2019%2F09%2F07%2Flayui4%2F</url>
    <content type="text"><![CDATA[1.layui-form-select dl &#123; max-height:210px; &#125;]]></content>
      <categories>
        <category>Layui</category>
      </categories>
      <tags>
        <tag>Layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layui表格内放置图片,并点击放大]]></title>
    <url>%2F2019%2F09%2F07%2Flayui3%2F</url>
    <content type="text"><![CDATA[原文链接 12345678910111213141516171819 //layui table: done:function(res,curr,count)&#123; hoverOpenImg();//显示大图 &#125;//显示大图片 function hoverOpenImg()&#123; var img_show = null; // tips提示 $('td img').hover(function()&#123; //alert($(this).attr('src')); var img = "&lt;img class='img_msg' src='"+$(this).attr('src')+"' style='width:130px;' /&gt;"; img_show = layer.tips(img, this,&#123; tips:[2, 'rgba(41,41,41,.5)'] ,area: ['160px'] &#125;); &#125;,function()&#123; layer.close(img_show); &#125;); $('td img').attr('style','max-width:70px');&#125;]]></content>
      <categories>
        <category>Layui</category>
      </categories>
      <tags>
        <tag>Layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layer弹出层父子页面事件相互调用方法]]></title>
    <url>%2F2019%2F09%2F07%2Flayui2%2F</url>
    <content type="text"><![CDATA[原文链接 父页面 12345678910111213141516171819202122232425262728&lt;body&gt;&lt;a data-url="bbbb.html" id="parentIframe"&gt;小小提示层&lt;/a&gt;&lt;input id="shuzhi" /&gt;&lt;button class="but_par"&gt;父页面&lt;/button&gt;&lt;/body&gt;&lt;script src="../jquery-1.9.1.min.js"&gt;&lt;/script&gt;&lt;script src="layer/layer.js"&gt;&lt;/script&gt;&lt;script&gt;$(function()&#123;$("#parentIframe").click(function()&#123;var a = $(this).attr("data-url");layer.open(&#123; type: 2, content: a, success: function(layero, index)&#123; var body = layer.getChildFrame('body', index);//获取子页面内容 //得到iframe页的窗口对象,执行iframe页的方法：iframeWin.method(); var iframeWin = window[layero.find('iframe')[0]['name']]; body.find("#transmit").click();//执行子页面的方法 body.find('input').val('Hi，我是从父页来的') $(".but_par").click(function()&#123; alert(222); &#125;) &#125;&#125;); &#125;);&#125;);&lt;/script&gt; 子页面 1234567891011121314151617&lt;body&gt;&lt;input id="name" value="不满意" /&gt;&lt;button id="transmit"&gt;给父层传值&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;$(function()&#123;$(document).on("click","#transmit").click(function()&#123;parent.$("#shuzhi").val($("#name").val());parent.location.reload(); 刷新父页面//关闭layer弹出层var index = parent.layer.getFrameIndex(window.name); //获取窗口索引parent.layer.close(index);&#125;)window.parent.$(".but_par").click();//执行父页面的事件&#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>Layui</category>
      </categories>
      <tags>
        <tag>Layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layui 给数据表格加序号]]></title>
    <url>%2F2019%2F09%2F07%2Flayui1%2F</url>
    <content type="text"><![CDATA[原文链接 第一种需求,只给当前页加序号 12345,cols: [[ &#123;field:'tourPlayerId', width:80, title: 'ID1', sort: true,fixed: 'left',&#125; ,&#123;field:'zizeng', width:80, title: '排名',fixed: 'left',templet: function (d) &#123;return d.LAY_TABLE_INDEX+1;&#125;&#125; ]] 需注意:点击下一页时,只会重新从1开始排序 第二种需求,包括分页的数据也加上序号(连续性排序) 1234,cols: [[ &#123;field:'tourPlayerId', width:80, title: 'ID1', sort: true,fixed: 'left',&#125; ,&#123;field:'zizeng', width:80, title: '排名',fixed: 'left', type:'numbers'&#125; ]] 设定列类型。可选值有：normal(常规列,无需设定)、checkbox(复选框列)、space(空列)、numbers(序号列) 注意:该参数为 layui 2.2.0 新增。而如果是之前的版本,复选框列采用 checkbox:true、空列采用 space: true]]></content>
      <categories>
        <category>Layui</category>
      </categories>
      <tags>
        <tag>Layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dom访问表单控件的常用属性和方法]]></title>
    <url>%2F2019%2F09%2F07%2Fjs7%2F</url>
    <content type="text"><![CDATA[DOM访问列表框、下拉菜单的常用属性 form 返回列表框/下拉框所在的表单对象 length 返回列表框/下拉框的选项个数 options 返回列表框/下拉菜单里所有选项组成的数组 selectedIndex 返回下拉列表中选中选项的索引 type 返回下拉列表的类型, 多选的话返回select-multiple,单选select-one 使用options[index]返回具体选项所对应的常用属性 defaultSelected 返回该选项默认是否被选中 index 返回该选项在列框/下拉菜单中的索引 selected 返回该选项是否被选中 text 返回该选项呈现的文本 value 返回该选项的value属性值 在elements返回的数组中访问具体的表单控件语法 .elements[index] 返回该表单中的第index个表单控件 .elements[elementName] 返回表单内id或name为elementName的表单控件 .elementName 返回表单中id或name为elementName的表单控件 案例:表单控件 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表单控件&lt;/title&gt; &lt;script&gt; function operateForm() &#123; var myForm = document.forms[0]; console.log(myForm.action); console.log(myForm.method); console.log(myForm.target); myForm.submit(); //表单提交 //myForm.reset(); //表单重置 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id="myform" action="https://www.baidu.com" method="get" target="_self"&gt; &lt;input name="username" type="text" value="liming" /&gt;&lt;br/&gt; &lt;input name="password" type="password" value="123456" /&gt;&lt;br/&gt; &lt;select name="city"&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; &lt;input type="button" value="获取表单内的第一个控件" onclick="alert(document.getElementById('myform').elements[0].value)" /&gt; &lt;input type="button" value="获取表单内的第二个控件" onclick="alert(document.getElementById('myform').elements['password'].value)" /&gt; &lt;input type="button" value="获取表单内的第三个控件" onclick="alert(document.getElementById('myform').city.value)" /&gt; &lt;input type="button" value="操作表单" onclick="operateForm()" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 案例:查找列表框,下拉菜单控件 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;查找列表框,下拉菜单控件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;select name="city" id="city" size="5"&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="beijing" selected="selected"&gt;北京&lt;/option&gt; &lt;option value="shanghai"&gt;天津&lt;/option&gt; &lt;option value="beijing"&gt;南京&lt;/option&gt; &lt;option value="shanghai"&gt;武汉&lt;/option&gt; &lt;option value="shanghai"&gt;深圳&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; &lt;input type="button" value="第一个城市" onclick="change(s_city.options[0])" /&gt; &lt;input type="button" value="上一个城市" onclick="change(s_city.options[s_city.selectedIndex-1])" /&gt; &lt;input type="button" value="下一个城市" onclick="change(s_city.options[s_city.selectedIndex+1])" /&gt; &lt;input type="button" value="最后一个城市" onclick="change(s_city.options[s_city.length-1])" /&gt; &lt;script&gt; var s_city = document.getElementById("city"); var change = function(city) &#123; alert(city.text); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; DOM访问表格子元素的常用属性和方法 caption 返回表格的标题对象 rows 返回该表格里所有行 tbodies 返回该表格里所有&lt;tbody../&gt;元素组成的数组 tfoot 返回该表格里所有的&lt;tfoot../&gt;元素 thead 返回该表格里所有的&lt;thead../&gt;元素 通过rows[index]返回表格指定的行所对应的属性 cells 返回该表格内所有的单元格组成的数组 rowIndex 返回该表格行在表格内的索引值 sectionRowIndex 返回该表格行在其所在元素(tbody,thead等元素)的索引值 通过cells[index]返回表格指定的列所对应的属性 属性 描述 cellIndex 返回该单元格在表格行内的索引值 1234567function updateCell()&#123;var row=document.getElementById("row").value;var cell=document.getElementById("cell").value;var t=document.getElementById("mytable");t.rows[row-1].cells[cell-1].innerHTML=document.getElementById("course").value;//t.rows.item(row-1).cells.item(cell-1).innerHTML=document.getElementById("course").value;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dom对HTML元素的增删改操作]]></title>
    <url>%2F2019%2F09%2F07%2Fjs6%2F</url>
    <content type="text"><![CDATA[为了动态地修改HTML元素,须先访问HTML元素。 DOM主要提供了两种方式来访问 HTML元素 根据 l D访问HTML元素一通过document对象调用getE l ementById()方法来查找具有唯一id属性值的元素。 利用节点关系访问HTML元素。常用的属性和方法 parentNode 返回当前节点的父节点 previousSibling 返回当前节点的前一个兄弟节点 nextSibling 返回当前节点的后一个兄弟节点 childNodes 返回当前节点的所有子节点 firstChild 返回当前节点的第一个子节点 lastChild 返回当前节点的最后一个子节点 getElementsByTagName(tagName) 返回当前节点的具有指定标签名的所有子节点 DOM创建节点的方法 document.createElement(Tag),Tag必须是合法的HTML元素 DOM复制节点的方法 节点cloneNode(boolean deep),当deep为true时,表示复制当前节点以及当前节点的全部后代节点(深复制)。为false时,只复制当前节点浅复制) DOM添加、 删除节点的方法 appendChild(newNode) 将newNode添加成当前节点的最后一个子节点 insertBefore(newNode,refNode) 在 refNode节点之前插入newNode节点 replaceChild(newNode,oldNode) 将ol dNode节点替换成newNode节点 removeChild(oldNode) 将oldNode子节点删除 代码示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; var city = document.getElementById("city"); function create() &#123; var element = document.createElement("li");//ie不支持 element.innerHTML = "南京"; city.appendChild(element); //city.firstChild.nextSibling --&gt;&lt;li&gt;北京&lt;/li&gt; //city.insertBefore(element,city.firstChild.nextSibling); //city.replaceChild(element,city.firstChild.nextSibling) &#125; function copy() &#123; var element = city.firstChild.nextSibling.cloneNode(true); //true深复制(后代元素也会复制) false浅复制 只复制当前元素 city.appendChild(element); &#125; function del() &#123; var element = city.firstChild.nextSibling; city.removeChild(element); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="city"&gt; &lt;li&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;/ul&gt; &lt;input type="button" value="创建复制替换节点" onclick="create()" /&gt; &lt;input type="button" value="复制节点" onclick="copy()" /&gt; &lt;input type="button" value="删除节点" onclick="del()" /&gt; &lt;/body&gt;&lt;/html&gt; DOM为列表框、下拉菜单添加选项的方式 创建选项除了使用前面所示createElement方法之外, 还可以使用专门的构造器来构造一个选项出来 语法如下: 1new Option(text,value,defaultSelected,selected) 该构造器有4个参数 text 该选项的文本、即该选项所呈现的”内容” value 选中该选项的值 defaultSelected 设置默认是否显示该选项 selected 设置该选项当前是否被选中 提示:并不是每次构造函数都需指明4个参数,可以指明一个或者两个都可以(浏览器都兼容). 添加创建好的选项至列表框或下拉菜单的方式 直接为&lt;select…/&gt;的指定选项赋值 列表框或下拉菜单对象.options[i]=创建好的option对象 删除列表框或下拉菜单的选项的方法 列表框或下拉菜单对象.remove(index)方法/对象.options[index]=null 删除指定项 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; function createSelect() &#123; var element = document.createElement("select"); for(var i = 0; i &lt; 10; i++) &#123; var op = new Option("新增的选项" + i, i); element.options[i] = op; &#125; element.size = 5; //一次性显示5个 element.id = "city"; //设置id属性 document.getElementById("test").appendChild(element); &#125; function delOne() &#123; var city = document.getElementById("city"); var len = city.options.length; if(len &gt; 0) &#123; city.remove(len - 1); //city.options[len-1]=null; &#125; &#125; function delAll() &#123; var city = document.getElementById("city"); var len = city.options.length; if(len &gt; 0) &#123; city.options.length = 0; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body id="test"&gt; &lt;input type="button" value="创建一个城市列表" onclick="createSelect()" /&gt; &lt;input type="button" value="一条条删除列表框内容" onclick="delOne()" /&gt; &lt;input type="button" value="一次性清空列表框内容" onclick="delAll()" /&gt; &lt;/body&gt;&lt;/html&gt; DOM动态添加删除表格内容所使用到的常用方法 insertRow(index) 在指定索引位置插入一行 createCaption() 为该表格创建标题 createTFoot() 为该表格创建&lt;tfoot. .. /&gt;元素,假如已存在就返回现有的 createTHead() 为该表格创建&lt;thead. .. /&gt;元素,假如已存在就返回现有的 deleteRow(index) 删除表格中 i ndex索引处的行 deleteCaption() 删除表格标题 deleteTFoot() 从表格删除 tFoot元素及其内容 deleteTHead() 从表格删除 tHead元素及其内容 给表格行创建,删除单元格的方法 insertCell(index) 在index处创建一个单元格,返回新创建的单元格 deleteCell(index) 删除某行在index索引处的单元格 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; function createTable() &#123; var b = document.getElementById("test"); var t = document.createElement("table"); t.border = "1"; t.id = "mytable"; var caption = t.createCaption(); caption.innerHTML = "我的表格"; for(var i = 0; i &lt; 5; i++) &#123; var tr = t.insertRow(i); for(var j = 0; j &lt; 4; j++) &#123; var td = tr.insertCell(j); td.innerHTML = "单元格" + i + j; &#125; &#125; b.appendChild(t); &#125; function delLastRow() &#123; var t = document.getElementById("mytable"); var rows = t.rows; if(rows.length &gt; 0) &#123; t.deleteRow(rows.length - 1); &#125; &#125; function delLastCell() &#123; var t = document.getElementById("mytable"); var rows = t.rows; if(rows.length &gt; 0) &#123; var lastRow = t.rows[t.rows.length - 1]; var len = lastRow.cells.length; if(len &gt; 0) &#123; lastRow.deleteCell(len - 1); &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body id="test"&gt; &lt;input type="button" value="创建一个5行4列的表格" onclick="createTable()" /&gt; &lt;input type="button" value="删除最后一行" onclick="delLastRow()" /&gt; &lt;input type="button" value="删除最后一个单元格" onclick="delLastCell()" /&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中创建对象主要有3种方式(常用内置对象)]]></title>
    <url>%2F2019%2F09%2F07%2Fjs5%2F</url>
    <content type="text"><![CDATA[使用 new关键字调用构造器创建对象12345678910&lt;script type="text/javascript"&gt;function Student(name,age) &#123;this.name=name;this.age=age;&#125;var s1=new Student();//没有传入参数var s2=new Student("haogeshuai",30) ;document. write(s1.name+"--"+s1.age+"&lt;br/&gt;");document. write(s2.name+"--"+s2.age) ;&lt;/script&gt; 使用Object直接创建对象 1234567891011&lt;script type="text/javascript"&gt;var myObj=new Object() ;myObj.name="haogeshuai"; myObj.age=34;myObj.info=function()&#123;document. write("我的名字叫: "+this.name+"&lt;br/&gt;") ; document. write("今年"+this.age+"岁&lt;br/&gt;") ;&#125;myObj.info();&lt;/script&gt; JavaScript使用JSON创建对象的语法 JSON(JavaSoript Objeot Notation)是一种轻量级的数据交换,易于人阅读和编写. JSON的格式 JSON对象是以一对”大括号”括起来,大括号内以多个”名值对”组成,多个名值对之问用“逗号”隔开,名所对应的值可以是各种数据类型的值,也可以是JSON对象。 JSON数组用“[]”括起来. 语法 1object=&#123;属性名1:属性值1,属性名2:属性值2,...&#125; 示例: 12345678var p=&#123;name: "haogeshua i,gender: "male",info: function ()&#123;document.write("姓名:"+this.name+",性别:"+this.gender);&#125;&#125; p.info(); 对象是 JavaScript的特性之一,它是一种非常重要的数据类型,是自我包含的数据集合。这里介绍两个实用的具体对象Date和Math 创建Date对象方法 new Date() new Date(month dd,yyyy hh:mm:ss) new Date(yyyy,mth,dd,hh,mm.ss) new Date(yyyy,mth,dd) new Date(ms) Date对象设置时间方法 setDate() 设置Date对象中月的某一天(1~31) setMonth() 设置Date对象中月份(0~11) setFullYear() 设置Date对象中的年份(四位数字) setHours() 设置Date对象中的小时(0~23) setMinutes() 设置Date对象中的分钟(0~59) setSeconds() 设置Date对象中的秒钟(0~59) setMilliseconds() 设置Date对象中的亳秒(0~999) Date对象获取时间细节方法 getDate() 从Date对象返回一个月中的某一天(1~31) getDay() 从Date对象返回一周中的某一天(0~6) getMonth() 从Date对象返回月份(0~11) getFullYear() 从Dae对象以四位数字返回年份 getHours() 返回Date对象的小时(0~23)。 getMinutes() 返回Date对象的分钟(0~59) getSeconds() 返回Date对象的秒数(0~59) getTime () 返回1970年1月1日至今的亳秒数 Math对象的常用方法 abs(x) 返回数的绝对值 ceil(x) 对数进行上舍入 floor(x) 对数进行下舍入 max(x,y) 返回x和y的最高值 min(x,y) 返回x和y的最低值 pow(x,y) 返回x的y次幂 random() 返回0~1之间的随机数 round(x) 把数四舍五入为最接近的整数 sqrt(x) 返回数的平方根]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM模型中常用对象的介绍]]></title>
    <url>%2F2019%2F09%2F07%2Fjs4%2F</url>
    <content type="text"><![CDATA[BOM-javaScript是运行在浏览器中的, 所以提供了一系列对象用于和浏览器窗口进行交互, 这些对象主要包括window、document、screen、location、 navigator等.通常统称为浏览器对象模型(Brower Object Model) window对象是整个JavaScript脚本运行的顶层对象, 它的常用属性如下 document 返回该窗口内装载的HTML文档 location 返回该窗口装载的HTML文档的uRL navigator 返回浏览当前页面的浏览器, 包含了一系列的浏览器属性, 包括名称、版本号和平台等 screen 返回当前浏览者屏幕对象 history 返回该浏览窗口的历史 Iocation对象常用属性如下 hostname 文档所在地址的主机名 href 文档所在地址的uRL地址 host 文档所在地址的主机地址 port 文档所在地址的服务端口 pathname 文档所在地址的文件地址 protocol 装载该文档所使用的协议, 例如HTTP:等 1234567891011121314host name:localhosthref:http://1ooalhost:80l1l8/study/test.htmlhost adress:1ocalhost:8088port:8088protoco1 : http:availHeight:920availWidth:1280colorDepth:24appCodeName:MozillaappName:NetscapeappVersion:5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML,like Gecko) Chrome/33.0.1750.117 Safari/537.36 platform:Win32 userAgent:Mozilla/5.0 (Windows NT 6.1;WOW64) AppleWebKit/537.36 (KHTML,like Gecko) Chrome/33.0.1750.117 Safari/537.36 cookieEnabled:true screen对象常用属性如下 availHeight 窗口可以使用的屏幕高度, 单位像素 availwidth 窗口可以使用的屏幕宽度,单位像素 colorDepth 用户浏览器表示的颜色位数,通常为32位(每像素的位数) navigator对象常用属性如下 appcodeName 浏览器代码名的字符串表示 appName 官方浏览器名的字符串表示 appVersion 浏览器版本信息的字符串表示 platform 浏览器所在计算机平台的字符串表示 userAgent 用户代理头的字符串表示 cookieEnabled 如果启用cookie返回true, 否则返回false history对象常用方法如下 back() 后退到上一个浏览的页面,如果该页面是第一个打开的,则无效果 forward() 前进到下一个;刘览页面,如果该页面是第一个打开的,则无效果 go(IntValue) 该方法可指定前进或后退多少个页面,正前进,负后退 window对象的常用方法 alert(), confirm(),prompt() 分别用于弹出警告窗口、 确认对话框和提示输入对话框 close() 关闭窗口 moveBy()、 moveTo() 移动窗口 resizeBy()、 resizeTo() 重设窗口大小 scrollBy()、 scrollTo() 滚动当前窗口的HTML文档 open() 打开一个新的浏览器窗口加载新的uRL所指向的地址, 并可指定一系列新的属性, 包括隐藏菜单等 setIntervaI(),clearInteral() 设置、删除定时器]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2019%2F09%2F07%2Fjs3%2F</url>
    <content type="text"><![CDATA[事件的概念JavaScript使我们有能力创建动态页面, 网页中的每个元素都可以产生某些可以触发 JavaScript函数的事件。我们可以认为事件是可以被 JavaScript侦测到的一种行为。事件流事件流主要分冒泡型事件 ,和捕获型事件 。 lE浏览器目前只支持冒泡型事件,火狐、 chrome等两者都支持。 冒泡型事件 结果: p div body p div …. 捕获型事件 结果: body div p body div p …. 使用返回值改变HTML元素的默认行为 HTML元素大都包含了自己的默认行为,例如：超链接、提交按钮等。 我们可以通过在绑定事件中加return false来阻止它的默认行为。 通用性的事件监听方法 绑定HTML元素属性 1&lt;input type=&quot;button&quot; value=&quot;clickMe&quot; onclick=&quot;check(this)&quot; /&gt; 绑定DOM对象属性 1document.getElementById(&quot;btn1&quot;).onclick=test; IE中的事件监听方法 [object].attachEvent(“事件类型”,“处理函数”);//添加监听 [object].detachEvent(“事件类型”, 处理函数”); //取消监听 标准DOM中的事件监听方法 [objeot]. addEventListener( “事件类型”,“处理函数”，“冒泡事件或捕获事件”); [objeot]. removeEventListener( “事件类型”,“处理函数”，“冒泡事件或捕获事件”); 提示: l E监听方法中的事件类型和标准DOM监听方法中的事件类型写法有点同,前者事件类型“on”开头.比如: “onclick”,”onmousemove”等。而后者不需要去掉” on”,就是” click”,” mousemove”等 一般不会使用: 123456789101112131415161718192021222324//Ie特有: function show() &#123; alert(1); &#125; var test1 = document.getElementById("test1"); var test2 = document.getElementById("test2"); window.onload=function()&#123; test1 .attachEvent("onclick",show); test2.onclick=function()&#123; test1.detachEvent("onclick",show); &#125;; &#125;//标准DOM: window.onload = function() &#123; test1.addEventListener("click", show, true); //true 冒泡型事件 false 捕获型事件 test2.onclick = function() &#123; test1.removeEventListener("click", show, true); &#125;; &#125; 访问事件对象 事件对象封装了事件发生的详细信息,尤其是鼠标,键盘事件.如鼠标事件发生的位置,键盘事件的键盘键等 IE中的事件对象 IE中的事件对象是一个隐式可用的全局对象:event,它是window对象的一个属性. 123op.onclick=function()&#123;var oEvent=window.event;&#125; 标准DOM中的事件对象 在标准DOM浏览器检测到发生了某个事件时,将自动创建一个Event对象,并隐式地将该对象作为事件处理函数的第一个参数传入. 123op.onclick=function(oEvent)&#123; //作为参数传进来&#125; 经验之谈:为了兼容不同的浏览器,通常采用下面的方法得到事件对象. 12345op.onclick=function(oEvent)&#123; if(window.event)&#123; oEvent=window.event; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;事件的目标&lt;/title&gt; &lt;script&gt; function handle(oEvent) &#123; if(window.event) &#123; oEvent = window.event; &#125; var oTarget; if(oEvent.srcElement) &#123; oTarget = oEvent.srcElement;//IE &#125; else &#123; oTarget = oEvent.target;//标准DOM &#125; alert(oTarget.tagName); //弹出IMG &#125; window.onload = function() &#123; var oImg = document.getElementsByTagName("img")[0]; oImg.onclick = handle; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="img/HBuilder.png" border="0" /&gt; &lt;/body&gt;&lt;/html&gt; 常见的事件类型 常用的鼠标事件 onclick 单击鼠标左键触发 ondclick 双击鼠标左键触发 onmousedown 单击任意一个鼠标按键时触发 onmousemove 鼠标在某个元素上移动时持续触发 onmouseout 鼠标指针移出一个元素边界时触发 onmouseup 松开鼠标任意一个按键时触发 onmouseover 鼠标指针移到一个元素上时触发 常用的键盘事件 onkeydown 按下键盘上某个按键时触发,一直按会持续触发 onkeyup 释放某个按键时触发 onkeypress 按下某个按键并产生字符时触发, 忽略shift等功能键 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;鼠标事件&lt;/title&gt; &lt;script&gt; function handle(oEvent) &#123; if(window.event) &#123; oEvent = window.event; //处理兼容性，获得事件对象 &#125; var oDiv = document.getElementById("display"); oDiv.innerHTML += oEvent.type + "&lt;br/&gt;";//输出事件名称 &#125; window.onload = function() &#123; var oImg = document.getElementsByTagName("img")[0]; oImg.onmousedown = handle; oImg.onmouseup = handle; oImg.onmouseover = handle; oImg.onmouseout = handle; oImg.onclick = handle; oImg.ondblclick = handle; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="img/HBuilder.png" border="0" /&gt; &lt;div id="display"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;键盘事件&lt;/title&gt; &lt;script&gt; function handle(oEvent) &#123; if(window.event) &#123; oEvent = window.event; //处理兼容性，获得事件对象 &#125; var oDiv = document.getElementById("display"); oDiv.innerHTML += oEvent.type + "&lt;br/&gt;"; //输出事件名称 &#125; window.onload = function() &#123; var txt = document.getElementsByTagName("textarea")[0]; txt.onkeydown = handle; txt.onkeyup = handle; txt.onkeypress = handle; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;textarea rows="4" cols="50"&gt;&lt;/textarea&gt; &lt;div id="display"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; HTML事件 1234567891011121314&lt;body onload="alert('hello')" onunload="alert('byebye')"&gt; &lt;form action="https://www.baidu.com" onsubmit="return false"&gt; &lt;input type="text" value="a" onfocus="alert('获取焦点')" onblur="alert('失去焦点')" /&gt; &lt;input type="text" value="b" onchange="alert('内容改变了')" onselect="alert('内容选中了')" /&gt; &lt;select name="city" onchange="alert('选项改变了')"&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[onclick事件传变量时注意的问题]]></title>
    <url>%2F2019%2F09%2F07%2Fjs2%2F</url>
    <content type="text"><![CDATA[原文链接 onclick事件传变量时 123var setname="start";return '&lt;img src="images/control_start_blue.png" style="cursor:hand" width="15px" height="15px" onclick="sendMsg(\''+setname+'\');" &gt;'; 上面这个注意&#39;‘这个是一个\和两个’单引号，而不是一个”双引号，刚开始老看不明白，是因为两个’放一起看起来像”双引号了。 原文链接 onclick事件中传递对象参数 1234567var user = &#123;id:1, name:'zs', age:20&#125;;var ele = '&lt;a onclick="edit(' + JSON.stringify(user).replace(/"/g, '&amp;quot;') + ');"&gt;修改&lt;/a&gt;';或者 var ele = '&lt;a onclick="edit(\'' + JSON.stringify(user).replace(/"/g, '&amp;quot;') + '\');"&gt;修改&lt;/a&gt;'; 前者取到的是json对象，后者取到的是json字符串。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js正则验证特殊字符]]></title>
    <url>%2F2019%2F09%2F07%2Fjs1%2F</url>
    <content type="text"><![CDATA[参考链接方案一1234567var regEn = /[`~!@#$%^&amp;*()_+&lt;&gt;?:"&#123;&#125;,.\/;'[\]]/im, regCn = /[·！#￥（——）：；“”‘、，|《。》？、【】[\]]/im; if(regEn.test(newName) || regCn.test(newName)) &#123; alert("名称不能包含特殊字符."); return false;&#125; 方案二12345678function checkName(val)&#123; var reg = new RegExp("[`~!@#$^&amp;*()=|&#123;&#125;':;',\\[\\].&lt;&gt;/?~！@#￥……&amp;*（）——|&#123;&#125;【】‘；：”“'。，、？]"); var rs = ""; for (var i = 0, l = val.length; i &lt; val.length; i++) &#123; rs = rs + val.substr(i, 1).replace(reg, ''); &#125; return rs; &#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特殊日期格式转换]]></title>
    <url>%2F2019%2F09%2F06%2Fjquery7%2F</url>
    <content type="text"><![CDATA[特殊日期格式转换2018-12-03T17:17:36.000+08:00 转化为2018-12-03 00:00:00 (正则表达式的方法) 原文链接 1234567// str=2018-12-03T17:17:36.000+08:00 转化为2018-12-03 00:00:00function toDate(str)&#123; var dateee = new Date(str).toJSON(); var date = new Date(+new Date(dateee)+8*3600*1000).toISOString().replace(/T/g,' ').replace(/\.[\d]&#123;3&#125;Z/,'') console.log("时间2==="+date); return date ;&#125;]]></content>
      <categories>
        <category>JQUERY</category>
      </categories>
      <tags>
        <tag>JQUERY</tag>
        <tag>DATE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery判断复选框是否被选中]]></title>
    <url>%2F2019%2F09%2F06%2Fjquery6%2F</url>
    <content type="text"><![CDATA[jQuery判断复选框是否被选中1234567891011121314151617181920212223方法一：if ($(&quot;#checkbox-id&quot;).get(0).checked) &#123; // do something&#125;方法二：if($(&apos;#checkbox-id&apos;).is(&apos;:checked&apos;)) &#123; // do something&#125;方法三：if ($(&apos;#checkbox-id&apos;).attr(&apos;checked&apos;)) &#123; // do something&#125;在jQuery1.6版本之后，取复选框有没有被选中，要用propif($(&apos;#checkbox-id&apos;).prop(&apos;checked&apos;))&#123; //do something&#125; tr变色1234567891011$(function () &#123; //input 单击事件 $(&quot;input&quot;).click(function () &#123; //获取checkbox选中项 if ($(this).attr(&apos;checked&apos;)) &#123; $(this).parent().parent().css(&quot;background&quot;, &quot;#d4efff&quot;); &#125; else &#123; $(this).parent().parent().css(&quot;background&quot;, &quot;&quot;); &#125; &#125;);&#125;); $(this).parent()–&gt;找到当前行td –&gt;$(this).parent().parent() –&gt;找到当前行td的父亲tr]]></content>
      <categories>
        <category>JQUERY</category>
      </categories>
      <tags>
        <tag>JQUERY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Select的文本,值获取/设置/删除/清空]]></title>
    <url>%2F2019%2F09%2F06%2Fjquery5%2F</url>
    <content type="text"><![CDATA[原文链接 获取select 12345678//获取select 选中的 text : $("#ddlregtype").find("option:selected").text();//获取select选中的 value: $("#ddlregtype").val();//获取select选中的索引: $("#ddlregtype").get(0).selectedindex; 设置select 1234567891011121314151617181920212223//设置select选中的索引： $("#ddlregtype").get(0).selectedindex=index;//index为索引值//设置select 选中的value： $("#ddlregtype").attr("value","normal“); $("#ddlregtype").val("normal"); $("#ddlregtype").get(0).value = value;//设置select 选中的text: var count=$("#ddlregtype option").length; for(var i=0;i&lt;count;i++) &#123; if($("#ddlregtype").get(0).options[i].text == text) &#123; $("#ddlregtype").get(0).options[i].selected = true; break; &#125; &#125; $("#select_id option[text='jquery']").attr("selected", true);//设置select option项: $("#select_id").append("&lt;option value='value'&gt;text&lt;/option&gt;"); //添加一项option $("#select_id").prepend("&lt;option value='0'&gt;请选择&lt;/option&gt;"); //在前面插入一项option select删除/清空 12345$("#select_id option:last").remove(); //删除索引值最大的option$("#select_id option[index='0']").remove();//删除索引值为0的option$("#select_id option[value='3']").remove(); //删除值为3的option$("#select_id option[text='4']").remove(); //删除text值为4的option$("#ddlregtype").empty();//清空]]></content>
      <categories>
        <category>JQUERY</category>
      </categories>
      <tags>
        <tag>JQUERY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何改变html标签的样式(两种实现方法)]]></title>
    <url>%2F2019%2F09%2F06%2Fjquery4%2F</url>
    <content type="text"><![CDATA[原文链接 通过修改标签属性来改变它的样式 js设置和获取标签的属性 1234567&lt;script type="text/javascript"&gt; window.onload = function () &#123; var attr = document.getElementById("attr"); attr.setAttribute("style", "font-weight:bold;") alert(attr.getAttribute("style")); &#125; &lt;/script&gt; jquery设置和获取标签的属性 123456789&lt;script src="jquery/jquery-1.4.2.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#attr").attr("style", "color:#ff0000");//单个属性的设置 $("#Avatar").attr(&#123; "class": "banner", "alt": "头像", "src": "http://pic.cnblogs.com/avatar/a118538.jpg?id=11133319" &#125;);//多个属性的设置 alert($("#Avatar").attr("src")); //得到指定标签的属性 &#125;); &lt;/script&gt; 值得注意的是JS的window.onload方法块的内容是在JQ的$(function(){})方法块执行完成后，再执行的。 通过修改标签的css样式来改变它的样式 看看基本的语法： 1234$("#attr").addClass("banner");//添加样式 $("#attr").removeClass("banner");//移除样式 //ＪＱ支持连带写法，因为removeClass的返回结果也是一个Jq对象，所以Jq对象的所有方法和事件它都可以使用 $("#attr").removeClass("banner").addClass("bannerOver"); 下面是一个例子，当在dd标签上单击时，将当前dd块进行高亮显示 1234567891011121314151617181920212223&lt;style&gt; .banner &#123; background: #0094ff; &#125; .bannerOver &#123; background: #808080; &#125; .cur &#123; background: #ff6a00; &#125; &lt;/style&gt; &lt;script&gt; $(function () &#123; $('#menu_title').find('dd').click(function () &#123; $('#menu_title').find('dd').removeClass('cur'); $(this).addClass('cur'); &#125;);&#125;); &lt;/script&gt; &lt;body&gt;&lt;dl id="menu_title"&gt; &lt;dt&gt;人&lt;/dt&gt; &lt;dd&gt;一种高级动物&lt;/dd&gt; &lt;dt&gt;狗&lt;/dt&gt; &lt;dd&gt;人类的朋友&lt;/dd&gt; &lt;dt&gt;猫&lt;/dt&gt; &lt;dd&gt;猫科动物的祖先&lt;/dd&gt; &lt;/dl&gt; &lt;/body&gt; 下面是为表格的隔行变色效果 12345678910.odd &#123; background: #808080; &#125; .even &#123; background: #ffd800; &#125; .selected &#123; background: #0094ff; color: #fff; &#125; .hover &#123; background: #808080; &#125; //选择所有行 var $trs = $("#menu_title&gt;dd"); //给奇数行添加odd样式 $trs.filter(":odd").addClass("odd");//给偶数行添加odd样式 $trs.filter(":even").addClass("even"); 单击行后，让当前行高亮显示 1234//点击行,添加变色样式 $trs.click(function(e) &#123; $(this).addClass("selected").siblings().removeClass("selected"); &#125;) 添加鼠标移入与移出事件 123456789// 鼠标移入 与移出 $("#menu_title&gt;dd").hover( function () &#123; $(this).addClass("hover"); &#125;, function () &#123; $(this).removeClass("hover"); &#125; );]]></content>
      <categories>
        <category>JQUERY</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>JQUERY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery禁用、启用button以及button的样式操作]]></title>
    <url>%2F2019%2F09%2F06%2Fjquery3%2F</url>
    <content type="text"><![CDATA[原文链接 禁止使用button1.直接写在&lt;button&gt;标签里面1&lt;button id="btn" disabled="disabled"&gt;设置按钮不可以点击&lt;/button&gt;2.js禁用button1document.getElementById("btn").disabled=true; 3.使用jquery禁用button 123$("#btn").attr('disabled',true);$("#btn").attr('disabled','disabled');$("#btn").prop('disabled','disabled'); 设置禁用之后启用button 1.使用js启用button 1document.getElementById("btn").disabled = true; 2.jquery启用button 12345$("#btn").attr('disabled',false);$("#btn").removeAttr("disabled");$("#btn").attr('disabled',''); button的显示与隐藏 1234//jq:$("#btn").show();$("#btn").hide(); 给button设置css样式 1234567891011121314151617background-color: #1AAD19;//设置背景颜色color: #FFFFFF;//设置按钮上面的字体颜色border: 1px solid #1AAD19;//设置边框的颜色cursor: pointer;//设置鼠标移动到button的样式border-radius: 3px;//设置倒角的大小，这个属性可以使得四个角有一定的角度更美观一点width: 100px;//设置按钮的宽度height: 36px;//设置按钮的高度border:none;//去掉边框background:url("static/images/reponse_add.png") no-repeat;//设置背景图片 设置button的click事件 12$("#btn").click(function()&#123; //do something jquery改变button的样式 1.直接css()方法进行修改样式 123456789101112131415$("#btn").css("color","red");//改一种$("#btn").css(&#123;"color":"white","background-color":"#98bf21","font-family":"Arial","font-size":"20px","padding":"5px"&#125;);//改多种，注意里面加大括号 2.首先定义一个class的样式，然后动态的添加样式 12345678.btnStyle&#123; border: 1px solid #E4E8EB; border-radius: 100%; width: 36px; height: 36px; background-color: #FFFFFF; cursor: pointer;&#125; 点击改成上面这个样式、点击移除上面这个样式。 123456$("#btn").click(function()&#123; $(this).addClass("btnStyle"); &#125;) $("#btn").click(function()&#123; $(this).removeClass("btnStyle"); &#125;)]]></content>
      <categories>
        <category>JQUERY</category>
      </categories>
      <tags>
        <tag>JQUERY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据指定的时间来跟当前时间比较计算倒计时]]></title>
    <url>%2F2019%2F09%2F06%2Fjquery1%2F</url>
    <content type="text"><![CDATA[原文链接 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 指定的时间 --&gt;&lt;span class="timeCount" data-enddate='&lt;fmt:formatDate value="$&#123;dateTime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;'&gt;00:00:00&lt;/span&gt;&lt;!-- jquery --&gt;&lt;script type="text/javascript"&gt;//初始化倒计时间$(function()&#123;$(".menu li").each(function()&#123;if($(this).attr("class") == "checked")&#123;setInterval(GetRTime,1000); &#125;&#125;);&#125;); function GetRTime()&#123;var EndTime= new Date($(".timeCount").attr("data-enddate"));//new Date('2015/12/31 10:00:00'); //截止时间 前端路上 http://www.51xuediannao.com/qd63/var NowTime = new Date();//当前时间var t =EndTime.getTime() - NowTime.getTime();//var d=Math.floor(t/1000/60/60/24);//天var h=Math.floor(t/1000/60/60%24);//时var m=Math.floor(t/1000/60%60);//分var s=Math.floor(t/1000%60);//秒if(parseInt(h)&lt;10)&#123;h="0"+h;&#125;if(parseInt(m)&lt;10)&#123;m="0"+m;&#125;if(parseInt(s)&lt;10)&#123;s="0"+s;&#125;$(".timeCount").text(h + ":"+m + ":"+s );&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JQUERY</category>
      </categories>
      <tags>
        <tag>JQUERY</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[input file控件限制上传文件类型]]></title>
    <url>%2F2019%2F09%2F06%2Fhtml6%2F</url>
    <content type="text"><![CDATA[原文链接 网页上添加一个input file HTML控件： 1&lt;input id="File1" type="file" /&gt; 默认是这样的，所有文件类型都会显示出来，如果想限制它只显示我们设定的文件类型呢，比如“word“,”excel“,”pdf“文件 解决办法是可以给它添加一个accept属性，比如： 1&lt;input id="File1" type="file" accept=".xls,.doc,.txt,.pdf" /&gt; 这样选择的时候默认会显示为这样： 文件选择框内只显示出你自定义文件类型的文件，也还比较方便。But,这只是最简单的掩人耳目的做法，还是能选择其它文件类型： 所以，如果要做到真正意义上限制类型做法（其实这种算不上限制，只是把你要的文件类型默认显示出来而已，并不是说不能选择其它的）,还是要通过js或者后台来控制。 支持的文件类型: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647*.3gpp audio/3gpp， video/3gpp 3GPP Audio/Video*.ac3 audio/ac3 AC3 Audio*.asf allpication/vnd.ms-asf Advanced Streaming Format*.au audio/basic AU Audio*.css text/css Cascading Style Sheets*.csv text/csv Comma Separated Values*.doc application/msword MS Word Document*.dot application/msword MS Word Template*.dtd application/xml-dtd Document Type Definition*.dwg image/vnd.dwg AutoCAD Drawing Database*.dxf image/vnd.dxf AutoCAD Drawing Interchange Format*.gif image/gif Graphic Interchange Format*.htm text/html HyperText Markup Language*.html text/html HyperText Markup Language*.jp2 image/jp2 JPEG-2000*.jpe image/jpeg JPEG*.jpeg image/jpeg JPEG*.jpg image/jpeg JPEG*.js text/javascript， application/javascript JavaScript*.json application/json JavaScript Object Notation*.mp2 audio/mpeg， video/mpeg MPEG Audio/Video Stream， Layer II*.mp3 audio/mpeg MPEG Audio Stream， Layer III*.mp4 audio/mp4， video/mp4 MPEG-4 Audio/Video*.mpeg video/mpeg MPEG Video Stream， Layer II*.mpg video/mpeg MPEG Video Stream， Layer II*.mpp application/vnd.ms-project MS Project Project*.ogg application/ogg， audio/ogg Ogg Vorbis*.pdf application/pdf Portable Document Format*.png image/png Portable Network Graphics*.pot application/vnd.ms-powerpoint MS PowerPoint Template*.pps application/vnd.ms-powerpoint MS PowerPoint Slideshow*.ppt application/vnd.ms-powerpoint MS PowerPoint Presentation*.rtf application/rtf， text/rtf Rich Text Format*.svf image/vnd.svf Simple Vector Format*.tif image/tiff Tagged Image Format File*.tiff image/tiff Tagged Image Format File*.txt text/plain Plain Text*.wdb application/vnd.ms-works MS Works Database*.wps application/vnd.ms-works Works Text Document*.xhtml application/xhtml+xml Extensible HyperText Markup Language*.xlc application/vnd.ms-excel MS Excel Chart*.xlm application/vnd.ms-excel MS Excel Macro*.xls application/vnd.ms-excel MS Excel Spreadsheet*.xlt application/vnd.ms-excel MS Excel Template*.xlw application/vnd.ms-excel MS Excel Workspace*.xml text/xml， application/xml Extensible Markup Language*.zip aplication/zip Compressed Archive]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页title左边显示网页的logo图标]]></title>
    <url>%2F2019%2F09%2F06%2Fhtml5%2F</url>
    <content type="text"><![CDATA[原文链接 步骤一:在图片中显示图标，这里的图片只支持ico格式，需要转换图片格式.原始图像可以接受: .jpg .jpeg .gif .png等图像格式 在这个网址上传你的原始图片然后生成ico格式图标(百度ico可以找到制作ico图标的网站) 注意：图标要用 16*16 的(保证了兼容性,无论在哪个地方都可以显示) 步骤二：把图标放到网站根目录 在&lt;head&gt;&lt;/head&gt;引入图标,网页标题左侧显示： &lt;link rel=&quot;icon&quot; href=&quot;图标地址&quot; type=&quot;image/x-icon&quot;/&gt; 收藏夹显示图标: &lt;link rel=&quot;shortcut icon&quot; href=&quot;图标地址&quot; type=&quot;image/x-icon&quot;&gt; 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;一个有梦想咸鸭蛋&lt;/title&gt; &lt;!--网页标题左侧显示--&gt; &lt;link rel="icon" href="1111.ico" type="image/x-icon"&gt; &lt;!--收藏夹显示图标--&gt; &lt;link rel="shortcut icon" href="1111.ico" type="image/x-icon"&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 建议把生成的图标名称改掉,在引用;如生成后是bitbug_favicon.ico改为你起的名字.ico.如果没有生效-关闭浏览器重新打开 怎么样获取别人的Logo 在网站首页 打开开发者工具;在Elements里&lt;head&gt;&lt;/head&gt;里找到link rel=&quot;icon&quot; href=&quot;图标名称.ico&quot; type=&quot;image/x-icon&quot;&amp;gt;点击右键在新标签页打开链接(Goolge是Open link in new tab)注意要在href的链接地址右键不然没有Open link in new tab这个选项。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多媒体]]></title>
    <url>%2F2019%2F09%2F06%2Fhtml4%2F</url>
    <content type="text"><![CDATA[什么是编解码器编码器的作用是读取特定的容器格式, 并对其中的音频与视频轨道进行解码, 然后实现播放.音频和视频原始数据比较大, 我们往往通过编码器对原始音频和视频文件进行有损压缩, 这样就便于在互联网上进行传输或播放。 常用的视频编解码器 H_246 H.264是MPEG-4标准所定义的最新格式, 同时也是技术含量最高、代表最新技术水平的视频编码格式之一,有的也称(AVC) , 目前是主流。 VP8 Google公司的产品 。VP8是一个免版权费用可自由使用的技术, 任何使用都不受版权限制, 使用的比较少 Ogg Theora OggTheora是 xiph.Org第一个公开发布的视频编解码器, 在 Ogg项目和 Ogg 流媒体服务器中使用 常用的音频编解码器 AAC 高级音频编码。相对于mp3, AAc格式的音质更佳,文件更小。 苹果、 诺基亚等公司的设备支持AAC格式 MP3 MP3是一种音频压缩技术, 其全称是动态影像专家压缩标准音频层面3,主要是在美国和日本, 不包括欧盟国家, 如微软更倾向于使用 MP3格式 Ogg Vorbis Ogg是指一种文件格式, 开源且免使用费, 就是为了与需要专利使用费的 M P3和AAc一争高下 代码定义: 播放音频12345&lt;audio controls="controls"&gt; &lt;source src="kk.mp4" type="audio/ogg"/&gt; &lt;source src="kk.mp4" type="audio/mpeg"/&gt; 您的浏览器不支持audio元素&lt;/audio&gt; 播放视频123&lt;video src="kk.mp4" controls="controls"&gt; 您的浏览器不支持audio元素&lt;/video&gt; 音频视频的相关属性 src 用于指定媒体资源的 URL地址 autoplay 该属性可以实现页面加载音频后一旦就绪即开始自动播放 buffered 用于返回一个TimeRanges对象, 确认浏览器已经缓存媒体文件 controls 可以为媒体文件提供用于播放的控制条,包含播放、暂停、定位、时间显示、音量控制、全房切换等常用控件 currentSrc 用于返回媒体数据的URL地址,如未指定地址,则返回一个空串 ourrentTime 用于获取或设置当前的播放位置,返回值为时间,单位为秒 defaultPlaybackRate 设置或返回音频/视频的默认播放速度 loop 设置或返回音频/视频是否应该在结束时重新播放 duration 用于获取当前媒体的持续时间 muted 设置或返回音频/视频是否应该被持音 (关闭声音) networkState 返回音频/视频的当前网络状态 paused 检查视频是否己暂停 playbackRate 设置返回音频/视频的当前播放速度。 played played属性返回 TimeRanges对象。TimeRanges 对象表示用户已经播放或看到的音频/视频范围 preload 设置或返回是否在页面加载后立即加载音频/视频 readyState 返回音频/视频的当前就绪状态 seekable 返回 TimeRanges 对象。表明可以对当前媒体资源进行请求 volume 属性设置或返回音频/视频的当前音量。必须是介于 0.0与1.0 之间的数字 seeking 返回用户目前是否正在音频/视频中请求数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;音频、视频相关属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick="getFirstBuffRange()" type="button"&gt;获得第一个缓冲范围&lt;/button&gt;&lt;button onclick="getVid()" type="button"&gt;获得当前视频URL&lt;/button&gt;&lt;br&gt;&lt;button onclick="getCurTime()" type="button"&gt;获取视频当前播放时间&lt;/button&gt;&lt;button onclick="setCurTime()" type="button"&gt;设置视频播放时间点&lt;/button&gt;&lt;br&gt;&lt;button onclick="getPlaySpeed()" type="button"&gt;获取视频默认播放速度&lt;/button&gt;&lt;button onclick="setPlaySpeed()" type="button"&gt;设置视频播放速度&lt;/button&gt;&lt;br&gt;&lt;button onclick="getVidDur()" type="button"&gt;获取视频的播放长度&lt;/button&gt;&lt;br&gt;&lt;!--播放视频--&gt;&lt;button onclick="enableLoop()" type="button"&gt;设置循环&lt;/button&gt;&lt;button onclick="disableLoop()" type="button"&gt;取消循环&lt;/button&gt;&lt;button onclick="checkLoop()" type="button"&gt;是否循环&lt;/button&gt;&lt;br&gt;&lt;button onclick="enableMute()" type="button"&gt;设置静音&lt;/button&gt;&lt;button onclick="disableMute()" type="button"&gt;取消静音&lt;/button&gt;&lt;button onclick="checkMute()" type="button"&gt;是否静音&lt;/button&gt;&lt;br&gt;&lt;button onclick="getNWState()" type="button"&gt;获取网络状态&lt;/button&gt;&lt;button onclick="isVidPaused()" type="button"&gt;视频是否暂停&lt;/button&gt;&lt;br&gt;&lt;button onclick="getPlaySpeed()" type="button"&gt;获取视频速度&lt;/button&gt;&lt;button onclick="setPlaySpeed()" type="button"&gt;减慢视频速度&lt;/button&gt;&lt;br&gt;&lt;button onclick="getFirstPlayedRange()" type="button"&gt;获得首段播放的范围&lt;/button&gt;&lt;br&gt;&lt;button onclick="enablePreload()" type="button"&gt;设置预加载&lt;/button&gt;&lt;button onclick="disablePreload()" type="button"&gt;取消预加载&lt;/button&gt;&lt;button onclick="checkPreload()" type="button"&gt;检查预加载状态&lt;/button&gt;&lt;br&gt;&lt;button onclick="getReadyState()" type="button"&gt;获取视频的就绪状态&lt;/button&gt;&lt;br&gt;&lt;button onclick="getFirstSeekableRange()" type="button"&gt;获得第一次可寻址范围&lt;/button&gt;&lt;br&gt;&lt;button onclick="getVolume()" type="button"&gt;获取当前音量&lt;/button&gt;&lt;button onclick="setHalfVolume()" type="button"&gt;设置当前音量为0.2&lt;/button&gt;&lt;button onclick="setFullVolume()" type="button"&gt;设置当前音量为1.0&lt;/button&gt;&lt;br&gt;&lt;video controls="controls" id="my_video" width="320" height="240" autoplay="autoplay"&gt; &lt;source id="mp4_src" src="kk.mp4" type="video/mp4"/&gt; &lt;source id="ogg_src" src="kk.mp4" type="video/ogg"/&gt; 您的浏览器不支持video元素&lt;/video&gt;&lt;script&gt; let myVideo = document.getElementById("my_video"); //获得第一个缓冲范围 function getFirstBuffRange() &#123; alert("Start:" + myVideo.buffered.start(0) + "End:" + myVideo.buffered.end(0)); &#125; //获得当前视频URL function getVid() &#123; alert(myVideo.currentSrc); &#125; //获取视频当前播放时间 function getCurTime() &#123; alert(myVideo.currentTime); &#125; // 设置视频播放时间点 function setCurTime() &#123; myVideo.currentTime = 5; &#125; //获取视频的播放长度 function getVidDur() &#123; alert(myVideo.duration); &#125; //是否循环 function checkLoop() &#123; alert(myVideo.loop); &#125; //设置循环 function enableLoop() &#123; myVideo.loop = true; myVideo.load(); &#125; //取消循环 function disableLoop() &#123; myVideo.loop = false; myVideo.load(); &#125; //设置静音 function enableMute() &#123; myVideo.muted = true; &#125; //取消静音 function disableMute() &#123; myVideo.muted = false; &#125; //是否静音 function checkMute() &#123; alert(myVideo.muted); &#125; //获取网络状态 function getNWState() &#123; alert(myVideo.networkState);/* 表示音频/视频元素的当前网络状态： 0 = NETWORK_EMPTY - 音频/视频尚未初始化 1 = NETWORK_IDLE - 音频/视频是活动的且已选取资源，但并未使用网络 2 = NETWORK_LOADING - 浏览器正在下载数据 3 = NETWORK_NO_SOURCE - 未找到音频/视频来源 */ &#125; //视频是否暂停 function isVidPaused() &#123; alert(myVideo.paused); &#125; //获取视频速度 function getPlaySpeed() &#123; alert(myVideo.playbackRate); &#125; //减慢视频速度 function setPlaySpeed() &#123; myVideo.playbackRate = 0.5; &#125; //获得视频中以秒计的首段已播放的范围 function getFirstPlayedRange() &#123; alert("Start:" + myVideo.played.start(0) + "End:" + myVideo.played.end(0)); &#125; //设置预加载(是否在页面加载后立即加载音频/视频) function enablePreload() &#123; myVideo.preload = "auto"; &#125; //取消预加载 function disablePreload() &#123; myVideo.preload = "none"; &#125; //检查预加载状态 function checkPreload() &#123; alert(myVideo.preload); &#125; //获取视频的就绪状态 function getReadyState() &#123; alert(myVideo.readyState); &#125; //TimeRanges 对象表示音频/视频中用户可寻址的范围（可拖动缓存播放的位置） function getFirstSeekableRange() &#123; alert("Start:" + myVideo.seekable.start(0) + "End:" + myVideo.seekable.end(0)); &#125; //获取当前音量 function getVolume() &#123; alert(myVideo.volume); &#125; //设置当前音量为1.0 function setFullVolume() &#123; myVideo.volume = 1.0; &#125; //设置当前音量为0.2 function setHalfVolume() &#123; myVideo.volume = 0.2; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 音频视频相关方法 canPlayType() 检测测览器是否能播放指定的音频/视频类型 canPlayType() 方法可返回下列值之一:“probably” -浏览器最可能支持该音频/视频类型“maybe” - 浏览器也许支持该音频/视频类型 “” - (空字符串) 浏览器不支持该音频/视频类型 load() 重新加载音频/视频元素. load() 方法用于在更改来源或其他设置后对音频/视频元素进了更新 pause() 停止(暂停)当前播放的音频或视频 play() play()方法开始播放当前的音频或视频。 所有主流浏览器都支持 play() 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;音频、视频相关方法&lt;/title&gt; &lt;script&gt; let myVideo = null; //检测浏览器是否对视频资源支持 function supportType(vidType, codeType) &#123; let myVid = document.createElement("video"); let isSupp = myVid.canPlayType(vidType + ';codecs="' + codeType + '"'); if (isSupp === "") &#123; isSupp = "No"; &#125; alert(isSupp); &#125; //切换视频资源 function changeSource() &#123; document.getElementById("mp4_src").src = "kk1.mp4"; document.getElementById("ogg_src").src = "kk1.mp4"; document.getElementById("my_video").load(); &#125; //播放视频 function playVid() &#123; myVideo = document.getElementById("my_video"); myVideo.play(); &#125; //暂停视频 function pauseVid() &#123; myVideo = document.getElementById("my_video"); myVideo.pause(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;浏览器是否支持播放MP4视频&lt;/p&gt;&lt;button onclick="supportType('video/mp4','avc1.42E01E,mp4a.40.2')" type="button"&gt;Test&lt;/button&gt;&lt;p&gt;浏览器是否支持播放ogg视频&lt;/p&gt;&lt;button onclick="supportType('video/ogg','theora,vorbis')" type="button"&gt;Test2&lt;/button&gt;&lt;br&gt;&lt;button onclick="changeSource()" type="button"&gt;切换视频资源&lt;/button&gt;&lt;br&gt;&lt;button onclick="playVid()" type="button"&gt;播放视频&lt;/button&gt;&lt;br&gt;&lt;button onclick="pauseVid()" type="button"&gt;暂停视频&lt;/button&gt;&lt;br&gt;&lt;video controls="controls" id="my_video" width="320" height="240"&gt; &lt;source id="mp4_src" src="kk.mp4" type="video/mp4"/&gt; &lt;source id="ogg_src" src="kk.mp4" type="video/ogg"/&gt; 您的浏览器不支持video元素&lt;/video&gt;&lt;/body&gt;&lt;/html&gt; 音频视频的相关事件 pause 在音频/视频暂停时触发 play 在音频/视频开始播放时触发 playing 在音频/视频因缓冲而暂停或停止后已就绪时触发 ratechange 在音频/视频播放速度发生改变时触发(如用户切换到慢速或快速播放模式) seeked 在用户己移动/跳成到音频/视频中的新位置时触发 seeking 在用户开始移动/跳跌到新的音频/视频播放位置时触发 stalled 在浏览器尝试获取媒体数据, 但数据不可用时触发 suspend 在浏览器刻意不加载媒体数据时触发 timeupdate 在音频/视频的播放位置发生改变时触发 volumechange 在音频/视频的音量发生改变时触发 waiting 在视频由于需要缓下一帧而停止时触发 canplay 当浏览器能够开始播放指定的音频/视频时,会发生 canplay事件 canplaythrough 当浏览器预计能够在不停下来进行缓冲的情况下持续播放指定的音频/视频时,会发生 oanpIaythrough事件 durationchange 当指定音频/视频的时长数据发生变化时 loadeddata 当当前帧的数据已加载, 但没有足够的数据来播放指定音频/视频的下一帧时 loadedmetadata 当指定的音频/视频的元数据已加载时,会发生此事件。音频/ 视频的元数据包括:时长、尺寸(仅视频)以及文本轨道 loadstart 当浏览器开始寻找指定的音频/视频时 progress 当浏览器正在下载指定的音频/视频 abort 在音频/视频(audio/video)终止加载时触发 ended 在音频/视频(audio/video)播放完成后触发 error 在音频/视频(audio/video)加载发生错误时触发]]></content>
      <categories>
        <category>HTML</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增form元素或属性]]></title>
    <url>%2F2019%2F09%2F06%2Fhtml3%2F</url>
    <content type="text"><![CDATA[新增的form元素 新增的datal ist元素 data l ist元素用于为输入提供一个可选的列表, 用户可以直接选择列表中的某一选项, 从而免去了输入的麻烦 。123456请输入网址: &lt;input aria-label="tt" type="text" list="url_list" /&gt; &lt;datalist id="url_list"&gt; &lt;option label="新浪" value="http://www.sina.com.cn"&gt;&lt;/option&gt; &lt;option label="搜狐" value="http://www.souhu.com"&gt;&lt;/option&gt; &lt;option label="网易" value="http://www.163.com"&gt;&lt;/option&gt;&lt;/datalist&gt; 新增的keygen元素 keygen元素是秘钥对生成器, 能够使用户验证更为可靠。 用户提交表单时会生成两个键,一个私钥,一个公钥,私钥保存客户端而公钥会发送到服务端。 (浏览器兼容性差,目测在火狐上可显示,其他不支持) 1请选择加密强度: &lt;keygen name="security"/&gt; 新增的output元素 output元素用于浏览器中显示计算结果或脚本输出, 包含完整的开始和结束标签。 语法: &lt;output name=&quot;&quot;&gt;text&lt;/output&gt; 12345678910111213&lt;script&gt; function multi()&#123; let a, b; a = parseInt(prompt("请输入第一个数字")); b=parseInt(prompt("请输入第二个数字")); document.forms["form"]["result"].value=a*b; &#125;&lt;/script&gt;&lt;body onload="multi()"&gt;&lt;form action="#" method="get" name="form"&gt;两数的乘积为:&lt;output name="result"&gt;&lt;/output&gt;&lt;/form&gt; 新增的form属性 新增的autocomplete属性 当此属性用于form元素时, 所有从属于该form的元素都具备自动完成功能。 如果要使用个别元素关闭自动完成功能, 则单独为该元素指定autocomplete=“off”即可。 1请输入用户名:&lt;input type="text" name="user_name" autocomplete="on"/&gt; 新增的novalidate属性 此属性用于提交表单时取消整个表单的验证, 即关闭对表单内所有元素的有效检查 。 如果只取消表单中较少部分内容的验证而不一妨碍提交的大部分内容, 则可以将此属性单独用于表单中的这些元素。 1234567&lt;form action="#" enctype="application/x-www-form-urlencoded" id="testform" method="get" novalidate&gt; 请输入电子邮件地址:&lt;input type="email" name="userid"&gt;&lt;br&gt; &lt;input type="submit" value="formaction" formaction="http://www.souhu.com"/&gt; &lt;!--修改跳转的路径--&gt; &lt;input type="submit" value="formenctype" formenctype="multipart/form-data"/&gt; &lt;!-- 修改enctype类型--&gt; &lt;input type="submit" value="formmethod" formmethod="post"/&gt; &lt;!--修改请求的方式--&gt;novalidate&lt;===&gt; &lt;input type="submit" value="formnovalidate" formnovalidate="formnovalidate" &gt; &lt;!--表单验证是否开启--&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>HTML</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5相关内容]]></title>
    <url>%2F2019%2F09%2F06%2Fhtml2%2F</url>
    <content type="text"><![CDATA[HTML5文档有如下结构12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 页面内容 &lt;/body&gt;&lt;/html&gt; 注意: 不要在&lt;html&gt;和&lt;head&gt;之间插入任何内容 不要在&lt;head&gt;和&lt;body&gt;之间插入任何内容 不要在&lt;body&gt;和&lt;html&gt;之间插入任何内容 HTML5语法变化 标签不区分大小写 元素可以省略结束标签 允许省略属性的属性值 允许属性不使用引号 提示: HTML5的语法变化主要是为兼容互联网上成千上万的不遵守HTML语法规范的网站,所以可以认为HTML5制定的是一种”妥协式”的规范. 新增的常用语义性元素 mark 定义带有记号的文本,需要突出显示文本时使用&lt;mark&gt;标签 progress 标签定义运行中的任务进度(进程) time 表示时间日期值 details 此标签规定了用户可见的或者隐藏的需求的补充细节 datalist 定义选项列表。请与input元素配合使用该元素,来定义input可能的值。 ruby 此标签定义 ruby注释,往往与&lt;rt&gt;和&lt;rp&gt;标签一起配合使用 menu 表示菜单列表 command 可以定义用户可能调用的命令(比如单选按钮、复选框或按钮) 新增的结构性元素 section 定义文档中的节。比如章节、页眉、页脚或文档中的其它部分。一般用于成节的内容, 会在文档流中开始一个新的节 article 它是一个特殊的sect i on标签, 它比sect i on具有更明确的语义, 它代表一个独立的,完整的相关内容块, 可独立于页面其它内容使用 nav 此标签代表页面的一个部分, 表示页面中导航链接的部分 aside 它用来装载非正文的内容, 被视为页面里面一个单独的部分。它包含的内容与页面的主要内容是分开的, 可以被删除, 而不会影响到网页的内容、章节或是页面所要传达的信息 hgroup 是对网页或区段section的标题元素 (h1-h6) 进行组合 footer 它定义section或文档的页脚, 包含了与页面、 文章或是部分内容有关的信息 header 定义文档的页眉, 通常是一些引导和导航信息。它不局限于写在网页头部, 也可以写在网页内容里面 figure 用于对元素进行组合。多用于图片与图片描述组合 新增的input输入类型 list 属性引用&lt;datalist&gt;元素,其中包含&lt;input&gt;元素的预定义选项 新增的miN,max和step属性 min:规定输入框所输入的最小值,max:规定输入框所输入的最大值,step:为输入框规定合法的数字间隔 multiple 属性规定允许用户输入到 &lt;input&gt; 元素的多个值 pattern 规定用于验证 &lt;i nput&gt; 元素的值的正则表达式 pIaceholder 规定可指述输入&lt;input&gt; 字段预期值的简短的提示信息 required 规定必需在提交表单之前填写输入字段 autocomptete 规定&lt;input&gt;元素输入字段是否应该启用自动完成功能 autofocus 规定当页面加载时&lt;input&gt;元素应该自动获得焦点 form 规定 &lt;input&gt; 元素所属的一个或多个表单 formaction 规定当表单提交时处理输入控件的文件的 url formenctype 规定当表单数据提交到服务器时如何编码 formmethod 定义发送表单数据到 actionURL的 HTTP方法 formtarget 规定表示提交表单后在哪里显示接收到响应的名称或关键词 formnovalidate 覆盖&lt;form&gt;元素的写属性novalidate属性 除了formnovalidate属性 其它属性都是只针对 type=”submit”和 type=”image” 新增的height和width属性 规定&lt;input&gt;元素的高度(只针对type=”image”) email 定义用于 email地址的字段 url 定义用于输入 URL的字段 number 定义用于输入数手的手段 range 定义用于精确值不重要的输入数手的控件 Date Pickers 定义 date控件。month:定义 month和 year控件(不带时区) 。 week:定义 week和 year控件。 time:定义用于输入时间的控件。 datetime:定义 date和 time控件,基于uTC时区。datetime-looal:定义 date和 time控件, 不带时区 search 定义用于输入捜索字符串的文本字段 tel 定义用于输入电话号码的字段 color 定义拾色器 HTML5废除的相关元素 能用css代替的元素, 比如:basefont、 big、 center、 font、 s、strike、 tt、 u。 不再使用frame框架, frameset、 frame、 noframes。 HTML5中不支持frame框架, 只支持 iframe框架 。 只有部分刘览器支持的元素, applet、 bgsound、 bl ink、 marquee等标签。 其他被废除的元素, 比如:废除rb使用ruby替代、废除acronym使用abbr替代、废除dir使用ul替代、废除listing使用pre替代等。]]></content>
      <categories>
        <category>HTML</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas相关内容]]></title>
    <url>%2F2019%2F09%2F06%2Fhtml1%2F</url>
    <content type="text"><![CDATA[认识Canvas元素 canvas是HTML5新增的专门用来绘制图形的元素, 通过Canvas技术, 用户可以在Web中绘制各种图形. canvas元素它是一块无色透明的区域, 它只是一个容器, 开发者通过JavaScript脚本可以轻松的在区域上实现任意绘图 在页面中添加canvas元素 1234567&lt;html &gt;&lt;body&gt;&lt;canvas id="myCanvas" width="578" height="200"&gt;您的浏览器不支持oanvas元素, 请更新或更换您的浏览器.&lt;/canvas&gt;&lt;/body&gt;&lt;/html &gt; Canvas绘制步骤 在html5页面中添加canvas元素, 定义 id属性值以便接下来调用 1&lt;canvas id="myCanvas" width="578" height="200"&gt;&lt;/canvas&gt; 使用 id寻找页面中的canvas元素 1var c=document.getElementById("myCanvas"); 通过canvas元素的getContext方法来获取其上下文(Context) ,即创建Context对象, 以获取允许进行绘制的2D环境。 1var context=c.getContext("2d"); 使用 JavaScript脚本来进行绘制 12context.fillStyle='#ff0000';context.fillRect(50,25,100,50); 绘制直线相关的方法 beginPath() 定义了一个新的路径绘制动作的开始 moveTo() 为指定点创建了一个新的子路径, 这个点就变成了新的上下文点,我们可以把moveTo() 方法看成用来定位我们的绘图鼠标用的 lineTo() 以上下文点为起点, 到方法参数中指定的点之间函一条直线 stroke() 为所画的线赋予颜色, 并使其可见.如果没有特别的指定颜色的,则默认使用黑色画直线 绘制直线的相关属性 lineWidth 直线的宽度 strokeStyle 直线的颜色 直线端点样式 HTML5canvas支持3种i线的端点样式, 包括:butt,round,round 和 square.设定端点样式是用lineGap属性设定.缺省情况下,将使用butt样式 绘制矩形 绘制矩形使用rect()方法。每个短形需要由左上角坐标(x, y) 和矩形的宽与高 (width,height)来确定。 绘制圆 画圆只需要在调用arc()方法时,将起始角度设为0,终止角度设为2 * Pl即可。 图形的颜色填充 要填充图形,需要用filIStyIe属性设五填充图形用的颜色,然后使用fill()方法完成对图形的填充。默认情况下,fillStyle的颜色是黑色。 123456789101112131415161718192021222324&lt;script&gt; window.onload=function ()&#123; let canvas=document.getElementById("myCanvas"); let context=canvas.getContext("2d");//绘制矩形 context.beginPath(); context.rect(10,50,200,100); context.lineWidth=5;//线的粗细 context.strokeStyle="blue";//线的颜色 context.stroke(); context.fillStyle="blue";//填充的颜色 context.fill();//填充//绘制圆 context.beginPath(); //圆心的坐标 let centerX=canvas.width/1.5; let centerY=canvas.height/2; let radius=80;//半径 context.arc(centerX,centerY,radius,0,1.5*Math.PI,false); //true逆时针 false顺时针 context.lineWidth=5;//线的粗细 context.strokeStyle="black";//线的颜色 context.stroke(); &#125;&lt;/script&gt; 绘制文本 绘制文本的方法 context.fillText(Text,x1, y1) 其中text是要绘制的文本, x1 , y1是绘制文本的位置。 设置文本的字体、大小和样式 要设置字体、大小和样式,需要用到上下文对象的 font属性。样式可以是normal,itaIic或bold.默认情况是 normal 。 设置文本颜色 文本的颜色用fillStyle属性设置 描绘文本边缘 要描绘字体边缘的效果,要使用 strokeText()方法替代filIText(), 同时要用strokeStyle属性替代 filIStyIe属性。 12345678910111213&lt;script&gt; window.onload = function () &#123; let canvas = document.getElementById("myCanvas"); let context = canvas.getContext("2d"); let x = canvas.width / 2; let y = canvas.height / 2; context.font = "italic 40px Arial"; context.fillStyle = "#ff0000"; context.fillText("Hello World", x, y); context.lineWidth = 2; context.strokeText("Hello World", x, y + 50); &#125;&lt;/script&gt; 绘制文本对齐 文本的对齐功能设定使用 textAlign属性。其可用的选项包括start, end, left, center和 right。 文本度量 要获取有关文本的尺度信息,可以使用 measureText()方法。此方法需要一个文本字符串组为参数, 并返回一个尺度对象.尺度对象中的数据是基于所提供的字符串参数和当前的文本字体信息而来的. 文本换行 要实现文本换行功能, 我们需要创建一个用户自定义函数, 此函数需要canvas上下文对象,一个文本字符串、一个位置、一个最大宽度和行高度信息.函数将使用 measureText()计算何时换行。 12345678910111213141516171819202122232425262728293031&lt;script&gt; window.onload = function () &#123; let canvas = document.getElementById("myCanvas"); let context = canvas.getContext("2d"); let text = "They say a person needs just three things to be truly happy in this world: someone to love, something to do, and something to hope for."; let maxWidth = 300;//每一行绘制的长度,超过就换行 let lineHeight = 25;//设置行之间的间隔 let x = (canvas.width - maxWidth) / 2;//绘制起始坐标 let y = 30; context.font = "16px Arial"; context.fillStyle = "#000fff"; wrapText(context, text, x, y, maxWidth, lineHeight); &#125;; function wrapText(context, text, x, y, maxWidth, lineHeight) &#123; let words = text.split(" ");//以空格把字符串分割并存到数组里 let line = ""; for (let n = 0; n &lt; words.length; n++) &#123; let testLine = line + words[n] + " "; let metrics = context.measureText(testLine); let testWidth = metrics.width;//得到测量字符的宽度 if (testWidth &gt; maxWidth) &#123; context.fillText(line, x, y); line = words[n] + " "; //重新给line赋值,绘制下一行 y += lineHeight;//y坐标要加上行高,在上一行的下方绘制,避免绘制的内哦平重叠 &#125; else &#123; line = testLine; &#125; &#125; context.fillText(line, x, y);//绘制文本 &#125;&lt;/script&gt; 据说一个人在这个世上获得真正的幸福需要三件事情：有人爱，有事做，有所期待。 123456789101112131415161718192021222324252627&lt;script&gt; window.onload=function ()&#123; let canvas=document.getElementById("myCanvas"); let context=canvas.getContext("2d"); //绘制弧线 context.beginPath(); context.moveTo(20,20); context.lineTo(100,20); context.arcTo(150,20,150,70,50); context.lineTo(150,120); context.stroke(); context.beginPath(); context.moveTo(100,20); //第一条直线 context.lineTo(200,160); //二次曲线 context.quadraticCurveTo(230,200,250,120); //贝塞尔曲线 context.bezierCurveTo(290,-40,300,200,400,150); //第二条直线 context.lineTo(500,90); context.lineWidth=5; context.strokeStyle="blue"; context.stroke(); &#125; &lt;/script&gt; 绘制径向渐变 首先使用 createRadiaIGradient()方法创建canvasGradient对象, 语法如下: var grad=context.createRadialGradient(X1,Y1,R1,X2,Y2, R2); 其中X1,Y1,R1定义一个以(X1, Y1)为原点、半径为R1的国。 X2,Y2,R2定义一个以(X2, Y2)为原点、半径为R2的圆。然后使用 addColorStop方法定义色标的位置并上色 。grad. addColorStop(position, color) ;其中参数position为渐变中色标的相对位置 (偏移量) 绘制线性渐变 首先使用 createLinearGradient()方法创建canvasGradient对象, 语法如下: var grad=context.createLinearGradient(X1, Y1, X2, Y2); 其中X1、 Y1为渐变的起点, X2、 Y2为渐变的终点。然后使用 addColorStop方法定义色标的位置并上色 grad. addColorStop(position, color) ;其中参数position为渐变中色标的相对位置 (偏移量) 123456789101112131415161718192021&lt;script&gt; window.onload=function()&#123; let c=document.getElementById("myCanvas"); let context=c.getContext("2d"); //线性渐变 let clg=context.createLinearGradient(0,0,100,200); clg.addColorStop(0,"#ff0000"); clg.addColorStop(0.5,"#00ff00"); clg.addColorStop(1,"#0000ff"); context.fillStyle=clg; context.strokeStyle=clg; context.fillRect(10,10,200,200); //径向渐变 let crg=context.createRadialGradient(325,100,20,325,100,80); crg.addColorStop(0,"#ffffff"); crg.addColorStop(0.75,"#ff0000"); crg.addColorStop(1,"#000000"); context.fillStyle=crg; context.fillRect(230,10,200,200); &#125;&lt;/script&gt; 绘制图像的方法 context.drawlmage(imageObj, x,y); 此方法需要一个图像对象和一个起始点坐标作为参数, 其中起始点坐标是相对于canvas的左上角的位置 context. drawlmage(imageObj, x, y, width, height); drawlmage方法还可以接受 width和 height两个参数用来以任意指定的尺寸显示图像。 context. drawlmage(imageObj,sx,sy,sw, sh, dx, dy, dw, dh); drawlmage方法还可以增加另六个参数来实现对图像的裁剪 。 这六个参数是 sourceX,sourceY, sourGeWidth, sourceHeight,destWidth和destHeight。 12345678910111213&lt;script&gt; window.onload=function()&#123; let c=document.getElementById("myCanvas"); let context=c.getContext("2d"); let image=new Image(); image.src="icon.png"; image.onload=function()&#123; context.drawImage(image,10,10);//原始图片的大小 context.drawImage(image,10,10,200,200);//绘制图片的大小 context.drawImage(image,50,40,300,450,50,50,350,450);//裁剪后的图像 &#125; &#125;&lt;/script&gt; 绘制阴影 要为图形添加明影需要用到: shadowColor:阴影颜色 shadowB1ur:阴影模糊度 shadowOffsetX:设置或返回阴影与形状的水平距高 shadowOffsetY:设置或返回阴影与形状的垂直距高 绘制透明度 globalAlpha属性设置或还回绘图的当前透明值.属性值必须是介于0.0(完全透明)与1.0(不透明)之间的数字。 12345678910111213141516171819202122232425 &lt;script&gt; window.onload=function ()&#123; let canvas=document.getElementById("myCanvas"); let context=canvas.getContext("2d"); //绘制圆 context.beginPath();//圆心的坐标 let centerX=canvas.width/1.5; let centerY=canvas.height/2; let radius=80;//半径 context.arc(centerX,centerY,radius,0,2*Math.PI,false); //true逆时针 false顺时针 context.lineWidth=5;//线的粗细 context.strokeStyle="black";//线的颜色 context.stroke(); context.fillStyle="#8ED6FF";//设置填充色 //设置阴影 context.shadowColor="green"; context.shadowBlur=20; context.shadowOffsetX=10; context.shadowOffsetY=10; //设置透明度 context.globalAlpha=0.2; context.fill(); &#125; &lt;/script&gt; 绘制图案填充 用上下文对象的 createPattern()方法创建一个图案填充对象, 语法如下: context.createPattern(image, type); 其中type必须为下面字符串之一: repeat、 repeat-x、 repeat-y、 no-repeat 123456789101112131415161718192021&lt;script&gt; function draw(type)&#123; let c=document.getElementById("myCanvas"); let canvas=c.getContext("2d"); canvas.clearRect(0,0,500,400); let img=document.getElementById("butterfly"); let pat=canvas.createPattern(img,type); canvas.rect(0,0,500,400); canvas.fillStyle=pat; canvas.fill(); &#125; &lt;/script&gt;&lt;body&gt;&lt;p&gt;图像的使用:&lt;/p&gt;&lt;img src="icon.png" id="butterfly"/&gt;&lt;br&gt;&lt;button onclick="draw('repeat')"&gt;Repeat&lt;/button&gt;&lt;button onclick="draw('repeat-x')"&gt;Repeat-x&lt;/button&gt;&lt;button onclick="draw('repeat-y')"&gt;Repeat-y&lt;/button&gt;&lt;button onclick="draw('no-repeat')"&gt;no-repeat&lt;/button&gt;&lt;canvas id="myCanvas" width="500" height="400"&gt;&lt;/canvas&gt;&lt;/body&gt; 图形的变换 移动坐标空间 使用 translate() 方法可以将绘图原点横向和纵向的移动到指定的距离(x, y),结果表现为整张图像的移动。 旋转坐标空间 旋转canvas用的方法是 rotate()。此方法接受一个以弧度为单位的旋转参教,整个canvas将以坐标原点,也就是由 transIate()所确定的原点为圆心进行旋转。 缩放图形 缩放操作使用 scale()方法,参数x、 y分别代表横向与纵向的缩放比例, 两个参数都是浮点数, 1. 0表示不缩放, 小于1. 0表示缩小,大于1. 0表示放大。 12345678910111213141516&lt;script&gt; window.onload = function () &#123; let canvas = document.getElementById("myCanvas"); let context = canvas.getContext("2d"); let rectWidth=150; let rectHeight=75; context.fillStyle="#ff0000"; //把坐标原点移动到canvas中心点 context.translate(canvas.width/2,canvas.height/2); //顺时针旋转45度 context.rotate(0.25*Math.PI); //坐标在纵向上缩小一半 context.scale(1,0.5); context.fillRect(-rectWidth/2,-rectHeight/2,rectWidth,rectHeight); &#125;&lt;/script&gt; 保存与恢复canvas状态 使用save()和 restore()方法可以实现对坐标变换状态的保存与恢复。 1234567891011121314151617181920212223242526&lt;script&gt; window.onload = function () &#123; let canvas = document.getElementById("myCanvas"); let context = canvas.getContext("2d"); //所绘制矩形的宽度和高度 let rectWidth = 150; let rectHeight = 75; context.save();//保存状态1(坐标0,0) context.translate(canvas.width / 2, canvas.height / 2); context.save();//保存状态2(坐标移动到画布中间) context.rotate(Math.PI / 4); context.save();//保存状态3 (按中心点旋转45) context.scale(2, 2);//矩形宽度和高度增加2倍 context.fillStyle = "blue"; context.fillRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight); context.restore();//回复状态3 context.fillStyle = "red"; context.fillRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight); context.restore();//回复状态2 context.fillStyle = "yellow"; context.fillRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight); context.restore();//回复状态1 context.fillStyle = "green"; context.fillRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight); &#125;&lt;/script&gt; 图形的组合 globalCompositeOperation 属性设置或返回如何将一个源 (新的) 图像绘制到日标(已有的)的图像上。 属性值如下: source-over 默认。在目标图像上显示源图像 source-atop 在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的 source-in 在目标图像中显示源图像。只有目标图像之内的源图像部分会显示, 目标图像是透明的 source-out 在 目标图像之外显示源图像.只有目标图像之外的源图像部分会显示,目标图像是透明的 destination-over 在源图像上显示目标图像 destination-atop 在源图像顶部显示目标图像。目标图像位于源图像之外的部分是不可见的 destination-in 在源图像中显示目标图像。只有源图像之内的目标图像部分会被显示, 源图像是透明的 destination-out 在源图像之外显示目标图像。只有源图像之外的目标图像部分会被显示, 源图像是透明的 lighter 显示源图像+ 目标图像,交叉处高亮显示 darker 显示源图像+目标图像 copy 显示源图像。忽略目标图像 xor 使用异或操作对源图像与目标图像进行组合。 红色源图像 蓝色目标图像 1234567891011121314151617181920212223242526&lt;script&gt; window.onload = function () &#123; let canvas = document.getElementById("myCanvas"); let context = canvas.getContext("2d"); //绘制矩形 context.beginPath(); context.rect(200, 20, 100, 100); context.fillStyle = "blue"; context.fill(); context.globalCompositeOperation = "source-over"; context.globalCompositeOperation = "source-atop"; context.globalCompositeOperation = "source-in"; context.globalCompositeOperation = "destination-in"; context.globalCompositeOperation = "destination-out"; context.globalCompositeOperation = "lighter"; context.globalCompositeOperation = "darker"; context.globalCompositeOperation = "xor"; context.globalCompositeOperation = "copy"; //绘制圆 context.beginPath(); context.arc(320, 120, 60, 0, 2 * Math.PI, false); context.fillStyle = "red"; context.fill(); &#125;&lt;/script&gt; 图形的裁切 clip()方法从原始画布中剪切任意的形状和尺寸 。 提示: 一旦剪切了某个区域, 则所有之后的绘图都会被限制在被剪切的区域内 (不能访问画布上的其他区域) 。 您也可以在使用 clip()方法前通过使用 save()方法对当前画布区域进行保存, 并在以后的任意时间对其进行恢复(通过 restore()方法) 。 12345678910111213141516171819202122232425262728 &lt;script&gt; window.onload = function () &#123; let canvas = document.getElementById("myCanvas"); let context = canvas.getContext("2d"); context.rect(50, 20, 200, 120); context.stroke(); context.fillStyle = "red"; context.fillRect(0, 0, 150, 100); let canvas1 = document.getElementById("myCanvas2"); let context1 = canvas1.getContext("2d"); context1.rect(50, 20, 200, 120); context1.stroke(); context1.clip();//裁切 context1.fillStyle = "red"; context1.fillRect(0, 0, 150, 100); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span&gt;没有裁切之前:&lt;/span&gt;&lt;br&gt;&lt;canvas id="myCanvas" width="300" height="150"&gt; 您的浏览器不支持HTML5 canvas标签&lt;/canvas&gt;&lt;span&gt;裁切之后:&lt;/span&gt;&lt;canvas id="myCanvas2" width="300" height="150"&gt; 您的浏览器不支持HTML5 canvas标签&lt;/canvas&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>HTML</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS使图片居中的三种方法]]></title>
    <url>%2F2019%2F09%2F06%2Fcss3%2F</url>
    <content type="text"><![CDATA[参考链接 利用display:table-cell 123&lt;div class="img_wrap"&gt; &lt;img src="wgs.jpg"&gt;&lt;/div&gt;12345678.img_wrap&#123; width: 400px; height: 300px; border: 1px dashed #ccc; display: table-cell; //主要是这个属性 vertical-align: middle; text-align: center; &#125; 采用背景法 1&lt;div class="img_wrap"&gt;&lt;/div&gt; 123456.img_wrap&#123; width: 400px; height: 300px; border: 1px dashed #ccc; background: url(wgs.jpg) no-repeat center center;&#125; 图片外面用个p标签,通过设置line-height使图片垂直居中 123&lt;div class="img_wrap"&gt; &lt;p&gt;&lt;img src="wgs.jpg"&gt;&lt;/p&gt; &lt;/div&gt; 12345678910111213141516*&#123;margin: 0px;padding: 0px&#125; .img_wrap&#123; width: 400px; height: 300px; border: 1px dashed #ccc; text-align: center;&#125; .img_wrap p&#123; width:400px; height:300px; line-height:300px; /* 行高等于高度 */ &#125; .img_wrap p img&#123; *margin-top:expression((400 - this.height )/2); /* CSS表达式用来兼容IE6/IE7 */ vertical-align:middle; border:1px solid #ccc; &#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择器]]></title>
    <url>%2F2019%2F09%2F06%2Fcss4%2F</url>
    <content type="text"><![CDATA[CSS3属性选择器 E[att^=“val”] 属性att的值以“val”开头的元素 E[att$=“val”] 属性att的值以“val”结尾的元素 E[att*=“val”] 属性att的值包含“val”字符串的元素 123a[src^="https"] 选择其src属性值以 "https"开头的每个&lt;a&gt;元素a[src$=".pdf"] 选择其src属性以".pdf"结尾的所有&lt;a&gt;元素a[src*="abc"] 选择其src属性中包含 "abc"子串的每个&lt;a&gt;元素 CSS3结构伪类选择器 :root 选择匹配文档的根元素 E:nth-child(n) 选择所有在其父元素中的第n个位置的匹配E的子元素 E:nth-last-child(n) 选择所有在其父元素中倒数第n个位置的匹配E的子元素 E: nth-of-type(n) 选择所有在其父元素中同类型第 n个位置的匹配E的子元素 E: nth-last-of- type(n) 选择所有在其父元素中同类型倒数第n个位置的匹配E的子元素 E: last-child 选择位于其父元素中最后一个位置, 且匹配E的子元素 E: first-of-type 选择在其父元素中匹配E的第一个同类型子元素 E:Iast-of-type 选择在其父元素中匹配E的最后一个同类型子元素 E:onIy-child 选择其父元素只包含一个子元素, 且该子元素匹配E E: only-of-type 选择其父元素只包含一个同类型的子元素, 且该子元素匹配E E:empty 选择匹配E的元素, 且该元素不包含子元素 CSS3Ull为类选择器 E:enabled 选择匹配E的所有可用UI元素 E:disabled 选择匹配E的所有不可用UI元素 E:checked 选择匹配E的所有可用UI元素 E:read-write 选择匹配可读及可写的元素 E:read-only 选择匹配设置”readonly” (只读)属性的元素 E::selection 匹配元素中被用户选中或处于高亮状态的部分 E:out-of-range 用于标签的值在指定区间之外时显示的样式 E:in-range 用于标签的值在指定区间之内时显示的样式 E:optional 用于匹配可选的输入元素 E:required 用于匹配设置了”required”属性的元素 E:valid E:invalid 匹配输入值为合法、非法的元素 其它CSS3选择器 E~F:通用兄弟元素选择器 选择匹配F的所有元素,且匹配元素位于匹配E的元素后面 E:not(s) :否定伪类选择器 选择匹配E的所有元素, 且过滤掉匹配s选择符的任意元素。 E: not(s)选择器相当于二次过滤, 适合精确选择元素。 E:target:目标伪类选择器类型 选择器匹配E的所有元素,且匹配元素被相关URL指向 。该选择器是动态选择器, 只有当存在的URL指向该匹配的元素时,样式效果才能够起效。 .]]></content>
      <categories>
        <category>CSS</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置按钮的样式]]></title>
    <url>%2F2019%2F09%2F06%2Fcss1%2F</url>
    <content type="text"><![CDATA[原文链接 css属性访问链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107.btnstyle &#123;width: 86px;/*按钮控件的宽度*/text-align: center;/*按钮控件中文本居中显示*/line-height: 100%;/*用百分比设置行高*/padding-top: 0.5em;/*文本顶部的内边距*/padding-right: 2em;/*文本右侧的内边距*/padding-bottom: 0.55em;/*文本底部的内边距*/padding-left: 2em;/*文本左侧的内边距*/font-family: "Arial Black", Gadget, sans-serif;/*字体*/font-size: 14px;/*字体大小*/font-style: normal;/*字体样式*/font-variant: normal;/*小写字母*/font-weight: normal;/*文本不需要加粗*/text-decoration: none;/*文本不需要下划线等*/margin-top: 0px;/*外边框的距离*/margin-right: 2px;/*外边框的距离*/margin-bottom: 0px;/*外边框的距离*/margin-left: 2px;/*外边框的距离*/vertical-align: text-bottom;/*图像放在文本下面*/display: inline-block;/*段落内生出内框*/cursor: pointer;/*鼠标的形状*/zoom:1;/*normal|number 设置或检索对象的缩放比例(是IE浏览器的专有属性，Firefox等浏览器不支撑) */outline-width:medium;/*整个轮廓的宽度*/outline-color:inherit;/*轮廓的颜色*/font-size-adjust:none;/*number|none|inherit 控制字体大小 (只有Firefox支持)*/font-stretch:normal;/*允许你使文字变宽或变窄 (目前没有主流浏览器支持font-Stretch属性)*/border-top-left-radius:0.5em;/*圆角边框弧度*/border-top-right-radius:0.5em;/*圆角边框弧度*/border-bottom-left-radius:0.5em;/*圆角边框弧度*/border-bottom-right-radius:0.5em;/*圆角边框弧度*/box-shadow:0px 1px 2px rgba(0,0,0,0.2);/*给按钮增加阴影*/color:#fefee9;/*设置文本的颜色*/border-top-color:#da7c0c;/*边框的颜色*/border-right-color:#da7c0c;/*边框的颜色*/border-bottom-color:#da7c0c;/*边框的颜色*/border-left-color:#da7c0c;/*边框的颜色*/border-top-width:1px;/*边框的粗细*/border-right-width:1px;/*边框的粗细*/border-bottom-width:1px;/*边框的粗细*/border-left-width:1px;/*边框的粗细*/border-top-style:solid;/*边框的样式*/border-right-style:solid;/*边框的样式*/border-bottom-style:solid;/*边框的样式*/border-left-style:solid;/*边框的样式*/background-image:none;/*背景图片*/background-attachment:scroll;/*背景图片是否移动*/background-repeat:repeat;/*允许重复*/background-position-x:0%;/*背景的x轴坐标*/background-position-y:0%;/*背景的y轴坐标*/background-size:auto;/*背景图片的尺寸*/background-origin:padding-box;/*背景图像相对于内边距框来定位*/background-clip:padding-box;/*背景被裁剪到内边距框*/background-color:#f78d1d;/*背景颜色*/&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL常用语法]]></title>
    <url>%2F2019%2F09%2F06%2Fsql3%2F</url>
    <content type="text"><![CDATA[查看数据库的编码 1show variables like '%char%'; 修改字符编码(根据其上所列Variable_name进行编码设置) 12set character_set_server=utf8;set character_set_database=utf8;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接数据库常用配置]]></title>
    <url>%2F2019%2F09%2F06%2Fsql1%2F</url>
    <content type="text"><![CDATA[数据库连接字符编码 1url ="jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8"]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Value'0000-00-00'异常解决方法]]></title>
    <url>%2F2019%2F09%2F06%2Fsql4%2F</url>
    <content type="text"><![CDATA[java.sql.SQLException: Value ‘0000-00-00 ‘异常解决方法 原因: 数据库查询的timestamp时间字段数据内容为0000-00-00,Java实体类Date映射不成功,默认是抛出异常,所以直接赋值为null. 解决办法: 1url="jdbc:mysql://localhost:3306/test?zeroDateTimeBehavior=convertToNull"]]></content>
      <categories>
        <category>Exception</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL数据类型]]></title>
    <url>%2F2019%2F09%2F06%2Fsq12%2F</url>
    <content type="text"><![CDATA[数值类型 Mysql支持所有标准SQL中的数值类型其中包括严格数据类型 (INTEGER,SMALLINT,DECIMAL,NUMBERIC)，以及近似数值数据类型 (FLOAT,REAL,DOUBLE PRESISION),并在此基础上进行扩展。扩展后增加了 TINYINT,MEDIUMINT,BIGINT这3种长度不同的整形，并增加了BIT类型，用来存放位数据。 类型范围及用途 整数类型 字节 范围（有符号） 范围（无符号） 用途 TINYINT 1 (-128，127) (0，255) 小整数值 SMALLINT 2 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 (-9 233 372 036 854 775 808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 单精度浮点数值 DOUBLE 8 双精度浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 INT 类型 在 MySQL 中支持的 5 个主要整数类型是 TINYINT,SMALLINT,MEDIUMINT,INT和BIGINT。这些类型在很大程度上是相同的，只有它们存储的值的大小是不相同的。 MySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。万一我们需要对一个字段存储一个超出许可范围的数字，MySQL 会根据允许范围最接近它的一端截短后再进行存储。还有一个比较特别的地方是，MySQL 会在不合规定的值插入表前自动修改为 0。 UNSIGNED 修饰符规定字段只保存正值。因为不需要保存数字的正、负符号，可以在储时节约一个“位”的空间。从而增大这个字段可以存储的值的范围。 ZEROFILL 修饰符规定 0(不是空格)可以用来真补输出的值。使用这个修饰符可以阻止 MySQL 数据库存储负值。 FLOAT、DOUBLE 和 DECIMAL 类型 MySQL 支持的三个浮点类型是 FLOAT、DOUBLE 和 DECIMAL 类型。FLOAT 数值类型用于表示单精度浮点数值，而 DOUBLE 数值类型用于表示双精度浮点数值。 与整数一样，这些类型也带有附加参数：一个显示宽度指示器和一个小数点指示器。比如语句 FLOAT(7,3) 规定显示的值不会超过 7 位数字，小数点后面带有 3 位数字。 对于小数点后面的位数超过允许范围的值，MySQL 会自动将它四舍五入为最接近它的值，再插入它。 DECIMAL 数据类型用于精度要求非常高的计算中，这种类型允许指定数值的精度和计数方法作为选择参数。精度在这里指为这个值保存的有效数字的总个数， 而计数方法表示小数点后数字的位数。比如语句 DECIMAL(7,3) 规定了存储的值不会超过 7 位数字，并且小数点后不超过 3 位。忽略 DECIMAL 数据类型的精度和计数方法修饰符将会使 MySQL 数据库把所有标识为这个数据类型的字段精度设置为 10，计算方法设置为 0。 UNSIGNED 和 ZEROFILL 修饰符也可以被 FLOAT、DOUBLE 和 DECIMAL 数据类型使用。并且效果与 INT 数据类型相同。 字符串类型 MySQL 提供了8个基本的字符串类型,分别:CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 各SET等多种字符串类型。可以存储的范围从简单的一个字符到巨大的文本块或二进制字符串数据。 类型范围及用途 字符串类型 字节大小 描述及存储需求 CHAR 0-255字节 定长字符串 VARCHAR 0-255字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65535字节 二进制形式的长文本数据 TEXT 0-65535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LOGNGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 VARBINARY(M) 允许长度0-M个字节的定长字节符串，值的长度+1个字节 BINARY(M) 允许长度0-M个字节的定长字节符串 CHAR 和 VARCHAR 类型 CHAR 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围从 0-255。比指定长度大的值将被截短，而比指定长度小的值将会用空格作填补。 CHAR 类型可以使用 BINARY 修饰符。当用于比较运算时，这个修饰符使 CHAR 以二进制方式参于运算，而不是以传统的区分大小写的方式。 CHAR 类型的一个变体是 VARCHAR 类型。它是一种可变长度的字符串类型，并且也必须带有一个范围在 0-255 之间的指示器。CHAR 和 VARCHGAR 不同之处在于 MYSQL 数据库处理. 这个指示器的方式：CHAR 把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度(增加一个额外字节来存储字符串本身的长度)来存储值。所以短于指示器长度的 VARCHAR 类型不会被空格填补，但长于指示器的值仍然会被截短。因为 VARCHAR 类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。VARCHAR 类型在使用 BINARY 修饰符时与 CHAR 类型完全相同。 TEXT 和 BLOB 类型 对于字段长度要求超过 255 个的情况下，MySQL 提供了 TEXT 和 BLOB 两种类型。根据存储数据的大小，它们都有不同的子类型。这些大型的数据用于存储文本块或图像、声音文件等二进制数据类型。 TEXT 和 BLOB 类型在分类和比较上存在区别。BLOB 类型区分大小写，而 TEXT 不区分大小写。 大小修饰符不用于各种 BLOB 和 TEXT 子类型。比指定类型支持的最大范围大的值将被自动截短。 日期和时间类型在处理日期和时间类型的值时，MySQL 带有 5 个不同的数据类型可供选择。它们可以被分成简单的日期、时间类型，和混合日期、时间类型。根据要求的精度，子类型在每个分类型中都可以使用，并且 MySQL 带有内置功能可以把多样化的输入格式变为一个标准格式。 类型范围及用途 类型 大小(字节) 范围 格式 用途 DATE 4 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2037 年某时 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 DATE、TIME 和 TEAR 类型MySQL 用 DATE 和 TEAR 类型存储简单的日期值，使用 TIME 类型存储时间值。这些类型可以描述为字符串或不带分隔符的整数序列。如果描述为字符串, DATE 类型的值应该使用连字号作为分隔符分开，而 TIME 类型的值应该使用冒号作为分隔符分开。 需要注意的是，没有冒号分隔符的 TIME 类型值，将会被 MySQL 理解为持续的时间，而不是时间戳。 MySQL 还对日期的年份中的两个数字的值，或是 SQL 语句中为 TEAR 类型输入的两个数字进行最大限度的通译。因为所有 TEAR 类型的值必须用 4 个数字存储。 MySQL 试图将 2 个数字的年份转换为 4 个数字的值。把在 00-69 范围内的值转换到 2000-2069 范围内。把 70-99 范围内的值转换到 1970-1979 之内。 如果 MySQL 自动转换后的值并不符合我们的需要，请输入 4 个数字表示的年份。 DATEYIME 和 TIMESTAMP 类型除了日期和时间数据类型，MySQL 还支持 DATEYIME 和 TIMESTAMP 这两种混合类型。它们可以把日期和时间作为单个的值进行存储。 这两种类型通常用于自动存储包含当前日期和时间的时间戳，并可在需要执行大量数据库事务和需要建立一个调试和审查用途的审计跟踪的应用程序中发挥良好作用。 如果我们对 TIMESTAMP 类型的字段没有明确赋值，或是被赋与了 null 值。MySQL 会自动使用系统当前的日期和时间来填充它。 复合类型MySQL 还支持两种复合数据类型 ENUM 和 SET，它们扩展了 SQL 规范。虽然这些类型在技术上是字符串类型，但是可以被视为不同的数据类型。 一个 ENUM 类型只允许从一个集合中取得一个值；而 SET 类型允许从一个集合中取得任意多个值。 ENUM 类型ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。ENUM 类型字段可以从集合中取得一个值或使用 null 值， 除此之外的输入将会使 MySQL 在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL 会自动使用插入值的大小写转换成与集合中大小写一致的值。 ENUM 类型在系统内部可以存储为数字，并且从 1 开始用数字做索引。一个 ENUM 类型最多可以包含 65536 个元素，其中一个元素被 MySQL 保留，用来存储错误信息， 这个错误值用索引 0 或者一个空字符串表示。 MySQL 认为 ENUM 类型集合中出现的值是合法输入，除此之外其它任何输入都将失败。这说明通过搜索包含空字符串或对应数字索引为 0 的行就可以很容易地找到错误记录的位置。 SET 类型SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。并且与 ENUM 类型相同的是任何试图在 SET 类型字段中插入非预定义的值都会使 MySQL 插入一个空字符串。如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。 一个 SET 类型最多可以包含 64 项元素。在 SET 元素中值被存储为一个分离的“位”序列，这些“位”表示与它相对应的元素。“位”是创建有序元素集合的一种简单而有效的方式。 并且它还去除了重复的元素，所以 SET 类型中不可能包含两个相同的元素。 希望从 SET 类型字段中找出非法的记录只需查找包含空字符串或二进制值为 0 的行。 通过对每种数据类型的用途，物理存储，表示范围等有一个概要的了解。这样在面对具体应用时，就可以根据相应的特来来选择合适的数据类型，使得我们能够争取在满足应用的基础上，用较小的存储代价换来较高的数据库性能。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据某个字段将多条记录的某个字段拼接成一个字段]]></title>
    <url>%2F2019%2F09%2F06%2Fmysql8%2F</url>
    <content type="text"><![CDATA[如下表所示:``SQL代码：(注意：group by 进行分组)12SELECT NAME,GROUP_CONCAT(r.roleName)roleName FROM users u JOIN user_role ur ON u.id=ur.uid JOIN role r ON ur.rid=r.id GROUP BY u.id 查询效果：]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL字符串函数-字符串截取]]></title>
    <url>%2F2019%2F09%2F06%2Fmysql7%2F</url>
    <content type="text"><![CDATA[原文链接 left(name,4)截取左边的4个字符 1SELECT LEFT(201809,4) 年 -- 2018 right(name,2)截取右边的2个字符 1SELECT RIGHT(201809,2) 月份 -- 09 SUBSTRING(name,5,3) 截取name这个字段从第五个字符开始,只截取之后的3个字符 1SELECT SUBSTRING('成都融资事业部',5,3) -- 事业部 SUBSTRING(name,3) 截取name这个字段从第三个字符开始,之后的所有的字符 1SELECT SUBSTRING('成都融资事业部',3) -- 融资事业部 SUBSTRING(name, -4) 截取name这个字段的第 4 个字符位置（倒数）开始取，直到结束 1SELECT SUBSTRING('成都融资事业部',-4) -- 资事业部 SUBSTRING(name, -4，2) 截取name这个字段的第 4 个字符位置（倒数）开始取，只截取之后的2个字符 1SELECT SUBSTRING('成都融资事业部',-4,2) -- 资事 注意:我们注意到在函数 substring(str,pos, len)中,pos 可以是负值,但 len 不能取负值。 substring_index(‘www.baidu.com&#39;, ‘.’, 2) 截取第二个 ‘.’ 之前的所有字符 1SELECT substring_index('www.baidu.com', '.', 2) -- www.baidu substring_index(‘www.baidu.com&#39;, ‘.’, -2) 截取第二个 ‘.’ （倒数）之后的所有字符 1SELECT substring_index(&apos;www.baidu.com&apos;, &apos;.&apos;, -2) -- baidu.com SUBSTR(name, 1, CHAR_LENGTH(name)-3) 截取name字段,取除name字段后三位的所有字符 1SELECT SUBSTR('成都融资事业部', 1, CHAR_LENGTH('成都融资事业部')-3) -- 成都融资]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务-隔离级别]]></title>
    <url>%2F2019%2F09%2F06%2Fmysql5%2F</url>
    <content type="text"><![CDATA[数据库事务具有ACID这4个特性 A：Atomic,原子性,将所有SQL作为原子工作单元执行,要么全部执行,要么全部不执行; C：Consistent,一致性,事务完成后,所有数据的状态都是一致的，即A账户只要减去了100,B账户则必定加上了100; I：Isolation,隔离性,如果有多个事务并发执行,每个事务作出的修改必须与其他事务隔离; D：Duration,持久性,即事务完成后,对数据库数据的修改被持久化存储. 隔离级别 对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。 SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况： Isolation Level 脏读（Dirty Read） 不可重复读（Non Repeatable Read） 幻读（Phantom Read） Read Uncommitted Yes Yes Yes Read Committed - Yes Yes Repeatable Read - - Yes Serializable - - - Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。 我们来看一个例子。 首先，我们准备好students表的数据，该表仅一行记录： 1234567mysql&gt; select * from students;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec) 然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; 2 BEGIN; BEGIN; 3 UPDATE students SET name = ‘Bob’ WHERE id = 1; 4 SELECT * FROM students WHERE id = 1; 5 ROLLBACK; 6 SELECT * FROM students WHERE id = 1; 7 COMMIT; video1 当事务A执行完第3步时，它更新了id=1的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。随后，事务A在第5步进行了回滚，事务B再次读取id=1的记录，发现和上一次读取到的数据不一致，这就是脏读。可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。 Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。 不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。 我们仍然先准备好students表的数据： 1234567mysql&gt; select * from students;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec) 然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL READ COMMITTED; 2 BEGIN; BEGIN; 3 SELECT * FROM students WHERE id = 1; 4 UPDATE students SET name = ‘Bob’ WHERE id = 1; 5 COMMIT; 6 SELECT * FROM students WHERE id = 1; 7 COMMIT; video2 当事务B第一次执行第3步的查询时，得到的结果是Alice，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了Bob，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。 Repeatable Read一个事务可能会遇到幻读（Phantom Read）的问题。 幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。 我们仍然先准备好students表的数据： 1234567mysql&gt; select * from students;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec)) 然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; 2 BEGIN; BEGIN; 3 SELECT * FROM students WHERE id = 99; 4 INSERT INTO students (id, name) VALUES (99, ‘Bob’); 5 COMMIT; 6 SELECT * FROM students WHERE id = 99; 7 UPDATE students SET name = ‘Alice’ WHERE id = 99; 8 SELECT * FROM students WHERE id = 99; 9 COMMIT; video 事务B在第3步第一次读取id=99的记录时，读到的记录为空，说明不存在id=99的记录。随后，事务A在第4步插入了一条id=99的记录并提交。事务B在第6步再次读取id=99的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取id=99的记录时，记录出现了。可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。 Serializable是最严格的隔离级别在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景,一般都不会使用Serializable隔离级别。 默认隔离级别 如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用sql]]></title>
    <url>%2F2019%2F09%2F06%2Fmysql6%2F</url>
    <content type="text"><![CDATA[插入或替换 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句，这样就不必先查询，再决定是否先删除再插入：1REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99); 若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。 插入或更新 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO ... ON DUPLICATE KEY UPDATE ...语句： 1INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99) ON DUPLICATE KEY UPDATE name='小明', gender='F', score=99; 若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。 插入或忽略 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO ...语句： 1INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99); 若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。 快照 如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT： 12-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1; 新创建的表结构和SELECT使用的表结构完全一致。 写入查询结果集 如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。 例如，创建一个统计成绩的表statistics，记录各班的平均成绩： 123456CREATE TABLE statistics ( id BIGINT NOT NULL AUTO_INCREMENT, class_id BIGINT NOT NULL, average DOUBLE NOT NULL, PRIMARY KEY (id)); 然后，我们就可以用一条语句写入各班的平均成绩： 1INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id; 确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果： 123456789&gt; select * from statistics;+----+----------+--------------+| id | class_id | average |+----+----------+--------------+| 1 | 1 | 86.5 || 2 | 2 | 73.666666666 || 3 | 3 | 88.333333333 |+----+----------+--------------+3 rows in set (0.00 sec)]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql生成任意指定两时间范围内的日期列表（三种方法）]]></title>
    <url>%2F2019%2F09%2F06%2Fmysql4%2F</url>
    <content type="text"><![CDATA[参考链接Mysql生成任意指定两时间范围内的日期列表（三种方法）mysql 给定起止日期获取之间的连续日期 创建一个临时的日历表DELIMITER $$ DROP PROCEDURE IF EXISTS create_calendar $$ CREATE PROCEDURE create_calendar (s_date DATE, e_date DATE) BEGIN SET @createSql = &apos;CREATE TABLE IF NOT EXISTS calendar ( `date` date NOT NULL, UNIQUE KEY `unique_date` (`date`) USING BTREE )ENGINE=InnoDB DEFAULT CHARSET=utf8&apos;; prepare stmt from @createSql; execute stmt; WHILE s_date &lt;= e_date DO INSERT IGNORE INTO calendar VALUES (DATE(s_date)) ; SET s_date = s_date + INTERVAL 1 DAY ; END WHILE ; END$$ DELIMITER ; CALL create_calendar (&apos;2018-03-01&apos;, &apos;2018-12-30&apos;); 总结:生成一张临时表,里面存放着你自己指定的时间范围内的所有日期。生成临时表，根据自己业务需求与数据进行各种操作得出某段时间范围内日期齐全的数据。 (变量控制)指定数据条数,生成连续的数字或日期 1234567SELECT DATE_FORMAT(DATE_SUB(NOW(), INTERVAL xc MONTH), '%Y-%m') as dateFROM ( SELECT @xi:=@xi+1 as xc from (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) xc1, (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) xc2, (SELECT @xi:=0) xc0 ) xcxc 总结：在如上的例子当中,涉及到的知识点是变量,DATE_SUB(),DATE_FORMAT().使用以上方法的好处就是不用创建存储过程，也不涉及到任何表。缺点就是数据的条数控制并不灵活,不能和用户之间形成互动,即不能自定义日期区间,只能控制数据条数。 利用数据量大的表做操作 创建一个数字辅助表 1234CREATE TABLE `manhour_record` ( `key` int(11) NOT NULL, PRIMARY KEY (`key`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='数字辅助表'; 创建一个存储过程为数字辅助表增加数据 1234567891011121314DELIMITER $$CREATE DEFINER=`root`@`%` PROCEDURE `create_nums`(cnt int unsigned)BEGINdeclare s int unsigned default 1; truncate table manhour_record; insert into manhour_recordselect s; while s*2&lt;=cnt do begin insert into nums select `key`+s from manhour_record; set s=s*2; end; end while;END$$DELIMITER ; 执行存储过程，增加1-50000进入数字辅助表 1call create_nums(50000); 代码编写 oracle 求两个日期之间的所有日期 1234SELECT TO_CHAR((TO_DATE('2019-05-28', 'yyyy-MM-dd') + (ROWNUM - 1)), 'yyyy-MM-dd') DT FROM DUALCONNECT BY ROWNUM &lt;=(TO_DATE('2019-05-31', 'yyyy-MM-dd') - TO_DATE('2019-05-28', 'yyyy-MM-dd') + 1);]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql的Rownum使用示例]]></title>
    <url>%2F2019%2F09%2F06%2Fmysql3%2F</url>
    <content type="text"><![CDATA[原文链接 显示当前查询结果的行号 1SELECT @rownum := @rownum +1 AS rownum,e.* FROM (SELECT @rownum := 0) r,employee e]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于时间的一些查询]]></title>
    <url>%2F2019%2F09%2F06%2Fmysql2%2F</url>
    <content type="text"><![CDATA[查询最近的一条信息1SELECT * FROM table_name ORDER BY create_time DESC LIMIT 1; //limit 1 提高查询效率，避免全表扫描 查询今天12345678方法一：SELECT * FROM table_name WHERE DATE_FORMAT( create_time,'%Y-%m-%d') = DATE_FORMAT(NOW(), '%Y-%m-%d');方法二：SELECT * FROM table_name WHERE DATE(create_time) =DATE(NOW());方法三：SELECT * FROM table_name WHERE TO_DAYS(create_time) =TO_DAYS(NOW()); DATE_FORMAT(date,format)函数用于以不同的格式显示日期/时间数据 date参数是合法的日期。 format规定日期/时间的输出格式 NOW()函数返回当前的日期和时间 TO_DAYS(date) 返回当前日期的毫秒数 DATE(date) 提取日期或日期/时间表达式的日期部分 计算两个日期之间的年/月/日相差 1SELECT TIMESTAMPDIFF(YEAR/MONTH/DAY,'2003-02-01','2003-05-01'); TIMESTAMPDIFF(interval,datetime_expr1,datetime_expr2) 返回日期或日期时间表达式datetime_expr1 和datetime_expr2the 之间的整数差(注意日期大小不可颠倒) 查询昨天 1CURDATE()-1 //参考查询今天的方法 在今天的天数是-1 CURDATE() 返回当前的日期 查询一个星期内/一个月内的数据的数据 1SELECT * FROM table_name WHERE DATE_SUB(CURDATE(),INTERVAL 7 DAY/INTERVAL 1 MONTH) &lt;=DATE(create_time) ORDER BY create_time DESC; DATE_SUB(date,INTERVAL expr unit) 从日期里减去指定的时间间隔 返回date的星期索引(1 = Sunday, 2 = Monday, … 7 = Saturday) 1SELECT DAYOFWEEK(create_time) FROM table_name ORDER BY create_time DESC 给日期添加指定的时间间隔 1SELECT * FROM table_name WHERE DATE_ADD(create_time,INTERVAL 1 DAY) &lt;= DATE(NOW()); DATE_ADD(date,INTERVAL expr unit) 给日期添加指定的时间间隔 返回两个日期之间的天数 1SELECT * FROM table_name WHERE DATEDIFF(NOW(),create_time)=0 //0代表查询的是当天,1 查询的就是昨天.. DATEDIFF(expr1,expr2) 返回两个日期之间的天数 查询本季度数据 12345select * from table_name where QUARTER(create_time)=QUARTER(NOW());查询上季度数据select * from table_name where QUARTER(create_time)=QUARTER(NOW())-1;或者:select * from table_name where QUARTER(create_time)=QUARTER(DATE_SUB(NOW(),interval 1 QUARTER)); QUARTER(date) 1=1季度(1-2-3月)… 查询本年数据 12345select * from table_name where YEAR(create_time)=YEAR(NOW());查询上年数据select * from table_name where YEAR(create_time)=YEAR(NOW())-1;或者:select * from table_name where YEAR(create_time)=YEAR(date_sub(NOW(),interval 1 YEAR)); YEAR(date) 获取日期的年份 MONTH(date) 获取日期的月份 Day(date) 获取日期的天数 TIME(NOW())获取时间 查询当前这周的数据 1SELECT * FROM table_name WHERE YEARWEEK(date_format(create_time,'%Y-%m-%d')) = YEARWEEK(NOW()); 查询距离当前现在6个月的数据 1select * from table_name where create_time between date_sub(NOW(),interval 6 MONTH) and NOW(); 日期：CURDATE()=CURRENT_DATE()= DATE(NOW()) 日期+时间： NOW()=SYSDATE()=CURRENT_TIMESTAMP()=LOCALTIME()=LOCALTIMESTAMP() 时间：CURTIME()=CURRENT_TIME()=TIME(NOW())]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Case when then end]]></title>
    <url>%2F2019%2F09%2F06%2Fmysql1%2F</url>
    <content type="text"><![CDATA[已知商品评论表如下图展示： 表结构： 统计每种商品下的好坏留言的人数： 思路：先进行商品分类–》case when then 进行评分的判定–》count统计数量。 代码如下： 123456SELECT pro.pid,pro.pname, COUNT(CASE WHEN p.prscore=5 THEN 1 END)best, COUNT(CASE WHEN p.prscore=4 THEN 1 END)good, COUNT(CASE WHEN p.prscore=3 THEN 1 END)common, COUNT(CASE WHEN p.prscore&lt;=2 THEN 1 END)bad FROM product_review p JOIN products pro ON p.pid =pro.pid GROUP BY p.pid 效果显示：]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[You have not concluded your merge]]></title>
    <url>%2F2019%2F09%2F06%2Fgithub5%2F</url>
    <content type="text"><![CDATA[fatal: You have not concluded your merge (MERGE_HEAD exists)参考链接报错原因：【pull下来的代码自动合并失败】从远程获取最新版本到本地有两种方式： Git fetch:只是从远程获取最新版本到本地,不会merge(合并) 123git fetch origin master //从远程的origin的master主分支上获取最新版本到origin/master分支上git log -p master..origin/master //比较本地的master分支和origin/ master分支的区别git merge origin/master //合并 Git pull:从远程获取最新版本并merge(合并)到本地 1git pull origin master //相当于进行了 git fetch 和 git merge两部操作 实际工作中,可能git fetch更好一些, 因为在merge前,可以根据实际情况决定是否【merge】 解决方法： 方法一:保留本地的更改,中止合并-&gt;重新合并-&gt;重新拉取 123git merge --abortgit reset --mergegit pull 方法二:舍弃本地代码,远端版本覆盖本地版本(慎重) 123git fetch --allgit reset --hard origin/mastergit fetch]]></content>
      <categories>
        <category>Exception</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础学习]]></title>
    <url>%2F2019%2F09%2F06%2Fgit3%2F</url>
    <content type="text"><![CDATA[参考文档1.廖雪峰-git教程2.git学习(廖雪峰版教程)-可借鉴笔记集中式vs分布式 集中式开发(CVS及SVN)：是将项目集中存放在中央服务器中，在工作的时候，大家只在自己电脑上操作，从同一个地方下载最新版本，然后开始工作，做完的工作再提交给中央服务器保存。这种方式需要联网. 2.分布式开发(Git)：通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它也一样干活，只是交换修改不方便而已。而每一台电脑有各自独立的开发环境(每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了)，不需要联网，本地直接运行，相对集中式安全系数高很多。 安装Git最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。要使用Git，第一步当然是安装Git了. 在Linux上安装Git 首先，你可以试着输入git，看看系统有没有安装Git： 123$ gitThe program &apos;git&apos; is currently not installed. You can install it by typing:sudo apt-get install git 像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。 如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。 老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。 在Mac OS X上安装Git 如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ 在Windows上安装Git 在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢请移步国内镜像），然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区(.git所在的目录下，除了.git之外的其他文件都是在工作区内)，而是Git的版本库(这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”) Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区(用add命令放进来文件的位置)，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD (表示当前版本，上一个版本就是HEAD^(可以写为HEAD~1)，上上一个版本就是HEAD^^^^^(可以写为HEAD~5)) 我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 如果文件在工作区被编辑，对应的status状态就是 Changes not staged for commit 如果工作区新增文件，则对应的status状态就是 Untracked files 如果文件被add后，对应的status状态就是 Changes to be committed 多次add后的文件都放在暂存区，最后一次性全部提交。提交后的status状态就是 nothing to commit, working tree clean 这时候工作区就是干净的，暂存区就没有任何内容了。 远程仓库只要注册一个GitHub账号，就可以免费获得Git远程仓库. 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录(在windows中就是 C:\Users\Administrator\，或者你新建了一个用户，那就是 C:\Users\用户名\)下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa - C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 分支管理（小视频） 每次提交 创建与合并分支 注意小结 Git管理的是修改，而不是文件 每次修改，如果不用git add到暂存区，那就不会加入到commit中 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并 多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并 如果合并有冲突，则解决冲突，并在本地提交 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to= origin/&lt;branch-name&gt; &lt;branch-name&gt; 标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签 忽略某些文件时，需要编写.gitignore该文件本身要放到版本库里，并且可以对.gitignore做版本管理 配置Git的时候，加上--global是针对当前用户(用户主目录下.gitconfig文件)起作用的，如果不加，那只针对当前的仓库起作用。每个仓库的Git配置文件都放在.git/config文件中 如果MERGE(合并)出现冲突， 则解决冲突以后必须：git add - &gt; git commit 禁用FAST forward模式,Git就会在MERGE时生成一个新的COMMIT，这样，从分支历史上就可以看出分支信息]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[refusing to merge unrelated histories]]></title>
    <url>%2F2019%2F09%2F06%2Fgithub3%2F</url>
    <content type="text"><![CDATA[fatal:refusing to merge unrelated histories(拒绝合并不相关的历史) 原因:两个 根本不相干的 git 库, 一个是本地库,一个是远端库, 然后本地要去推送到远端, 远端觉得这个本地库跟自己不相干, 所以告知无法合并 解决办法: 从远端库clone项目(test)到本地 ,本地把要加入的代码放到本地的库(test)下, 然后再提交上去 git pull origin master –allow-unrelated-histories (把两段不相干的 分支进行强行合并)]]></content>
      <categories>
        <category>Exception</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[failed to push some refs to 'git@github.com']]></title>
    <url>%2F2019%2F09%2F06%2Fgithub2%2F</url>
    <content type="text"><![CDATA[git push_报错error: failed to push some refs to ‘git@github.com’ 原因： GitHub远程仓库中的README.md文件不在本地仓库中。 解决办法： 12$ git pull --rebase origin master //先拉下来，会自动合并的(pull=fetch+merge)$ git push -u origin master //进行推送]]></content>
      <categories>
        <category>Exception</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git push_时出现"Everything up-to-date"]]></title>
    <url>%2F2019%2F09%2F06%2Fgithub1%2F</url>
    <content type="text"><![CDATA[git push_时出现”Everything up-to-date 原因： 没有git add 没有git commit -m “提交信息” 解决办法：按部就班]]></content>
      <categories>
        <category>Exception</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Incorrect username or password(access token)]]></title>
    <url>%2F2019%2F09%2F06%2Fgithub4%2F</url>
    <content type="text"><![CDATA[remote: Incorrect username or password ( access token )原文链接 异常 123git push origin ionic-001remote: Incorrect username or password ( access token )fatal: Authentication failed for &apos;https://gitee.com/yyr/demo.git/&apos; 原因 由于之前重置了Git账户的密码，忘记修改计算机的凭据导致这个问题的出现。 解决方案 1.打开电脑的控制面板–&gt;用户账户–&gt;管理Windows凭据 2.找到普通凭据中自己的账号信息，选择编辑，填入正确的用户名和密码，最后点击保存即可。 3.最后重新使用git的push指令，成功将代码提交。]]></content>
      <categories>
        <category>Exception</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse-Github操作]]></title>
    <url>%2F2019%2F09%2F06%2Fgit4%2F</url>
    <content type="text"><![CDATA[参考链接小白使用eclipse提交到GitHub (详细步骤)Eclipse生成SSH传输密钥并实现GitHub的SSH代码提交(部分参考)Eclipse使用egit插件通过ssh协议方式上传代码到gitLab(部分参考) eclipse使用https、ssh协议方式上传代码至github1.首先登陆GitHub创建一个新的repository (Start a project),复制地址备用。 注意,红色标识部分不要勾选,否则后续提交代码时会出现冲突。 2.Eclipse:项目名称必须与gitHub中一致 Eclipse 高级版本自带Git,不需要安装插件。(如使用低级版本,请自己百度安装Git插件) 将本地项目上传到Git,流程：需要先通过Commit 传到本地仓库,然后再从本地仓库push到Git。 以https协议方式上传项目代码 https://github.com/xxxx/TestDemo.git 3.项目右键,Team -&gt; Share Project(项目提交通用) 4.选择Git,随后配置GIT, Configure Git Repository 5.在此目录下会生成一个.git 的文件夹,此时Eclipse中文件显示?号。 为新建的文件添加Index, 右键项目-＞Team-&gt;Add to Index, 这里将所有文件会带个+号, 对于不需要提交的文件,可以通过右键-&gt;Team-&gt;Remove from Index 移除。 提交代码到本地仓库 6.右键项目-&gt;Team-&gt;Commit, add commit message, 如果遇到下面这种情况,先去Window-&gt;Preference-&gt;Team-&gt;Git-&gt;Committing, 将第一个默认勾选去掉。 以下面作为参考提交: 7.注意,代码只需要提交图片中标识的文件即可。也可以通过编辑.gitignore将不需要提交的文件筛除。 commit后, 这时,可以看到文件带有圆柱形标志。 8.从本地代码提交到Git 项目右键,Team-&gt;Remote-&gt;Push, 输入Git地址,以及登陆凭证 9.点击Next,Source ref和Destination ref下拉框中选择master,点击Add Spec,点击Next。 10.项目提交到Git成功 11.打开GitHub,查看是否项目是否上传成功。 以ssh协议方式上传项目代码 使用ssh方式可以不通过https协议,避免直接提供账号密码的方式上传项目到git在线服务器,如GitLab、Bitbucket、GitHub,同时极其可靠的保证账号安全性。 操作步骤： 1.Window-&gt;preferences-&gt;General-&gt;Network Connections-&gt;SSH2 2.切换到Key Management页,选择点击 Generate DSA key 或 Generate RSA key 按钮,生成DSA或RSA算法的密钥,原则上是DSA或RSA都受支持的,个人感觉DSA甚至更好,毕竟两者中,DSA被美国NIST挑选作为数字签名标准,但是RSA在百度搜索出的纵多博文中被使用。 3.生成了看上去满意的密钥后,填写Comment简要注释,填写Passphrase(可选填项,相当于password,用于加密保护私钥,填写后每次上传服务器,将要求提供此密码验证私钥的使用权),点击SavePrivateKey。 如果之前已经生成文件,可重新定义文件位置或者进行覆盖。其中,id_rsa代表非对称加密算法rsa的私钥,id_rsa.pub代表公钥,私钥是需要自己保管的,而公钥可以任意发送给他人保管,这是为了让remote用户能够判断传输的加密数据是否为本人操作。 4.【关键步骤】点击 Export Via SFTP ,按 user@host[:port] 形式输入公钥绑定的服务器域,如 git@bitbucket.org 或 git@github.com (输入刚才的Passphrase,点击各种确定,ps:我绑定时没出现,如果报出 Failed to export ssh key to remote server 的错误,直接忽略)注意:push的时候报出 The authenticity of host ‘github.org’ can’t be established. 之类的错误,阻止上传,基本都是没执行这一步的原因。 5.点击 Load Existing Key,选择刚才生成的私钥(id_rsa文件),输入Passphrase,点击Apply。 6.点击旁边的Known Hosts,应该能看到刚才绑定的服务器记录。 7.返回General,确认Private keys中包含了刚才保存的私钥件id_rsa,没包含的话点击旁边的Add Private Key..添加进去,最后点击Apply(SSH2 home位置,用于存储SSH协议使用的非对称加密密钥文件) 8.最好重启一次Eclipse 9.把生成的公钥(刚才生成密钥的时候显示的那一串东西或者打开刚才生成的id_rsa.pub文件将里面的内容全部复制下来)绑定到git服务器上。 10.添加GitHub公钥 11.elipse代码提交如上,只需更改路径,其余跟https提交代码一致,不需要再输入密码。]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP相关内容]]></title>
    <url>%2F2019%2F09%2F06%2Fhttp%2F</url>
    <content type="text"><![CDATA[参考链接HTTP 教程 涉及内容：HTTP 简介、HTTP 消息结构、HTTP请求方法、HTTP 响应头信息、HTTP状态码、HTTP content-type HTTP 简介 HTTP协议是Hyper Text Transfer Protocol(超文本传输协议)的缩写,是用于从万维网 (WWW:World Wide Web )服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据(HTML 文件, 图片文件, 查询结果等) HTTP 工作原理 HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有:Apache服务器,IIS服务器(Internet Information Services)等。 Web服务器根据接收到的请求后,向客户端发送响应信息。 HTTP默认端口号为80,但是你也可以改为8080或者其他端口。 HTTP三点注意事项 HTTP是无连接:无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求,并收到客户的应答后,即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的:这意味着,只要客户端和服务器知道如何处理的数据内容,任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态:HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息,则它必须重传。这样可能导致每次连接传送的数据量增大。另一方面,在服务器不需要先前信息时它的应答就较快。 以下图表展示了HTTP协议通信流程: CGI(Common Gateway Interface) 是 HTTP 服务器与你的或其它机器上的程序进行“交谈”的一种工具,其程序须运行在网络服务器上。绝大多数的 CGI 程序被用来解释处理来自表单的输入信息,并在服务器产生相应的处理，或将相应的信息反馈给浏览器。CGI 程序使网页具有交互功能。 HTTP 消息结构 HTTP是基于客户端/服务端（C/S）的架构模型,通过一个可靠的链接来交换信息,是一个无状态的请求/响应协议。 一个HTTP”客户端”是一个应用程序(Web浏览器或其他任何客户端),通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。 一个HTTP”服务器”同样也是一个应用程序(通常是一个Web服务,如Apache Web服务器或IIS服务器等),通过接收客户端的请求并向客户端发送HTTP响应数据。 HTTP使用统一资源标识符(Uniform Resource Identifiers, URI)来传输数据和建立连接。一旦建立连接后,数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 客户端请求消息 客户端发送一个HTTP请求到服务器的请求消息包括以下格式:请求行(request line)、请求头部(header)、空行和请求数据四个部分组成,下图给出了请求报文的一般格式。 服务器响应消息HTTP响应也由四个部分组成,分别是:状态行、消息报头、空行和响应正文。 下面实例是一点典型的使用GET来传递数据的实例： 客户端请求1234GET /hello.txt HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi 服务端响应123456789HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMTETag: &quot;34aa387-d-1568eb00&quot;Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type: text/plain 输出结果: 1Hello World! My payload includes a trailing CRLF. HTTP请求方法 HTTP1.0定义了三种请求方法: GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法:OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 HTTP 协议中共定义了八种方法或者叫“动作”来表明对 Request-URI 指定的资源的不同操作方式,具体介绍如下: 方法 描述 GET 请求指定的页面信息,并返回实体主体。 HEAD 类似于get请求,只不过返回的响应中没有具体的内容,用于获取报头 POST 向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*‘的请求来测试服务器的功能性 TRACE 回显服务器收到的请求,主要用于测试或诊断。 虽然HTTP的请求方式有8种,但是我们在实际应用中常用的也就是get和post,其他请求方式也都可以通过这两种方式间接的来实现。 HTTP 响应头信息 HTTP请求头提供了关于请求,响应或者其他的发送实体的信息。 HTTP响应头信息如下: 应答头 说明 Allow 服务器支持哪些请求方法(如GET、POST等) Content-Encoding 文档的编码(Encode)方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩,但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此,Servlet应该通过查看Accept-Encoding头(即request.getHeader(“Accept-Encoding”))检查浏览器是否支持gzip,为支持gzip的浏览器返回经gzip压缩的HTML页面,为其他浏览器返回普通页面 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势,可以把输出文档写入 ByteArrayOutputStream,完成后查看其大小,然后把该值放入Content-Length头,最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain,但通常需要显式地指定为text/html。由于经常要设置Content-Type,因此HttpServletResponse提供了一个专用的方法setContentType Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦 Expires 应该在什么时候认为文档已经过期,从而不再缓存它 Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET,只有改动时间迟于指定时间的文档才会返回,否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置 Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的,而是通过HttpServletResponse的sendRedirect方法,该方法同时设置状态代码为302 Refresh 表示浏览器应该在多少时间之后刷新文档,以秒计。除了刷新当前文档之外,你还可以通过setHeader(“Refresh”, “5; URL=url”)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=url”＞实现,这是因为,自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是,对于Servlet来说,直接设置Refresh头更加方便。注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”,而不是”每隔N秒刷新本页面或访问指定页面”。因此,连续刷新要求每次都发送一个Refresh头,而发送204状态代码则可以阻止浏览器继续刷新,不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。注意Refresh头不属于HTTP 1.1正式规范的一部分,而是一个扩展,但Netscape和IE都支持它。 Server 服务器名字。Servlet一般不设置这个值,而是由Web服务器自己设置 Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …),而是应使用HttpServletResponse提供的专用方法addCookie WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息。在包含401(Unauthorized)状态行的应答中这个头是必需的。例如,response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。注意Servlet一般不进行这方面的处理,而是让Web服务器的专门机制来控制受密码保护页面的访问(例如.htaccess) HTTP状态码(HTTP Status Code) 当浏览者访问一个网页时,浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前,此网页所在的服务器会返回一个包含HTTP状态码的信息头(server header)用以响应浏览器的请求。 HTTP状态码分类 HTTP状态码由三个十进制数字组成,第一个十进制数字定义了状态码的类型,后两个数字没有分类的作用。HTTP状态码共分为5种类型 分类 分类描述 1** 信息,服务器收到请求,需要请求者继续执行操作 2** 成功,操作被成功接收并处理 3** 重定向,需要进一步的操作以完成请求 4** 客户端错误,请求包含语法错误或无法完成请求 5** 服务器错误,服务器在处理请求的过程中发生了错误 HTTP状态码列表 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议,例如:切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求,但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器,而是一个副本 204 No Content 无内容。服务器成功处理,但未返回内容。在未更新网页的情况下,可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功,用户终端(例如:浏览器)应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置,相应可返回一个资源特征与地址的列表用于用户终端(例如:浏览器)选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI,返回信息会包括新的URI,浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时,不会返回任何资源。客户端通常会缓存访问过的资源,通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误,服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留,将来使用 403 Forbidden 服务器理解请求客户端的请求,但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源(网页)。通过此代码,网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证,与401类似,但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长,超时 409 Conflict 服务器完成客户端的PUT请求是可能返回此代码,服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404,如果资源以前有现在被永久删除了可使用410代码,网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大,服务器无法处理,因此拒绝请求。为防止客户端的连续请求,服务器可能会关闭连接。如果只是服务器暂时无法处理,则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长(URI通常为网址),服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误,无法完成请求 501 Not Implemented 服务器不支持请求的功能,无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时,从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护,服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器,未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本,无法完成处理 HTTP content-type Content-Type,内容类型,一般是指网页中存在的Content-Type,用于定义网络文件的类型和网页的编码,决定浏览器将以什么形式、什么编码读取这个文件,这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。 HTTP content-type 对照表 文件扩展名 Content-Type(Mime-Type) 文件扩展名 Content-Type(Mime-Type) .*(二进制流,不知道下载文件类型) application/octet-stream .tif image/tiff .001 application/x-001 .301 application/x-301 .323 text/h323 .906 application/x-906 .907 drawing/907 .a11 application/x-a11 .acp audio/x-mei-aac .ai application/postscript .aif audio/aiff .aifc audio/aiff .aiff audio/aiff .anv application/x-anv .asa text/asa .asf video/x-ms-asf .asp text/asp .asx video/x-ms-asf .au audio/basic .avi video/avi .awf application/vnd.adobe.workflow .biz text/xml .bmp application/x-bmp .bot application/x-bot .c4t application/x-c4t .c90 application/x-c90 .cal application/x-cals .cat application/vnd.ms-pki.seccat .cdf application/x-netcdf .cdr application/x-cdr .cel application/x-cel .cer application/x-x509-ca-cert .cg4 application/x-g4 .cgm application/x-cgm .cit application/x-cit .class java/* .cml text/xml .cmp application/x-cmp .cmx application/x-cmx .cot application/x-cot .crl application/pkix-crl .crt application/x-x509-ca-cert .csi application/x-csi .css text/css .cut application/x-cut .dbf application/x-dbf .dbm application/x-dbm .dbx application/x-dbx .dcd text/xml .dcx application/x-dcx .der application/x-x509-ca-cert .dgn application/x-dgn .dib application/x-dib .dll application/x-msdownload .doc application/msword .dot application/msword .drw application/x-drw .dtd text/xml .dwf Model/vnd.dwf .dwf application/x-dwf .dwg application/x-dwg .dxb application/x-dxb .dxf application/x-dxf .edn application/vnd.adobe.edn .emf application/x-emf .eml message/rfc822 .ent text/xml .epi application/x-epi .eps application/x-ps .eps application/postscript .etd application/x-ebx .exe application/x-msdownload .fax image/fax .fdf application/vnd.fdf .fif application/fractals .fo text/xml .frm application/x-frm .g4 application/x-g4 .gbr application/x-gbr . application/x- .gif image/gif .gl2 application/x-gl2 .gp4 application/x-gp4 .hgl application/x-hgl .hmr application/x-hmr .hpg application/x-hpgl .hpl application/x-hpl .hqx application/mac-binhex40 .hrf application/x-hrf .hta application/hta .htc text/x-component .htm text/html .html text/html .htt text/webviewhtml .htx text/html .icb application/x-icb .ico image/x-icon .ico application/x-ico .iff application/x-iff .ig4 application/x-g4 .igs application/x-igs .iii application/x-iphone .img application/x-img .ins application/x-internet-signup .isp application/x-internet-signup .IVF video/x-ivf .java java/* .jfif image/jpeg .jpe image/jpeg .jpe application/x-jpe .jpeg image/jpeg .jpg image/jpeg .jpg application/x-jpg .js application/x-javascript .jsp text/html .la1 audio/x-liquid-file .lar application/x-laplayer-reg .latex application/x-latex .lavs audio/x-liquid-secure .lbm application/x-lbm .lmsff audio/x-la-lms .ls application/x-javascript .ltr application/x-ltr .m1v video/x-mpeg .m2v video/x-mpeg .m3u audio/mpegurl .m4e video/mpeg4 .mac application/x-mac .man application/x-troff-man .math text/xml .mdb application/msaccess .mdb application/x-mdb .mfp application/x-shockwave-flash .mht message/rfc822 .mhtml message/rfc822 .mi application/x-mi .mid audio/mid .midi audio/mid .mil application/x-mil .mml text/xml .mnd audio/x-musicnet-download .mns audio/x-musicnet-stream .mocha application/x-javascript .movie video/x-sgi-movie .mp1 audio/mp1 .mp2 audio/mp2 .mp2v video/mpeg .mp3 audio/mp3 .mp4 video/mpeg4 .mpa video/x-mpg .mpd application/vnd.ms-project .mpe video/x-mpeg .mpeg video/mpg .mpg video/mpg .mpga audio/rn-mpeg .mpp application/vnd.ms-project .mps video/x-mpeg .mpt application/vnd.ms-project .mpv video/mpg .mpv2 video/mpeg .mpw application/vnd.ms-project .mpx application/vnd.ms-project .mtx text/xml .mxp application/x-mmxp .net image/pnetvue .nrf application/x-nrf .nws message/rfc822 .odc text/x-ms-odc .out application/x-out .p10 application/pkcs10 .p12 application/x-pkcs12 .p7b application/x-pkcs7-certificates .p7c application/pkcs7-mime .p7m application/pkcs7-mime .p7r application/x-pkcs7-certreqresp .p7s application/pkcs7-signature .pc5 application/x-pc5 .pci application/x-pci .pcl application/x-pcl .pcx application/x-pcx .pdf application/pdf .pdf application/pdf .pdx application/vnd.adobe.pdx .pfx application/x-pkcs12 .pgl application/x-pgl .pic application/x-pic .pko application/vnd.ms-pki.pko .pl application/x-perl .plg text/html .pls audio/scpls .plt application/x-plt .png image/png .png application/x-png .pot application/vnd.ms-powerpoint .ppa application/vnd.ms-powerpoint .ppm application/x-ppm .pps application/vnd.ms-powerpoint .ppt application/vnd.ms-powerpoint .ppt application/x-ppt .pr application/x-pr .prf application/pics-rules .prn application/x-prn .prt application/x-prt .ps application/x-ps .ps application/postscript .ptn application/x-ptn .pwz application/vnd.ms-powerpoint .r3t text/vnd.rn-realtext3d .ra audio/vnd.rn-realaudio .ram audio/x-pn-realaudio .ras application/x-ras .rat application/rat-file .rdf text/xml .rec application/vnd.rn-recording .red application/x-red .rgb application/x-rgb .rjs application/vnd.rn-realsystem-rjs .rjt application/vnd.rn-realsystem-rjt .rlc application/x-rlc .rle application/x-rle .rm application/vnd.rn-realmedia .rmf application/vnd.adobe.rmf .rmi audio/mid .rmj application/vnd.rn-realsystem-rmj .rmm audio/x-pn-realaudio .rmp application/vnd.rn-rn_music_package .rms application/vnd.rn-realmedia-secure .rmvb application/vnd.rn-realmedia-vbr .rmx application/vnd.rn-realsystem-rmx .rnx application/vnd.rn-realplayer .rp image/vnd.rn-realpix .rpm audio/x-pn-realaudio-plugin .rsml application/vnd.rn-rsml .rt text/vnd.rn-realtext .rtf application/msword .rtf application/x-rtf .rv video/vnd.rn-realvideo .sam application/x-sam .sat application/x-sat .sdp application/sdp .sdw application/x-sdw .sit application/x-stuffit .slb application/x-slb .sld application/x-sld .slk drawing/x-slk .smi application/smil .smil application/smil .smk application/x-smk .snd audio/basic .sol text/plain .sor text/plain .spc application/x-pkcs7-certificates .spl application/futuresplash .spp text/xml .ssm application/streamingmedia .sst application/vnd.ms-pki.certstore .stl application/vnd.ms-pki.stl .stm text/html .sty application/x-sty .svg text/xml .swf application/x-shockwave-flash .tdf application/x-tdf .tg4 application/x-tg4 .tga application/x-tga .tif image/tiff .tif application/x-tif .tiff image/tiff .tld text/xml .top drawing/x-top .torrent application/x-bittorrent .tsd text/xml .txt text/plain .uin application/x-icq .uls text/iuls .vcf text/x-vcard .vda application/x-vda .vdx application/vnd.visio .vml text/xml .vpg application/x-vpeg005 .vsd application/vnd.visio .vsd application/x-vsd .vss application/vnd.visio .vst application/vnd.visio .vst application/x-vst .vsw application/vnd.visio .vsx application/vnd.visio .vtx application/vnd.visio .vxml text/xml .wav audio/wav .wax audio/x-ms-wax .wb1 application/x-wb1 .wb2 application/x-wb2 .wb3 application/x-wb3 .wbmp image/vnd.wap.wbmp .wiz application/msword .wk3 application/x-wk3 .wk4 application/x-wk4 .wkq application/x-wkq .wks application/x-wks .wm video/x-ms-wm .wma audio/x-ms-wma .wmd application/x-ms-wmd .wmf application/x-wmf .wml text/vnd.wap.wml .wmv video/x-ms-wmv .wmx video/x-ms-wmx .wmz application/x-ms-wmz .wp6 application/x-wp6 .wpd application/x-wpd .wpg application/x-wpg .wpl application/vnd.ms-wpl .wq1 application/x-wq1 .wr1 application/x-wr1 .wri application/x-wri .wrk application/x-wrk .ws application/x-ws .ws2 application/x-ws .wsc text/scriptlet .wsdl text/xml .wvx video/x-ms-wvx .xdp application/vnd.adobe.xdp .xdr text/xml .xfd application/vnd.adobe.xfd .xfdf application/vnd.adobe.xfdf .xhtml text/html .xls application/vnd.ms-excel .xls application/x-xls .xlw application/x-xlw .xml text/xml .xpl audio/scpls .xq text/xml .xql text/xml .xquery text/xml .xsd text/xml .xsl text/xml .xslt text/xml .xwd application/x-xwd .x_b application/x-x_b .sis application/vnd.symbian.install .sisx application/vnd.symbian.install .x_t application/x-x_t .ipa application/vnd.iphone .apk application/vnd.android.package-archive .xap application/x-silverlight-app]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java去除字符串中的空格]]></title>
    <url>%2F2019%2F09%2F06%2Ftool4%2F</url>
    <content type="text"><![CDATA[原文链接 123456String str=" Hello World ! ";str=str.trim() //trim()是去掉首尾空格str=str.replace(" ", ""); //去掉所有空格,包括首尾-中间str=str.replaceAll(" ",""); //去掉所有空格 str=str.replaceAll("\\s*", ""); //可以替换大部分空白字符， 不限于空格 \s可以匹配空格、制表符、换页符等空白字符的其中任意一个 System.out.println(str);]]></content>
      <categories>
        <category>工具类/简化开发</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串转化为整形、浮点类型(反之)]]></title>
    <url>%2F2019%2F09%2F06%2Ftool3%2F</url>
    <content type="text"><![CDATA[字符串转化为整形、浮点类型123456789String s = "100";//方法一int a = Integer.parseInt(String s);long b= Long.parseLong(String s);float c= Float.parseFloat(String s);double d= Double.parseDouble(String s) //方法二int a = Integer.valueOf(s).intValue(); float c = Float.valueOf(s).floatValue(); Integer.parseInt(String s)生成的是一个整形 Integer.valueOf(s).intValue()生成的是一个对象(图示代码自动拆箱为基本数据类型) 整形、浮点类型转化为字符串 123456789int i=11;float b=2.5f; //方法一 String s=i+""; //方法二 String s=String.valueOf(i); //方法三 String s=Integer.toString(i); String s2=Float.toString(b);]]></content>
      <categories>
        <category>工具类/简化开发</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java生成一定规则递增编号]]></title>
    <url>%2F2019%2F09%2F06%2Ftool2%2F</url>
    <content type="text"><![CDATA[生成设备编号 项目需求中有时需要生成一定规则递增编号。例如生成设备编号：设备类型+五位编号（从1开始,不够前补0）,也就是SYXH000001/SYXH00002/SDOI00001类似这样。 那么如何处理000001自增1变为000002呢？ 12345678910111213141516171819202122232425262728293031package com.lyf.test;public class Test2 &#123; /** * 生成规则设备编号:设备类型+五位编号（从1开始，不够前补0） * * @param equipmentType * 设备类型 * @param equipmentNo * 最新设备编号 * @return */ public static String getNewEquipmentNo(String equipmentType, String equipmentNo)&#123; String newEquipmentNo = "00001"; if(equipmentNo != null &amp;&amp; !equipmentNo.isEmpty())&#123; int newEquipment = Integer.parseInt(equipmentNo) + 1; newEquipmentNo = String.format(equipmentType + "%05d", newEquipment); &#125; return newEquipmentNo; &#125; public static void main(String[] args) &#123; String equipmentNo = Test2.getNewEquipmentNo("SYXH", "00032"); System.out.println("生成设备编号：" + equipmentNo); //生成设备编号：SYXH00033 &#125;&#125; 从上面代码中可以看到,首先我们默认了一个初始设备编号,当传入方法的最新设备编号为null或是空时将使用。 如果传入了数据库中最新设备编号,将首先Integer的parseInt()方法返回十进制整数,这样就可以对其+1。 最后通过String的format()方法进行字符串格式化返回就可以了。 生成ID模板：年月日时分秒+6位自增码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private static int sequence = 0; private static int length = 6; /** * YYYYMMDDHHMMSS+6位自增长码(20位) * @author shijing * 2015年6月29日下午1:25:23 * @return */ public static synchronized String getLocalTrmSeqNum() &#123; sequence = sequence &gt;= 999999 ? 1 : sequence + 1; String datetime = new SimpleDateFormat("yyyyMMddHHmmss") .format(new Date()); String s = Integer.toString(sequence); return datetime +addLeftZero(s, length); &#125; /** * 左填0 * @author shijing * 2015年6月29日下午1:24:32 * @param s * @param length * @return */ public static String addLeftZero(String s, int length) &#123; // StringBuilder sb=new StringBuilder(); int old = s.length(); if (length &gt; old) &#123; char[] c = new char[length]; char[] x = s.toCharArray(); if (x.length &gt; length) &#123; throw new IllegalArgumentException( "Numeric value is larger than intended length: " + s + " LEN " + length); &#125; int lim = c.length - x.length; for (int i = 0; i &lt; lim; i++) &#123; c[i] = '0'; &#125; System.arraycopy(x, 0, c, lim, x.length); return new String(c); &#125; return s.substring(0, length); &#125; 注意：如果你的ID是Long型,就要注意,Long的最大长度为19位,如果直接转的话会有问题，建议改为年月日时分秒+5位随机数 取当前时间与字母随机组合，并发少的情况足以胜任 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Random; //随机组合16位IDpublic class SeeId&#123; public static void main(String[] args) &#123; Long h = System.currentTimeMillis();//获得当前时间的毫秒数 String str = h.toString();//转化为字符串 int i = str.length();//总长度 int j = i-7;//用来取此字符串的末尾7位数，因为前面的数是年份什么的基本不变，我们只用后面的7位 char[] charArray = str.substring(j,i).toCharArray();//将取到的7位数做成数组 //将26位字母做成数组 String [] arr = &#123;"a", "b", "c", "d","e", "f", "g", "h","i","g", "k", "l","m", "n", "o", "p","q", "r", "s", "t", "u", "v", "w", "x","y", "z"&#125;; //将字母数组随机取3个字母组成一个字符串，一共组成3个字符串放到目标数组target中 StringBuffer uniqueId = new StringBuffer();//用于生成唯一ID Random random = new Random();//用于取随机数和布尔值 boolean insertflag = true;//用来控制是插入数字还是字母 int timecount = 0;//用来控制插入数字的长度，别超过7 int zimucount = 0;//用来控制插入字母的总数，别超过9 7个数字加上9个字母组合 boolean timeflag = true;//判断时间是否插入了7位，默认true为不满 boolean zimuflag = true;//判断字母是否插入了9位，默认true为不满 while (zimucount&lt;9||timecount&lt;7) &#123;//开始组合 if(insertflag)&#123;//默认为ture，先加字母，你也可以先加数字 if (zimucount&lt;9) &#123;//如果uniqueId插入的字母总数没超过9个 uniqueId.append(arr[random.nextInt(26)]);//则在字母数组中随机选一个插入 zimucount++;//对应加1 if(timeflag)&#123;//如果时间没有插入满7位则重新抓阄看插入时间还是数字 insertflag = random.nextBoolean();//重置flag，随机产生false还是true &#125;//如果timeflag=false,时间数字已经插入满7位，则不抓阄了。保持insertflag=true &#125;else&#123;//如果已经加够了否则不操作， zimuflag = false;//将zimuflag变为已加够，false insertflag = false;//将插入权判断给时间数字 &#125; &#125;else&#123; if (timecount&lt;7) &#123;//先加时间转化成的数组，你也可以先加字母 //此处取时间数字数组不能用random随机取。那样用时间来生成数组就没意义了 uniqueId.append(charArray[timecount]);//不可打乱顺序 timecount++;//对应加1 if(zimuflag)&#123;//如果字母没有插入满9位则重新抓阄看插入时间还是数字 insertflag = random.nextBoolean(); &#125;//如果zimuflag=false,字幕已经插入满9位，则不抓阄了。保持insertflag=false &#125;else&#123; timeflag = false;//将timeflag变为已加够，false insertflag = true;//将插入权判断给字母 &#125; &#125; &#125; System.out.println(uniqueId.toString());//得到最终id &#125;&#125;]]></content>
      <categories>
        <category>工具类/简化开发</category>
      </categories>
      <tags>
        <tag>规则编号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对日期Date相应处理]]></title>
    <url>%2F2019%2F09%2F06%2Ftool1%2F</url>
    <content type="text"><![CDATA[参考链接:Java对日期Date相应处理时间相减得到天数JAVA获取当前时间的前一天或者前几天时间1234567891011121314/** * JAVA获取当前时间的前一天或者前几天时间 * @param date 当前时间 new Date() * @return */ public String getTime(Date date)&#123; SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd"); Calendar calendar = Calendar.getInstance(); calendar.setTime(date); //获取后一天的当前时间 +1即可 calendar.add(Calendar.DAY_OF_MONTH, -1); date = calendar.getTime(); return sdf.format(date); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342package com.data.utils;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class DateFormat &#123; /** * 补充:功能描述：时间相减得到天数 * @param beginDateStr * @param endDateStr * @return * long * @author Administrator */ public static long getDaySub(String beginDateStr,String endDateStr) &#123; long day=0; java.text.SimpleDateFormat format = new java.text.SimpleDateFormat("yyyy-MM-dd"); java.util.Date beginDate; java.util.Date endDate; try &#123; beginDate = format.parse(beginDateStr); endDate= format.parse(endDateStr); day=(endDate.getTime()-beginDate.getTime())/(24*60*60*1000); //System.out.println("相隔的天数="+day); &#125; catch (ParseException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; return day; &#125; /** * 日期减几年 */ public static String dateMinusYear(String str) throws Exception &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyyMM"); Date dt = sdf.parse(str); Calendar rightNow = Calendar.getInstance(); rightNow.setTime(dt); rightNow.add(Calendar.YEAR, -1);// 日期减1年 Date dt1 = rightNow.getTime(); String reStr = sdf.format(dt1); return reStr; &#125; /** * 日期加几年 */ public static String dateAddYear(String str) throws Exception &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyyMM"); Date dt = sdf.parse(str); Calendar rightNow = Calendar.getInstance(); rightNow.setTime(dt); rightNow.add(Calendar.YEAR, 1);// 日期加1年 Date dt1 = rightNow.getTime(); String reStr = sdf.format(dt1); return reStr; &#125; /** * 日期减几月 */ public static String dateMinusMonth(String str) throws Exception &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyyMM"); Date dt = sdf.parse(str);//将字符串生成Date Calendar rightNow = Calendar.getInstance(); rightNow.setTime(dt);//使用给定的 Date 设置此 Calendar 的时间。 rightNow.add(Calendar.MONTH, -1);// 日期减1个月 Date dt1 = rightNow.getTime();//返回一个表示此 Calendar 时间值的 Date 对象。 String reStr = sdf.format(dt1);//将给定的 Date 格式化为日期/时间字符串，并将结果添加到给定的 StringBuffer。 return reStr; &#125; /** * 日期加几月 */ public static String dateAddMonth(String str) throws Exception &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyyMM"); Date dt = sdf.parse(str); Calendar rightNow = Calendar.getInstance(); rightNow.setTime(dt); rightNow.add(Calendar.MONTH, 1);// 日期加3个月 // rightNow.add(Calendar.DAY_OF_YEAR,10);//日期加10天 Date dt1 = rightNow.getTime(); String reStr = sdf.format(dt1); return reStr; &#125; /** * 获取当前年月的第一个月的str * @param str * 201505 * @return 201501 * @throws Exception */ public static String dateOneMonth(String str) &#123; str = str.substring(0, str.length() - 2); str = str + "01"; return str; &#125; /** * 算出所选月份距离一月份有几个月。 * @param str 201509 * @return 9 */ public static int dateDistanceMonth(String str) &#123; int i = Integer.parseInt(str); int j = Integer.parseInt(DateFormat.dateOneMonth(str)); System.out.println(i - j); return i - j + 1; &#125; /** * 获取两个时间的时间差，精确到毫秒 * @param str * @return */ public static String TimeDifference(long start, long end) &#123; long between = end - start; long day = between / (24 * 60 * 60 * 1000); long hour = (between / (60 * 60 * 1000) - day * 24); long min = ((between / (60 * 1000)) - day * 24 * 60 - hour * 60); long s = (between / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60); long ms = (between - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000 - min * 60 * 1000 - s * 1000); String timeDifference = day + "天" + hour + "小时" + min + "分" + s + "秒" + ms + "毫秒"; return timeDifference; &#125;&#125; /** * 获取24小时、一周、一个月的起始时间 * * @param timeInterval * : DAY_TIME_INTERVAL WEEK_TIME_INTERVAL MONTH_TIME_INTERVAL * @return "yyyy-mm-dd hh:mm:ss" */ public static String getStartTime(int timeInterval) &#123; Calendar cal = Calendar.getInstance(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); if (DAY_TIME_INTERVAL == timeInterval) &#123;// 获取24小时的起始时间 cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); String startTime = sdf.format(cal.getTime()); return startTime; &#125; else if (WEEK_TIME_INTERVAL == timeInterval) &#123; int weekday = cal.get(Calendar.DAY_OF_WEEK) - 1; cal.add(Calendar.DATE, -weekday); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); String startTime = sdf.format(cal.getTime()); return startTime; &#125; else if (MONTH_TIME_INTERVAL == timeInterval) &#123; int dayofmonthMin = cal.getActualMinimum(Calendar.DAY_OF_MONTH); // c.add(Calendar.DATE, -dayofmonth); cal.set(Calendar.DATE, dayofmonthMin); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); String startTime = sdf.format(cal.getTime()); return startTime; &#125; return null; &#125; /** * 获取24小时、一周、一个月的结束时间 * * @param timeInterval * : DAY_TIME_INTERVAL WEEK_TIME_INTERVAL MONTH_TIME_INTERVAL * @return "yyyy-mm-dd hh:mm:ss" */ public static String getEndTime(int timeInterval) &#123; Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone("GMT+8")); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); if (DAY_TIME_INTERVAL == timeInterval) &#123; cal.set(Calendar.HOUR_OF_DAY, 23); cal.set(12, 59); cal.set(13, 59); long date = cal.getTimeInMillis(); String endTime = sdf.format(new Date(date)); return endTime; &#125; else if (WEEK_TIME_INTERVAL == timeInterval) &#123; int weekday = cal.get(Calendar.DAY_OF_WEEK) - 1; cal.add(Calendar.DATE, -weekday); cal.add(Calendar.DATE, 6); cal.set(Calendar.HOUR_OF_DAY, 23); cal.set(12, 59); cal.set(13, 59); long date = cal.getTimeInMillis(); String endTime = sdf.format(new Date(date)); return endTime; &#125; else if (MONTH_TIME_INTERVAL == timeInterval) &#123; int dayOfMonthMax = cal.getActualMaximum(Calendar.DAY_OF_MONTH); cal.set(Calendar.DATE, dayOfMonthMax); cal.set(Calendar.HOUR_OF_DAY, 23); cal.set(Calendar.MINUTE, 59); cal.set(Calendar.SECOND, 59); String endTime = sdf.format(cal.getTime()); return endTime; &#125; return null; &#125; /** * 判断dateStr是否在start和end中间，start和end都可以为null yyyyMMddHHmmss或者yyyyMMdd格式 * * @author you.xu * @date 2015年8月19日下午3:11:46 * @param dateStr * @param start * @param end * @return */ public static boolean checkDateVal(String dateStr, String start, String end) &#123; boolean isDateRight = false; Date date = null; Date startDate = null; Date endDate = null; SimpleDateFormat sdf = null; // 判断日期格式 if (14 == dateStr.length()) &#123; sdf = new SimpleDateFormat("yyyyMMddHHmmss"); &#125; else if (8 == dateStr.length()) &#123; sdf = new SimpleDateFormat("yyyyMMdd"); &#125; else return false; try &#123; // 更改判断日期格式 date = sdf.parse(dateStr); &#125; catch (ParseException e) &#123; log.error(e, e); &#125; if ((start == null) &amp;&amp; (end != null)) &#123; try &#123; endDate = sdf.parse(end); &#125; catch (ParseException ex1) &#123; log.error(ex1, ex1); &#125; if ((date != null) &amp;&amp; (endDate != null))// Check parameters for &#123; if (date.compareTo(endDate) &lt;= 0) isDateRight = true; &#125; &#125; else if ((start != null) &amp;&amp; (end == null)) &#123; try &#123; startDate = sdf.parse(start); &#125; catch (ParseException ex1) &#123; log.error(ex1, ex1); &#125; if ((date != null) &amp;&amp; (startDate != null)) &#123; if (date.compareTo(startDate) &gt;= 0) isDateRight = true; &#125; &#125; else if ((start != null) &amp;&amp; (end != null)) &#123; try &#123; startDate = sdf.parse(start); endDate = sdf.parse(end); &#125; catch (ParseException ex2) &#123; System.out.println(ex2.toString()); &#125; if ((startDate != null) &amp;&amp; (date != null) &amp;&amp; (endDate != null)) &#123; if ((date.compareTo(startDate) &gt;= 0) &amp;&amp; (date.compareTo(endDate) &lt;= 0)) isDateRight = true; &#125; &#125; return isDateRight; &#125; /** * 判断dateStr是否在start和end中间，start和end都可以为null long形格式 * * @author you.xu * @date 2015年8月19日下午3:12:35 * @param dateStr * @param start * @param end * @return */ public static boolean checkDateV(String dateStr, String start, String end) &#123; boolean isDateRight = false; long date = -1; long fromDate = -1; long toDate = -1; date = java.lang.Long.parseLong(dateStr); if ((start == null) &amp;&amp; (end == null)) &#123; isDateRight = true; &#125; else if ((start == null) &amp;&amp; (end != null)) &#123; try &#123; toDate = java.lang.Long.parseLong(end); &#125; catch (NumberFormatException nfe) &#123; log.error(nfe, nfe); &#125; if (date &lt;= toDate) &#123; isDateRight = true; &#125; &#125; else if ((start != null) &amp;&amp; (end == null)) &#123; try &#123; fromDate = java.lang.Long.parseLong(start); &#125; catch (NumberFormatException nfe) &#123; log.error(nfe, nfe); &#125; if (date &gt;= fromDate) &#123; isDateRight = true; &#125; &#125; else if ((start != null) &amp;&amp; (end != null)) &#123; try &#123; toDate = java.lang.Long.parseLong(end); fromDate = java.lang.Long.parseLong(start); &#125; catch (NumberFormatException nfe) &#123; log.error(nfe, nfe); &#125; if ((date &lt;= toDate) &amp;&amp; (date &gt;= fromDate)) &#123; isDateRight = true; &#125; &#125; return isDateRight; &#125;]]></content>
      <categories>
        <category>工具类/简化开发</category>
      </categories>
      <tags>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Requestbody接收json参数映射到实体类中Date(时间日期)类型转换问题]]></title>
    <url>%2F2019%2F09%2F06%2Fspringboot4%2F</url>
    <content type="text"><![CDATA[场景： 前台ajax提交, 后台@requestbody接收json参数 映射到 实体类中 Date（时间日期）类型转换 解决方案： JsonFormat ：出参 DateTimeFormate ： 入参 123@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)private Date startTime; pattern 指定转化的格式 locale 主要指语言，如果中文的话，月份输出是五月，但是英文就是May timezone主要解决“8小时”问题(时区问题)]]></content>
      <categories>
        <category>Exception</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[application.properties常用设置]]></title>
    <url>%2F2019%2F09%2F06%2Fspringboot3%2F</url>
    <content type="text"><![CDATA[application.properties常用设置1.编码格式 1234spring.http.encoding.force=truespring.http.encoding.charset=UTF-8spring.http.encoding.enabled=trueserver.tomcat.uri-encoding=UTF-8]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发环境、测试环境、生产环境、UAT环境、仿真环境]]></title>
    <url>%2F2019%2F09%2F06%2Fxzs1%2F</url>
    <content type="text"><![CDATA[参考链接 开发环境(DEV)：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意， 为了开发调试方便，一般打开全部错误报告。 测试环境(UAT)：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。 生产环境(PROD)：是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。可以理解为包含所有的功能的环境，任何项目所使用的环境都以这个为基础，然后根据客户的个性化需求来做调整或者修改。 三个环境也可以说是系统开发的三个阶段：开发-&gt;测试-&gt;上线，其中生产环境也就是通常说的真实环境。 UAT环境：UAT,(User Acceptance Test),用户接受度测试 即验收测试，所以UAT环境主要是用来作为客户体验的环境。 仿真环境：顾名思义是和真正使用的环境一样的环境（即已经出售给客户的系统所在环境，也成为商用环境），所有的配置，页面展示等都应该和商家正在使用的一样，差别只在环境的性能方面。]]></content>
      <categories>
        <category>小知识</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保存时间比当前时间少8小时]]></title>
    <url>%2F2019%2F09%2F06%2Fspringboot2%2F</url>
    <content type="text"><![CDATA[原因：时区问题 解决方案： 在连接url增加时区设置参数(时区GMT+8的设置) 1jdbc:mysql://localhost/database?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2b8]]></content>
      <categories>
        <category>Exception</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[No primary or default constructor found ...]]></title>
    <url>%2F2019%2F09%2F06%2Fspringboot1%2F</url>
    <content type="text"><![CDATA[No primary or default constructor found for interface java.util.List 原因: 调用请求进行参数映射时出错. 解决方法(加上注解即可) 123public Object showCollectPros(@RequestParam(value = "content") List&lt;String&gt; content) &#123; do smoething...&#125;]]></content>
      <categories>
        <category>Exception</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jpa多表原生sql自定义字段条件查询并进行分页和排序(时间格式)]]></title>
    <url>%2F2019%2F09%2F06%2FJPA2%2F</url>
    <content type="text"><![CDATA[Jpa多表原生sql自定义字段条件查询并进行分页和排序 参考链接 前台使用的是layui 由于后台jpa多表查询使用的是 List&lt;Map&lt;String, Object&gt;&gt; 自定义字段输出 因此时间create_time方面会出现问题,template定义的有解决方法. 前台部分代码 12345678910111213141516171819202122232425262728293031323334353637 table.render(&#123; elem: '#demo', url: server + 'orders/getAllOrders', cellMinWidth: 80, size: 'lg', title: 'orders', cols: [ [ //标题栏 &#123; checkbox: true &#125;, &#123; field: 'order_no', title: 'orderNo', sort: true &#125;, &#123; field: 'uno', title: 'uno', sort: true, align: 'center' &#125;, &#123; field: 'create_time', title: 'createTime', sort: true,//特殊日期格式转换2018-12-03T17:17:36.000+08:00 转化为2018-12-03 00:00:00(正则表达式的方法) templet: function(d) &#123; var dateee = new Date(d.create_time).toJSON(); var date = new Date(+new Date(dateee) + 8 * 3600 * 1000).toISOString().replace(/T/g, ' ').replace(/\.[\d]&#123;3&#125;Z/, '') return date; &#125;, align: 'center' &#125; ,..... ]] &#125;); 实体类接收前台传来条件 123456789101112131415161718192021/** @ClassName：ProductSelect @Author：yyr @Date：2019-04-16 9:54 @Description：分页查询使用条件类 */@Datapublic class ProductSelect &#123; //当前第几页 private int page; //每页多少条数据 private int limit; //模糊查询名称条件 private String name=""; //订单类型 private String selectType=""; //按某一列进行排序 private String field; //排序方式(ASC/DESC) private String order;&#125; Controller方法定义 12345678910111213141516171819202122232425262728293031323334353637383940414243@ApiOperation(value = "条件查询订单详细信息并进行分页", notes = "条件查询订单详细信息并进行分页") @ApiImplicitParam(name = "pro", value = "查询的条件", required = true, dataType = "ProductSelect") @RequestMapping(value = "/getAllOrders", method = RequestMethod.GET) public Object getAllOrders(ProductSelect pro) &#123; Sort sort=null; if (pro.getField() == null) &#123; //默认时间降序排序 sort=new Sort(Sort.Direction.ASC,"create_time"); &#125; else &#123; String s="desc"; if(pro.getOrder().equals(s))&#123; sort=new Sort(Sort.Direction.DESC,pro.getField()); &#125;else&#123; sort=new Sort(Sort.Direction.ASC,pro.getField()); &#125; &#125; String type = pro.getSelectType(); String order_type = ""; if (type != "") &#123; switch (type) &#123; case "pro": order_type = "PI"; break; case "point": order_type = "GI"; break; case "demand": order_type = "DE"; break; default: System.out.println("没有啦"); &#125; &#125; //接收的名称 String name = pro.getName(); //分页和排序 Pageable pageable= PageRequest.of(pro.getPage() - 1,pro.getLimit(),sort); //条件查询后排序和分页后的数据 List&lt;Map&lt;String, Object&gt;&gt; list = productOrderDao.getAllOrders(name, order_type,pageable); //条件查询后数据总条数 int total = productOrderDao.getTotal(name, order_type); return MapTool.paging(list, total); &#125; MapTool工具类 (layui前台接收数据时有一定格式要求的,所以要按一定格式返回) 12345678910public class MapTool &#123; private static Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); public static Object paging(List&lt;?&gt; list, long count) &#123; map.put("count", count); map.put("code", 0); map.put("msg", "返回信息成功"); map.put("data", list); return map; &#125; &#125; 接口:原生sql多表条件查询 1234567891011121314151617181920212223242526272829public interface ProductOrderDao extends JpaRepository&lt;ProductOrder,Integer&gt; &#123;/** * 获取条件查询后的订单 * @param name 订单编号/客户编号/业务编号(产品订单+积份订单+需求订单 取三种订单的共同字段-订单编号,客户编号,订单状态,创建时间,业务编号) * @param type 订单类型 * @param sort 分页排序 * @return */ @Query(value = "select * from (SELECT p.order_no ,p.uno,p.order_status ,p.create_time ,(SELECT sno FROM users WHERE uno=p.uno)sno " + " FROM product_order p UNION " + "SELECT g.order_no,g.uno,g.status,g.charge_time,(SELECT sno FROM users WHERE uno=g.uno)sno FROM gift_charge g " + "UNION SELECT d.orderno,d.uno,d.status,d.createtime, (SELECT sno FROM users WHERE uno=d.uno)sno FROM demands d " + " ) p WHERE (order_no LIKE concat('%',?1,'%') OR uno LIKE concat('%',?1,'%') OR sno LIKE concat('%',?1,'%')) " + " AND order_no LIKE concat('%',?2,'%') ",nativeQuery = true) List&lt;Map&lt;String, Object&gt;&gt; getAllOrders( String name, String type, Pageable sort); /** * 获取条件查询后订单的总数 * @param name 订单编号/客户编号/业务编号 * @param type 订单类型 * @return */ @Query(value = "select count(*) from (SELECT p.order_no,p.uno,p.order_status,p.create_time,(SELECT sno FROM users WHERE uno=p.uno)sno " + " FROM product_order p UNION " + "SELECT g.order_no,g.uno,g.status,g.charge_time,(SELECT sno FROM users WHERE uno=g.uno)sno FROM gift_charge g " + "UNION SELECT d.orderno,d.uno,d.status,d.createtime, (SELECT sno FROM users WHERE uno=d.uno)sno FROM demands d )t" + " WHERE (order_no LIKE concat('%',?1,'%') OR uno LIKE concat('%',?1,'%') OR sno LIKE concat('%',?1,'%')) " + " AND order_no LIKE concat('%',?2,'%') " ,nativeQuery = true) int getTotal(String name, String type);&#125; 经测试可用,但需注意getAllOrders()sql编写:排序时可先正常编写sql,运行后检查控制台sql语句后跟随的排序是如何定义的,以创建时间升序为例-本接口下sql语句后跟随的是 1order by p.create_time asc limit ? 后台sql中会自动给字段找了个别名引用,或许跟接口定义有关吧 1ProductOrderDao extends JpaRepository&lt;ProductOrder,Integer&gt; 因此将查询后的数据重新放进另一张表并定义好别名p: 这样sql语句运行时就不会出现字段异常 1select * from (需要查询的数据) p 原接口本想使用 1Page&lt;Map&lt;String, Object&gt;&gt; getAllOrders( String name, String type, Pageable sort); 这样count就不需要手动再次编写,但是查询总数时出现问题 count查询语句不正确,因此放弃 最后分两步走,先条件查询数据,再条件查询count]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Layui</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA调用存储过程实例]]></title>
    <url>%2F2019%2F09%2F06%2FJPA1%2F</url>
    <content type="text"><![CDATA[参考链接 SQL方面 假设调用的存储过程形式如下：12call PROCEDURE in_only_test (inParam1 IN VARCHAR);call PROCEDURE in_and_out_test (inParam1 IN VARCHAR, outParam1 OUT VARCHAR); 这里有两个存储过程： in\_only\_test 它需要一个输入参数inParam1,但不返回值 in\_and\_out\_test 它需要一个输入参数inParam1,且返回值outParam1 JPA方面 我们可以使用@NamedStoredProcedureQueries来调用存储过程。 12345678910@Entity@Table(name = "MYTABLE")@NamedStoredProcedureQueries(&#123; @NamedStoredProcedureQuery(name = "in_only_test", procedureName = "in_only_test", parameters = &#123; @StoredProcedureParameter(mode = ParameterMode.IN, name = "inParam1", type = String.class) &#125;), @NamedStoredProcedureQuery(name = "in_and_out_test", procedureName = "in_and_out_test", parameters = &#123; @StoredProcedureParameter(mode = ParameterMode.IN, name = "inParam1", type = String.class), @StoredProcedureParameter(mode = ParameterMode.OUT, name = "outParam1", type = String.class) &#125;) &#125;)public class MyTable implements Serializable &#123;&#125; 关键要点:存储过程使用了注释@NamedStoredProcedureQuery并绑定到一个JPA表。procedureName是存储过程的名字name是JPA中的存储过程的名字。使用注释@StoredProcedureParameter来定义存储过程使用的IN/OUT参数 MyTableRepository仓库调用存储过程 123456public interface MyTableRepository extends CrudRepository&lt;MyTable, Long&gt; &#123; @Procedure(name = "in_only_test") void inOnlyTest(@Param("inParam1") String inParam1); @Procedure(name = "in_and_out_test") String inAndOutTest(@Param("inParam1") String inParam1);&#125; 关键要点: @Procedure的name参数必须匹配@NamedStoredProcedureQuery的name @Param必须匹配@StoredProcedureParameter注释的name参数 返回类型必须匹配:in_only_test存储过程返回是void,in_and_out_test存储过程必须返回String 调用 123456// 向存储过程传递参数并返回值String inParam = "Hi Im an inputParam";String outParam = myTableRepository.inAndOutTest(inParam);Assert.assertEquals(outParam, "Woohoo Im an outparam, and this is my inparam Hi Im an inputParam");// 向存储过程传递参数不返回值myTableRepository.inOnlyTest(inParam); 其它技巧 原生sql查询 123//本案例为自定义的结果数据@Query(value = " call get_order(?1,?2,?3,?4)", nativeQuery = true)List&lt;Map&lt;String, Object&gt;&gt; showOrderMoney( String begin, String end, String sno, String country); 需注意:该存储过程本身主要针对的是select返回数据,即调用存储过程之后本身就有结果,所有与out参数无关. 定义自定义的Repository来调用存储过程 定义自定义的Repository: 123public interface MyTableRepositoryCustom &#123; void inOnlyTest(String inParam1);&#125; 然后要确保主Repository类继承了这个接口。 12public interface MyTableRepository extends CrudRepository&lt;MyTable, Long&gt;, MyTableRepositoryCustom &#123;&#125; 创建Repository实现类 12345678public class MyTableRepositoryImpl implements MyTableRepositoryCustom &#123;@PersistenceContextprivate EntityManager em;@Overridepublic void inOnlyTest(String inParam1) &#123; this.em.createNativeQuery("BEGIN in_only_test(:inParam1); END;").setParameter("inParam1", inParam1) .executeUpdate();&#125;&#125; 可以以常规的方式进行调用 1234@AutowiredMyTableRepository myTableRepository;// 调用存储过程myTableRepository.inOnlyTest(inParam1);]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>存储过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList循环遍历并删除元素的常见陷阱]]></title>
    <url>%2F2019%2F09%2F06%2Fjihe4%2F</url>
    <content type="text"><![CDATA[参考链接 代码示例 1234567891011121314151617181920212223import java.util.ArrayList;public class ArrayListRemove&#123; publicstaticvoidmain(String[]args) &#123; ArrayList&lt;String&gt;list=newArrayList&lt;String&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); remove(list); for(Strings:list) &#123; System.out.println(&quot;element : &quot;+s); &#125; &#125; public static void remove(ArrayList&lt;String&gt; list) &#123; // TODO: &#125;&#125; 操作：想删除list的b字符 1.错误例子1： 1234567891011public static void remove(ArrayList&lt;String&gt; list)&#123; for(inti=0;i&lt;list.size();i++) &#123; Strings=list.get(i); if(s.equals(&quot;b&quot;)) &#123; list.remove(s); &#125; &#125;&#125; 效果：这种最普通的循环写法执行后会发现第二个“b”的字符串没有删掉 原因： 翻开JDK的ArrayList源码，先看下ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是入参不同，这里看的是入参为Object的remove方法）是怎么实现的： 12345678910111213141516public boolean remove(Objecto)&#123; if(o==null)&#123; for(intindex=0;index&lt;size;index++) if(elementData[index]==null)&#123; fastRemove(index); return true; &#125; &#125;else&#123; for(intindex=0;index&lt;size;index++) if(o.equals(elementData[index]))&#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 一般情况下程序的执行路径会走到else路径下最终调用faseRemove方法： 1234567private void fastRemove(int index)&#123; modCount++; intnumMoved=size-index-1; if(numMoved&gt;0) System.arraycopy(elementData,index+1,elementData,index,numMoved); elementData[--size]=null;// Let gc do its work&#125; 可以看到会执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。在遍历第一个字符串b时因为符合删除条件，所以将该元素从数组中删除，并且将后一个元素移动（也就是第二个字符串b）至当前位置，导致下一次循环遍历时后一个字符串b并没有遍历到，所以无法删除。 针对这种情况可以_倒序删除_的方式来避免（因为数组倒序遍历时即使发生元素删除也不影响后序元素遍历）： 1234567891011public static void remove(ArrayList&lt;String&gt; list)&#123; for(inti=list.size()-1;i&gt;=0;i--) &#123; Strings=list.get(i); if(s.equals(&quot;b&quot;)) &#123; list.remove(s); &#125; &#125;&#125; 2.错误例子2： 12345678910public static void remove(ArrayList&lt;String&gt; list)&#123; for(Strings:list) &#123; if(s.equals(&quot;b&quot;)) &#123; list.remove(s); &#125; &#125;&#125; 效果:这种for-each写法会报出著名的并发修改异常： java.util.ConcurrentModificationException 原因： foreach写法是对实际的Iterable、hasNext、next方法的简写，问题同样处在上文的fastRemove方法中，可以看到第一行把modCount变量的值加一，但在ArrayList返回的迭代器（该代码在其父类AbstractList中） 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法： 1234567891011public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125;&#125; checkForComodification方法： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 这里会做迭代器内部修改次数检查，因为上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。 针对这种情况可以在使用迭代器迭代时（显示或for-each的隐式）不要使用ArrayList的remove,改为用Iterator的remove的方式来避免: 123456789101112public static void remove(ArrayList&lt;String&gt; list) &#123; Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext()) &#123; String s = it.next(); if (s.equals(&quot;b&quot;)) &#123; it.remove(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速初始化list和map]]></title>
    <url>%2F2019%2F09%2F06%2Fjihe3%2F</url>
    <content type="text"><![CDATA[参考详解链接 List 1234567891011public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;()&#123; &#123; add("周一"); add("周五"); &#125; &#125;; System.out.println("list=="+list); &#125; Map 1234567891011public static void main(String[] args) &#123; System.out.println( new HashMap&lt;String, Object&gt;()&#123; &#123; put("上班", "不开心"); put("下班", "开心"); &#125; &#125;); &#125;]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对List集合中的元素进行排序]]></title>
    <url>%2F2019%2F09%2F06%2Fjihe1%2F</url>
    <content type="text"><![CDATA[参考链接 场景 有时候需要对集合中的元素按照一定的规则进行排序，这就需要用到,Java中提供的对集合进行操作的工具类Collections，其中的sort方法 实践 简单的例子: 12345678910public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;(); nums.add(3); nums.add(5); nums.add(1); nums.add(0); System.out.println(nums); //[3, 5, 1, 0] Collections.sort(nums); System.out.println(nums); //[0, 1, 3, 5]&#125; 复杂例子(list里装有对象): 1.Collections提供的第一种排序方法Comparable&lt;T&gt; compareTo()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package core.java.collection.collections;public class User implements Comparable&lt;User&gt;&#123; private int score; private int age; public User(int score, int age)&#123; super(); this.score = score; this.age = age; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public int compareTo(User o) &#123; int i = this.getAge() - o.getAge();//先按照年龄排序 if(i == 0)&#123; return this.score - o.getScore();//如果年龄相等了再用分数进行排序 &#125; return i; &#125;&#125;public static void main(String[] args) &#123; List&lt;User&gt; users = new ArrayList&lt;User&gt;(); users.add(new User(78, 26)); users.add(new User(67, 23)); users.add(new User(34, 56)); users.add(new User(55, 23)); Collections.sort(users); for(User user : users)&#123; System.out.print(user.getScore() + "," + user.getAge()+"\t\t"); //输出结果：55,23 67,23 78,26 34,56 &#125;&#125; 我们会发现sort(List&lt;T&gt;)方法中List中的T必须实现Comparable&lt;T&gt;接口，然后实现compareTo()方法，该方法的返回值0代表相等，1表示大于，-1表示小于;为什么在简单例子中没有看到实现Comparable接口呢？是因为Integer类其实自己已经实现了Comparable接口,Java已经给我们做好了。 2.Collections提供的第二种排序方法sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package core.java.collection.collections;public class Students &#123; private int age; private int score; public Students(int age, int score)&#123; super(); this.age = age; this.score = score; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125;&#125;public static void main(String[] args) &#123; List&lt;Students&gt; students = new ArrayList&lt;Students&gt;(); students.add(new Students(23, 100)); students.add(new Students(27, 98)); students.add(new Students(29, 99)); students.add(new Students(29, 98)); students.add(new Students(22, 89)); Collections.sort(students, new Comparator&lt;Students&gt;() &#123; @Override public int compare(Students o1, Students o2) &#123; int i = o1.getScore() - o2.getScore(); if(i == 0)&#123; return o1.getAge() - o2.getAge(); &#125; return i; &#125; &#125;); for(Students stu : students)&#123; System.out.print("score:" + stu.getScore() + ":age" + stu.getAge()+"\t\t"); //输出结果： score:89:age22 score:98:age27 score:98:age29 score:99:age29 score:100:age23 &#125;&#125; 从上面的例子我们可以看出Students类没有实现Comparable&lt;T&gt;接口，只是在sort()方法中多传入一个参数，只不过该参数是一个接口我们需要实现其compare方法。]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>Collections</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 常用配置]]></title>
    <url>%2F2019%2F09%2F06%2Fcykz%2F</url>
    <content type="text"><![CDATA[配置编码问题显示工具栏以及工具按钮栏配置相关的工作空间重点理解项目class文件生成（运行打包编译文件存储路径）配置IDEA构建项目的时候默认生成的iml文件配置改成.classpath类型的文件IDEA中导入jar的源码如果是Maven项目的时候，自动默认下载源码包，如果是javaWeb或者简单的java项目，自定义加入的jar是没有源码的，这时候手动添加源码包。 设置工作空间中项目的相关的设置 设置编码区字体的大小、字体类型、代码行距距离等##### 工具按钮可以在区域范围中推动摆设 添加tomcat等服务设置 DEDUG模式调试配置 配置各种文件的生成模板 配置一个class文件成的模板 IDEA类和方法注释模板设置（非常详细）快捷键设置 代码动态模板 例如： 控制台打印日志的各种级别的颜色配置空格与tab缩进设置插件安装卸载配置常用快捷键Ctrl+N ：快速查找文件 Alt + F1 ：快速定位文件在那个位置]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将集合转换成字符串(反之)]]></title>
    <url>%2F2019%2F09%2F06%2Fjihe2%2F</url>
    <content type="text"><![CDATA[将集合转换成字符串StringUtils工具类下的join()方法：12345678910111213141516import java.util.ArrayList;import java.util.List;import org.apache.commons.lang3.StringUtils;public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;aa&quot;); list.add(&quot;bb&quot;); list.add(&quot;cc&quot;); System.out.println(list); // 将集合转换成字符串 String str = StringUtils.join(list, &quot;,&quot;); //打印出字符串 System.out.println(str); &#125;&#125; 使用join()方法时，要传两个参数，一个是要转换的集合list，一个是要用符号分开的分隔符，这样利用工具类就会自动转换成“,”分隔的字符串形式。 字符串转换成集合12345678910111213import java.util.Arrays;import java.util.List;public class Test1 &#123; public static void main(String[] args) &#123; String str=&quot;aa,bb,cc&quot;; //用逗号将字符串分开，得到字符串数组 String[] String[] strs=str.split(&quot;,&quot;); //将字符串数组转换成集合list List&lt;String&gt; list = Arrays.asList(strs); //打印出集合 System.out.println(list); &#125;&#125; 注意：包的导入！]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 快捷键]]></title>
    <url>%2F2019%2F09%2F06%2Fideakuai-jie-jian%2F</url>
    <content type="text"><![CDATA[*编辑类 Ctrl+Space 基本代码实例（类、方法、变量） Ctrl + Shift + Space 智能代码实例（根据需要的类型过滤方法和变量） Ctrl + Shift + Enter 完整的声明(如有代码提示，自动获取第一个并在句尾加上分号结束。无提示，在此行下新增一行) Ctrl + P 参数信息（在方法调用参数时使用） Ctrl + Q Doc说明文档快速查看 Shift + F1 查看外部doc文档 Ctrl +鼠标放在代码上面 代码的简要doc说明（基本上是类或者方法的声明） Ctrl + F1 查看光标所在处的错误或者警告的详细信息 Alt + Insert 生成代码（Getter、Setter、Constructors、hashCode…） Ctrl + O 重写方法 Ctrl + I 实现方法 Ctrl + Alt + T 将光标所处行的代码用语句块（if…else、try…catch…）包围 Ctrl + / 注释/反注释光标所在行（自动换行） Ctrl + Shift + / 注释/反注释代码块 Ctrl + W 递增地（代码块所包含的范围增大）选择连续的代码块 Ctrl + Shift + W 在用了Ctrl + W后，减小代码块所包含的范围 Alt + Q 上下文信息 Alt + Enter 显示意图动作和快速修复 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 优化Imports（去掉不必要的） Ctrl + Alt + I 代码自动对齐 Tab / Shift + Tab 缩进/反缩进所选行 Ctrl+X or Shift+Delete 剪切行/代码块到剪贴板(默认全选一行) Ctrl+C or Ctrl+Insert 复制行/代码块到剪贴板(默认全选一行) Ctrl+V or Shift+Insert 粘贴剪贴板中的内容 Ctrl+Shift + V 粘贴剪贴板中缓存的内容 Ctrl+D 复制当前行/代码块的一个副本并插入到内容中 Ctrl+Y 删除光标所在行 Ctrl+Shift + J 智能行合并(在本行任何位置，自动删除本行的回车键和空格，将下一行字符连接到本行) Ctrl+Enter 智能分行(和Enter键的区别：光标不动，在本行下面新增一行) Shift + Enter 开始新的一行(相当于在行末按Enter键) Ctrl + Shift + U 变换光标所在处/代码块的字母的大小写状态 Ctrl + Shift + ] / [ 从光标处在处开始选择到最近] / [的代码块 Ctrl + Delete 删除光标后的一个单词 Ctrl + Backspace 删除光标前的一个单词 Ctrl + NumPad+/- 展开/收缩代码块 Ctrl + Shift+数字键盘的+ 展开所有代码块 Ctrl + Shift+数字键盘的- 折叠所有代码块 Ctrl + F4 关闭当前tab页 *搜索和替换 双击Shift 万能搜索 Ctrl + F 查找 F3 查找下一个 Shift + F3 查找上一个 Ctrl + R 替换 Ctrl + Shift + F 在指定路径中的文件中查找内容 Ctrl + Shift + R 在指定路径中的文件中替换内容 Ctrl + Shift + S Search structurally (Ultimate Edition only) Ctrl + Shift + M Replace structurally (Ultimate Edition only) *代码方法/变量使用处搜索 Alt + F7 查找当前文件变量/方法的使用处 Ctrl+F7 查找当前项目变量/方法的使用处 Ctrl +Shift+ F7 高亮显示变量/方法名在当前文件的所有使用处 Ctrl + Alt + F7 弹窗显示变量/方法名在当前文件的使用处列表 *编译和运行 Ctrl + F9 Make项目(修改编译和依赖) Ctrl + Shift + F9 编译文件、包或者模块 Alt + Shift + F10 选择配置并运行 Alt + Shift + F9 选择配置并调试 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 配置编辑器运行环境 *调式 调试： F8 Step over (步越：越过子函数，但子函数会执行) F7 Step into (步进：进入子函数) Shift + F7 Smart step into(智能步进) Shift + F8 Step out (跳出：跳出子函数) Alt + F9 Run to cursor (运行到光标处) Alt + F8 Evaluate expression (计算表达式？) F9 Resume program (恢复程序) Ctrl + F8 Toggle breakpoint (切换断点) Ctrl + Shift + F8 View breakpoints (查看断点) *导航 Ctrl + N 跳转到某个类文件 Ctrl + Shift + N 跳转到某个文件 Ctrl + Alt + Shift + N 跳转到某个标识符处，包括类名，方法，变量 Alt + 左/右 箭头 切换到左边/右边的编辑标签 F12 打开上一次打开的工具窗口 Esc 从工具窗口回到编辑窗口 Shift + Esc 隐藏活动的工具窗口并回到编辑窗口中 Ctrl+Shift+F4 关闭活动的run/messages/find/…窗口 Ctrl+G 跳转到某行 Ctrl+E 弹出一个菜单，上面包含最近打开的文件和工具窗 Ctrl+Alt + 向左/向右 箭头 跳转到上一个/下一个 Ctrl+Shift+Backspace 跳转到上一次做出修改的地方 Alt + F1 (实际应该是快捷菜单栏吧？) Ctrl + B or Ctrl + Click 跳转到方法或者变量的声明处 Ctrl + Alt + B 跳转到implements方法或者接口的地方 Ctrl + Shift + I 打开类/方法/变量的文档说明窗口 Ctrl + Shift + B 查看类型的声明 (例如：定义一个String字符串，将跳到String类中) Ctrl + U 跳转到super-method/super-class处 Alt + Up/Down 跳转到上一个/下一个方法的第一行处 Ctrl + ] / [ 移动光标到最近的] / [位置 Ctrl + F12 弹出文件的结构窗口 (方法、常量等) Ctrl + H 光标所在处的方法所属的类的继承层级制度 Ctrl + Shift + H 方法的层级制度 Ctrl + Alt + H 方法调用的层级制度 F2 / Shift + F2 跳转到下一个/上一个错误处并高亮显示 F4 / Ctrl + Enter 查看/改变源代码(Ctrl + Enter功能键冲突) Alt + Home 打开路径导航条 F11 设置/取消书签 Ctrl + F11 设置带数字/字母编号的书签 Ctrl + #[0-9] 跳转到[0-9]编号的书签处 Shift + F11 在弹出窗口中显示所有的书签 *重构 F5 复制 F6 移动 Alt + Delete 安全删除 Shift + F6 重命名 (批量) Ctrl + F6 修改方法(修饰符、方法名、参数列表、返回值、异常等) Ctrl + Alt + N 内嵌(可以将变量替换为其他内容) Ctrl + Alt + M 提取成方法 Ctrl + Alt + V 提取成变量 Ctrl + Alt + F 提取成字段 Ctrl + Alt + C 提取成常量 Ctrl + Alt + P 提取成参数 *版本控制和本地历史(VCS/Local History) Ctrl + K 提交项目到vcs Ctrl + T 从vcs中更新项目 Alt + Shift + C 查看最近更新 Alt + ` (反引号) vcs快速设置弹出菜单 *Live模板 Ctrl + Alt + J 用Live模板包围光标所在行的代码 Ctrl + J 插入Live模板 iter 使用JDK1.5风格迭代容器 inst 用instanceof检查对你的类型并向下转换对象 itco 遍历java.util.Collection集合的元素 itit 遍历java.util.Iterator集合的元素 itli 遍历java.util.List集合的元素 psf public static final thr throw new 更多Live模板查看：Settings—Editor—Live Templates *通用快捷键 Alt + #[0-9] 打开相对应的工具窗口 Ctrl + S 保存全部 Ctrl + Alt + Y 同步 Ctrl + Shift + F12 编辑器最大化 Alt + Shift + F 添加到最喜欢 Alt + Shift + I 根据当前配置文件审查当前文件 Ctrl + BackQuote (`) 快速切换代码颜色主题 Ctrl + Alt + S 打开设置 Ctrl + Alt + Shift + S 打开项目结构对话框，在这里可以删除模块 Ctrl + Tab 在已打开的文件和工具窗口之间切换 Ctrl + Shift + A 查找所有快捷操作（基本所有的动作在这里都可以找到） Ctrl+Z 撤销 Ctrl+Shift+Z 恢复Ctrl+Z掉的内容]]></content>
      <categories>
        <category>开发工具及技术</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA下lombok安装,@Data get,set找不到的问题]]></title>
    <url>%2F2019%2F09%2F06%2Fexception1%2F</url>
    <content type="text"><![CDATA[参考链接 Idea下安装lombok(需要两步)第一步： pom.xml中加入lombok依赖包1234567&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 第二步：加入lombok插件步骤：File ——》Settings——》Plugins. 搜索lombok，点击安装install。然后会提示重启，重启。 解决编译时无法找到set和get 的问题 IDEA的编译方式选项错误，应该是javac，而不是eclipse。 1因为eclipse是不支持lombok的编译方式的，javac支持lombok的编译方式。 没有打开注解生成器Enable annotation processing pom.xml中加入的lombok依赖包版本和自动安装的plugin中的lombok依赖包版本不一致因为我们添加的lombok插件plugin，点击insall时是自动安装的最新版本的lombok。 但是在pom.xml中的依赖包是maven中的低1.16.20的一个依赖包，版本不一致，造成了无法找到set和get.]]></content>
      <categories>
        <category>Exception</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[您的主机中的软件中止了一个已建立的连接]]></title>
    <url>%2F2019%2F09%2F06%2Fexception%2F</url>
    <content type="text"><![CDATA[参考链接 异常显示 123456789org.apache.catalina.connector.ClientAbortException: java.io.IOException: 您的主机中的软件中止了一个已建立的连接。 at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:396) at org.apache.tomcat.util.buf.ByteChunk.flushBuffer(ByteChunk.java:426) at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:345) at org.apache.catalina.connector.OutputBuffer.flush(OutputBuffer.java:320) at org.apache.catalina.connector.CoyoteOutputStream.flush(CoyoteOutputStream.java:110) at com.fasterxml.jackson.core.json.UTF8JsonGenerator.flush(UTF8JsonGenerator.java:1022) at com.fasterxml.jackson.databind.ObjectMapper.writeValue(ObjectMapper.java:2376) at ······ 原因 在tomcat中出现这个错误是由于客户端在发送请求后，还没等服务器响应就断开了连接，有可能是因为网络原因，突然网断了，但是如果错误频繁出现的话，可能就是服务端的问题了。 tomcat中配置了一个连接超时时间connectionTimeout,如果在这个时间之后客户端还未得到服务器端的响应的话,就会主动断开连接,这样就会出现上述异常了,tomcat中默认的连接超时时间是20秒,我们一般最好设置为60秒,从而避免后台程序处理时间长导致连接断开 解决方法 可以通过设置tomcat下conf文件夹的server.xml文件，对请求连接数和请求超时时间进行设置。 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;60000&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;500&quot; maxThreads=&quot;400&quot; /&gt; connectionTimeout以毫秒为单位，默认设置为20秒。通过修改该参数，可以修改tomcat的请求超时时间为60秒。 关于修改最大并发请求连接数，需要修改maxThreads和acceptCount两个参数。 其中，maxThreads的介绍如下： The maximum number of request processing threads to be created by this Connector, which therefore determines the maximum number of simultaneous requests that can be handled. If not specified, this attribute is set to 200. If an executor is associated with this connector, this attribute is ignored as the connector will execute tasks using the executor rather than an internal thread pool. 此连接器要创建的请求处理线程的最大数量，因此决定可以处理的并发请求的最大数量。如果没有指定，则将此属性设置为200。如果执行器与此连接器关联，则忽略此属性，因为连接器将使用执行器而不是内部线程池执行任务。 而acceptCount的介绍为： The maximum queue length for incoming connection requests when all possible request processing threads are in use. Any requests received when the queue is full will be refused. The default value is 100. 使用所有可能的请求处理线程时传入连接请求的最大队列长度。队列满时接收到的任何请求都将被拒绝。默认值是100。 所以两者的默认值分别是200和100，要调整Tomcat的默认最大连接数，可以增加这两个属性的值，并且使acceptCount大于等于maxThreads。]]></content>
      <categories>
        <category>Exception</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
</search>
